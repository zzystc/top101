# top101

## 01链表

### BM1 反转链表

给定一个长度为n的链表，反转该链表，输出表头

方法一：迭代（推荐使用）
具体做法：

step 1：优先处理空链表，空链表不需要反转。
step 2：我们可以设置两个指针，一个当前节点的指针，一个上一个节点的指针（初始为空）。
step 3：遍历整个链表，每到一个节点，断开当前节点与后面节点的指针，并用临时变量记录后一个节点，然后当前节点指向上一个节点。
step 4：再轮换当前指针与上一个指针，让它们进入下一个节点及下一个节点的前序节点。

```
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param head ListNode类 
# @return ListNode类
#
class Solution:
    def ReverseList(self , head: ListNode) -> ListNode:
        # write code here
        pre = None
        phead = head
        while phead:
            temp = phead.next
            phead.next = pre
            pre = phead
            phead = temp
        return pre
```

复杂度分析：

时间复杂度：O（N），遍历链表一次

空间复杂度：O（1），无额外空间使用

### BM2.链表内指定区间反转

题目的主要信息：
将一个节点数为 size 链表 m 位置到 n 位置之间的区间反转
链表其他部分不变，返回头节点
方法一：头插法迭代（推荐使用）
具体做法：

肯定是要先找到了第m个位置才能开始反转链表，而反转的部分就是从第m个位置到第n个位置。

step 1：我们可以在链表前加一个表头，后续返回时去掉就好了，因为如果要从链表头的位置反转，也很方便。
step 2：使用两个指针，一个指向当前节点，一个指向前序节点。
step 3：依次遍历链表，到第m个的位置。
step 4：对于从m到n这些个位置的节点，依次断掉指向后续的指针，反转指针方向。
step 5：返回时去掉我们添加的表头。

```
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param head ListNode类 
# @param m int整型 
# @param n int整型 
# @return ListNode类
#
class Solution:
    def reverseBetween(self , head: ListNode, m: int, n: int) -> ListNode:
        #加个表头
        res = ListNode(-1)
        res.next = head
        #前序节点
        pre = res 
        #当前节点
        cur = head 
        #找到m
        for i in range(1,m): 
            pre = cur
            cur = cur.next
        #从m反转到n
        for i in range(m, n): 
            temp = cur.next
            cur.next = temp.next
            temp.next = pre.next
            pre.next = temp
        #返回去掉表头
        return res.next 
```

复杂度分析：

时间复杂度：O(n)，最坏情况下递归遍历全部链表节点，比如m为链表最后一个位置，或者n为链表最后一个位置时

空间复杂度：O(n)，遍历全部节点时递归栈深度最坏为n

### BM3.链表中的节点每k个一组翻转

题目主要信息:
给定一个链表，从头开始每k个作为一组，将每组的链表结点翻转
组与组之间的位置不变
如果最后链表末尾剩余不足k个元素，则不翻转，直接放在最后
方法：递归（推荐使用）
具体做法：

step 1：现在我们想一想，如果拿到一个链表，想要像上述一样分组翻转应该做些什么？首先肯定是分段吧，至少我们要先分成一组一组，才能够在组内翻转。分组很容易，只要每次遍历k个元素，就是一组。
step 2：然后是组内翻转，翻转完了再连接起来。翻转即指定区间内的翻转，也很容易，可以参考链表指定区间内的翻转。
step 3：最后是将反转后的分组连接，但是连接的时候遇到问题了：首先如果能够翻转，链表第一个元素一定是第一组，它翻转之后就跑到后面去了，而第一组的末尾元素才是新的链表首，我们要返回的也是这个元素，而原本的链表首要连接下一组翻转后的头部，即翻转前的尾部，如果不建立新的链表，看起来就会非常难。
step 4：如果我们从最后的一个组开始翻转，得到了最后一个组的链表首，是不是可以直接连在倒数第二个组翻转后的尾（即翻转前的头）后面，是不是看起来就容易多了。
怎样从后往前呢？我们这时候可以用到自上而下再自下而上的递归或者说栈。接下来我们说说为什么能用递归？如果这个链表有n个分组可以翻转，我们首先对第一个分组翻转，那么是不是接下来将剩余n-1个分组翻转后的结果接在第一组后面就行了，那这剩余的n-1组就是一个子问题。我们来看看递归的三段式模版：

终止条件： 当进行到最后一个分组，即不足k次遍历到链表尾（0次也算），就将剩余的部分直接返回。
返回值： 每一级要返回的就是翻转后的这一分组的头，以及连接好它后面所有翻转好的分组链表。
本级任务： 对于每个子问题，先遍历k次，找到该组结尾在哪里，然后从这一组开头遍历到结尾，依次翻转，结尾就可以作为下一个分组的开头，而先前指向开头的元素已经跑到了这一分组的最后，可以用它来连接它后面的子问题，即后面分组的头。

```
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param head ListNode类 
# @param k int整型 
# @return ListNode类
#
class Solution:
    def reverseKGroup(self , head: ListNode, k: int) -> ListNode:
        #找到每次翻转的尾部
        tail = head 
        #遍历k次到尾部
        for i in range(0,k): 
            #如果不足k到了链表尾，直接返回，不翻转
            if tail == None: 
                return head
            tail = tail.next
        #翻转时需要的前序和当前节点
        pre = None 
        cur = head
        #在到达当前段尾节点前
        while cur != tail: 
            #翻转
            temp = cur.next 
            cur.next = pre
            pre = cur
            cur = temp
        #当前尾指向下一段要翻转的链表
        head.next = self.reverseKGroup(tail, k) 
        return pre
```

复杂度分析：

时间复杂度：O(n)，一共遍历链表n个节点

空间复杂度：O(n)，递归栈最大深度为n/k

### BM4. 合并有序链表

题目的主要信息：
两个元素值递增的链表，单个链表的长度为n
合并这两个链表并使新链表中的节点仍然是递增排序的
方法一：迭代（推荐使用）
具体做法：

既然两个链表已经是排好序的，都是从小到大的顺序，那我们要将其组合，可以使用归并排序的思想：每次比较两个头部，从中取出最小的元素，然后依次往后。这样就能最快速地将最小的元素依次取出来排好序。

step 1：判断空链表的情况，只要有一个链表为空，那答案必定就是另一个链表了，就算另一个链表也为空。
step 2：新建一个空的表头后面连接两个链表排序后的结点。
step 3：遍历两个链表都不为空的情况，取较小值添加在新的链表后面，每次只把被添加的链表的指针后移。
step 4：遍历到最后肯定有一个链表还有剩余的结点，它们的值将大于前面所有的，直接连在新的链表后面即可。

```
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param pHead1 ListNode类 
# @param pHead2 ListNode类 
# @return ListNode类
#
class Solution:
    def Merge(self, pHead1, pHead2):
        # write code here
        dummy = cur = ListNode(0)
        while pHead1 and pHead2:
            if pHead1.val <pHead2.val:
                cur.next = pHead1
                pHead1 = pHead1.next
            else:
                cur.next = pHead2
                pHead2 =pHead2.next
            cur = cur.next
        cur.next = pHead1 or pHead2
        return dummy.next
```

复杂度分析：

时间复杂度：O（n），最坏情况遍历2*n个结点
空间复杂度：O（1），无额外空间使用，新建的链表属于返回必要空间

### BM5. 合并k个已排序的链表

题目的主要信息：
给定k个排好序的升序链表
将这k个链表合并成一个大的升序链表，并返回这个升序链表的头
方法一：归并排序思想（推荐使用）
具体做法：

如果是两个有序链表合并，我们可能会利用归并排序合并阶段的思想：准备双指针分别放在两个链表头，每次取出较小的一个元素加入新的大链表，将其指针后移，继续比较，这样我们出去的都是最小的元素，自然就完成了排序。

其实这道题我们也可以两两比较啊，只要遍历链表数组，取出开头的两个链表，按照上述思路合并，然后新链表再与后一个继续合并，如此循环，知道全部合并完成。但是，这样太浪费时间了。

既然都是归并排序的思想了，那我们可不可以直接归并的分治来做，而不是顺序遍历合并链表呢？答案是可以的！

归并排序是什么？简单来说就是将一个数组每次划分成等长的两部分，对两部分进行排序即是子问题。对子问题继续划分，直到子问题只有1个元素。还原的时候呢，将每个子问题和它相邻的另一个子问题利用上述双指针的方式，1个与1个合并成2个，2个与2个合并成4个，因为这每个单独的子问题合并好的都是有序的，直到合并成原本长度的数组。

step 1：对于这k个链表，就相当于上述合并阶段的k个子问题，需要两个合并，不断往上，最终合并成完整的一个链表。
step 2：从链表数组的首和尾开始，每次划分从中间开始划分，划分成两半。
step 3：将这两半子问题合并好了就成了两个有序链表，最后将这两个有序链表合并就成了，依据子问题递归处理。
终止条件： 划分的时候直到左右区间相等或事左边大于右边。
返回值： 每级返回已经合并好的子问题链表。
本级任务： 对半划分，将划分后的子问题合并成新的链表。

```
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param lists ListNode类一维数组 
# @return ListNode类
#
# import sys
#设置递归深度
# sys.setrecursionlimit(100000) 

class Solution:
    #两个有序链表合并函数
    def Merge2(self, pHead1: ListNode, pHead2: ListNode) -> ListNode: 
        #一个已经为空了，直接返回另一个
        if pHead1 == None: 
            return pHead2
        if pHead2 == None:
            return pHead1
        #加一个表头
        head = ListNode(0) 
        cur = head
        #两个链表都要不为空
        while pHead1 and pHead2: 
            #取较小值的节点
            if pHead1.val <= pHead2.val: 
                cur.next = pHead1
                #只移动取值的指针
                pHead1 = pHead1.next 
            else:
                cur.next = pHead2
                #只移动取值的指针
                pHead2 = pHead2.next 
            #指针后移
            cur = cur.next 
        #哪个链表还有剩，直接连在后面
        if pHead1: 
            cur.next = pHead1
        else:
            cur.next = pHead2
        #返回值去掉表头
        return head.next 
    
    #划分合并区间函数
    def divideMerge(self, lists: List[ListNode], left: int, right: int) -> ListNode:         
        if left > right :
            return None
        #中间一个的情况
        elif left == right: 
            return lists[left]
        #从中间分成两段，再将合并好的两段合并
        mid = (int)((left + right) / 2) 
        return self.Merge2(self.divideMerge(lists, left, mid), self.divideMerge(lists, mid + 1, right))
    
    def mergeKLists(self , lists: List[ListNode]) -> ListNode:
        #k个链表归并排序
        return self.divideMerge(lists, 0, len(lists) - 1) 
```

复杂度分析：

时间复杂度：O(n*k)，其中n为所有链表的总节点数，最坏情况下每次合并都是O(n)，分治为二叉树型递归，每个节点都要使用一次合并，需要合并k-1次
空间复杂度：O(log~2~k)，最坏情况下递归log~2~k层，需要log~2~k的递归栈

### BM6. 判断链表中是否有环

题目主要信息:
给定一个链表的头节点，判断这个链表是否有环

方法：双指针（推荐使用）
具体做法：

我们都知道链表不像二叉树，每个节点只有一个val值和一个next指针，也就是说一个节点只能有一个指针指向下一个节点，不能有两个指针，那这时我们就可以说一个性质：环形链表的环一定在末尾，末尾没有NULL了。为什么这样说呢？仔细看上图，在环2，0，-4中，没有任何一个节点可以指针指出环，它们只能在环内不断循环，因此环后面不可能还有一条尾巴。如果是普通线形链表末尾一定有NULL，那我们可以根据链表中是否有NULL判断是不是有环。

但是，环形链表遍历过程中会不断循环，线形链表遍历到NULL结束了，但是环形链表何时能结束呢？我们可以用一种双指针技巧，这也是处理环形链表常用的技巧：

step 1：设置快慢两个指针，初始都指向链表头。
step 2：遍历链表，快指针每次走两步，慢指针每次走一步。
step 3：如果快指针到了链表末尾，说明没有环，因为它每次走两步，所以要验证连续两步是否为NULL。
step 4：如果链表有环，那快慢双指针会在环内循环，因为快指针每次走两步，因此快指针会在环内追到慢指针，二者相遇就代表有环。

```
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

#
# 
# @param head ListNode类 
# @return bool布尔型
#
class Solution:
    def hasCycle(self , head: ListNode) -> bool:
        #先判断链表为空的情况
        if head == None: 
            return False
        #快慢双指针
        fast = head 
        slow = head
        #如果没环快指针会先到链表尾
        while fast != None and fast.next != None: 
            #快指针移动两步
            fast = fast.next.next 
            #慢指针移动一步
            slow = slow.next 
            #相遇则有环
            if fast == slow: 
                return True
        #到末尾则没有环
        return False 
```

复杂度分析：

时间复杂度：O(n)，最坏情况下遍历链表n个节点
空间复杂度：O(1)，仅使用了两个指针，没有额外辅助空间

### BM7. 链表中环的入口节点

题目主要信息:
给定一个链表，首先判断其是否有环，然后找到环的入口
方法：双指针（推荐使用）
具体做法：

根据题干，不说别的，我们能发现这道题需要完成两个任务：

判断链表是否有环。
在有环的链表中找到环的入口。
对于第一个任务，可以参考判断链表中是否有环，主要思想是利用环没有末尾NULL，后半部分一定是环，然后快慢双指针相遇就代表有环。（具体分析可以参考BM6）

那我们现在假定已经是一个有环的链表了，那么这个链表中怎么找到环的入口呢？在慢指针进入链表环之前，快指针已经进入了环，且在里面循环，这才能在慢指针进入环之后，快指针追到了慢指针，不妨假设快指针在环中走了n圈，慢指针在环中走了m圈，它们才相遇，而进入环之前的距离为x，环入口到相遇点的距离为y，相遇点到环入口的距离为z。快指针一共走了x+n(y+z)+y步，慢指针一共走了x+m(y+z)+y，这个时候快指针走的倍数是慢指针的两倍，则x+n(y+z)+y=2(x+m(y+z)+y)，这时候x+y=(n−2m)(y+z)，因为环的大小是y+z，说明从链表头经过环入口到达相遇地方经过的距离等于整数倍环的大小：那我们从头开始遍历到相遇位置，和从相遇位置开始在环中遍历，会使用相同的步数，而双方最后都会经过入口到相遇位置这y个节点，那说明这y个节点它们就是重叠遍历的，那它们从入口位置就相遇了，这我们不就找到了吗？

step 1：使用判断链表中是否有环中的方法判断链表是否有环，并找到相遇的节点。
step 2：慢指针继续在相遇节点，快指针回到链表头，两个指针同步逐个元素逐个元素开始遍历链表。
step 3：再次相遇的地方就是环的入口。

```
# -*- coding:utf-8 -*-
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None
class Solution:
    def EntryNodeOfLoop(self, pHead):
        # write code here
        slow = self.hasCycle(pHead)
        #没有环
        if slow == None: 
            return None
        #快指针回到表头
        fast = pHead 
        #再次相遇即是环入口
        while fast != slow: 
            fast = fast.next
            slow = slow.next
        return slow
    
    def hasCycle(self , head):
        #先判断链表为空的情况
        if head == None: 
            return None
        #快慢双指针
        fast = head 
        slow = head
        #如果没环快指针会先到链表尾
        while fast != None and fast.next != None: 
            #快指针移动两步
            fast = fast.next.next 
            #慢指针移动一步
            slow = slow.next 
            #相遇则有环
            if fast == slow: 
                #返回相遇的地方
                return slow 
        #到末尾则没有环
        return None 
```

复杂度分析：

时间复杂度：O(n)，最坏情况下遍历链表两次
空间复杂度：O(1)，使用了常数个指针，没有额外辅助空间

### BM8. 链表中倒数最后k个结点

题目的主要信息：
一个长度为n的链表，返回原链表中从倒数第k个结点至尾节点的全部节点
如果该链表长度小于k，请返回一个长度为 0 的链表
方法一：快慢双指针（推荐使用）
具体做法：

我们无法逆序遍历链表，就很难得到链表的倒数第k个元素，那我们可以试试反过来考虑，如果当前我们处于倒数第k的位置上，即距离链表尾的距离是k，那我们假设双指针指向这两个位置，二者同步向前移动，当前面个指针到了链表头的时候，两个指针之间的距离还是k。虽然我们没有办法让指针逆向移动，但是我们刚刚这个思路却可以正向实施：

step 1：准备一个快指针，从链表头开始，在链表上先走k步。
step 2：准备慢指针指向原始链表头，代表当前元素，则慢指针与快指针之间的距离一直都是k。
step 3：快慢指针同步移动，当快指针到达链表尾部的时候，慢指针正好到了倒数个元素的位置。

```
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param pHead ListNode类 
# @param k int整型 
# @return ListNode类
#
class Solution:
    def FindKthToTail(self , pHead: ListNode, k: int) -> ListNode:
        # write code here
        fast = pHead
        slow = pHead
        #快指针先行k步
        for i in range(0,k): 
            if fast != None:
                fast = fast.next
            #达不到k步说明链表过短，没有倒数k
            else: 
                return None
        #快慢指针同步，快指针先到底，慢指针指向倒数第k个
        while fast:
            fast = fast.next
            slow = slow.next
        return slow
```

复杂度分析：

时间复杂度：O(n)，总共遍历n个链表元素
空间复杂度：O(1)，常数级指针变量，无额外辅助空间使用

### BM9. 删除链表的倒数第n个节点

题目的主要信息：
给定一个链表，要删除链表倒数第n个节点，并返回链表的头
题目保证链表长度一定大于等于n
方法一：双指针（推荐使用）
具体做法：

我们无法逆序遍历链表，就很难得到链表的倒数第n个元素，那我们可以试试反过来考虑，如果当前我们处于倒数第n的位置上，即距离链表尾的距离是n，那我们假设双指针指向这两个位置，二者同步向前移动，当前面个指针到了链表头的时候，两个指针之间的距离还是n。虽然我们没有办法让指针逆向移动，但是我们刚刚这个思路却可以正向实施：

step 1：给链表添加一个表头，处理删掉第一个元素时比较方便。
step 2：准备一个快指针，在链表上先走n步。
step 3：准备慢指针指向原始链表头，代表当前元素，前序节点指向添加的表头，这样两个指针之间相距就是一直都是n。
step 4：快慢指针同步移动，当快指针到达链表尾部的时候，慢指针正好到了倒数n个元素的位置。

```
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param head ListNode类 
# @param n int整型 
# @return ListNode类
#
class Solution:
    def removeNthFromEnd(self , head: ListNode, n: int) -> ListNode:
        # write code here
        #添加表头
        res = ListNode(-1) 
        res.next = head
        #当前节点
        cur = head 
        #前序节点
        pre = res 
        fast = head
        #快指针先行n步
        while n: 
            fast = fast.next
            n = n - 1
        #快慢指针同步，快指针到达末尾，慢指针就到了倒数第n个位置
        while fast: 
            fast = fast.next
            pre = cur
            cur = cur.next
        #删除该位置的节点
        pre.next = cur.next 
        #返回去掉头
        return res.next 
```

复杂度分析：

时间复杂度：O(n)，其中n为链表长度，最坏情况遍历整个链表1次
空间复杂度：O(1)，常数级指针，无额外辅助空间使用

### BM10. 两个链表的第一个公共结点

题目中的信息：
两个链表含有公共结点或没有，有公共结点则返回第一公共结点指针
单链表，无循环
没有公共节点返回空
方法一：双指针长度比较法（推荐使用）
具体做法：

如果两个链表有公共节点，那么它们后半部分都是相同的，我们要找的也就是后半部分的第一个节点，只要遍历两个指针同时抵达第一个相同的节点，我们就找到了它。

step 1：单独的遍历两个链表，得到各自的长度。
step 2：求得两链表的长度差n，其中较长的链表的指针从头先走n步。
step 3：两链表指针同步向后遍历，遇到第一个相同的节点就是第一个公共结点。

```
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

#
# 
# @param pHead1 ListNode类 
# @param pHead2 ListNode类 
# @return ListNode类
#
class Solution:
    def FindFirstCommonNode(self , pHead1 , pHead2 ):
        # write code here
        count1 = 0
        count2 = 0
        temp1 = pHead1
        temp2 = pHead2
        while temp1:
            temp1 = temp1.next 
            count1 += 1
        while temp2:
            temp2 = temp2.next 
            count2 += 1
        if count1 > count2:
            count1,count2 = count2,count1 
            pHead1,pHead2 = pHead2,pHead1
        delta = count2 - count1
        
        i = 1
        while i <= delta:
            pHead2 = pHead2.next
            i += 1
        while pHead1 != pHead2:
            pHead1 = pHead1.next
            pHead2 = pHead2.next
        return pHead1
```

复杂度分析：

时间复杂度：O(n)，其中n为两链表较长者的长度，虽是多次循环，但都为单循环，取最大值即为O(n)
空间复杂度：O(1)，没有其他空间申请

### BM11. 两个链表生成相加链表

题目主要信息:
给定两个链表，每个链表中节点值都是0-9，每个链表就可以表示一个数字
将两个链表表示的数字相加，结果也存在链表中
方法：反转链表法（推荐使用）
具体做法：

既然链表每个节点表示数字的每一位，那相加的时候自然可以按照加法法则，从后往前依次相加。但是，链表是没有办法逆序访问的，这是我们要面对第一只拦路虎。解决它也很简单，既然从后往前不行，那从前往后总是可行的吧，将两个链表反转一下，即可得到个十百千……各个数字从前往后的排列，相加结果也是个位在前，怎么办？再次反转，结果不就正常了。

step 1：任意一个链表为空，返回另一个链表就行了，因为链表为空相当于0，0加任何数为0，包括另一个加数为0的情况。
step 2：相继反转两个待相加的链表，反转过程可以参考反转链表。
step 3：设置返回链表的链表头，设置进位carry=0.
step 4：从头开始遍历两个链表，直到两个链表节点都为空且carry也不为1. 每次取出不为空的链表节点值，为空就设置为0，将两个数字与carry相加，然后查看是否进位，将进位后的结果（对10取模）加入新的链表节点，连接在返回链表后面，并继续往后遍历。
step 5：返回前将结果链表再反转回来。

```
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param head1 ListNode类 
# @param head2 ListNode类 
# @return ListNode类
#
class Solution:
    #反转链表
    def ReverseList(self, pHead:ListNode): 
        if pHead == None:
            return None
        cur = pHead
        pre = None
        while cur:
            #断开链表，要记录后续一个
            temp = cur.next 
            #当前的next指向前一个
            cur.next = pre 
            #前一个更新为当前
            pre = cur 
            #当前更新为刚刚记录的后一个
            cur = temp 
        return pre
    
    def addInList(self , head1: ListNode, head2: ListNode) -> ListNode:
        #任意一个链表为空，返回另一个
        if head1 == None: 
            return head2
        if head2 == None:
            return head1
        #反转两个链表
        head1 = self.ReverseList(head1) 
        head2 = self.ReverseList(head2)
        #添加表头
        res = ListNode(-1) 
        head = res
        #进位符号
        carry = 0 
        #只要某个链表还有或者进位还有
        while head1 != None or head2 != None or carry != 0: 
            #链表不为空则取其值
            val1 = 0 if head1 == None else head1.val 
            val2 = 0 if head2 == None else head2.val
            #相加
            temp = val1 + val2 + carry 
            #获取进位
            carry = (int)(temp / 10) 
            temp %= 10
            #添加元素
            head.next = ListNode(temp) 
            head = head.next
            #移动下一个
            if head1: 
                head1 = head1.next
            if head2:
                head2 = head2.next
        #结果反转回来
        return self.ReverseList(res.next) 
```

复杂度分析：

时间复杂度：O(max(m,n))，其中m与n分别为两个链表的长度，翻转链表三次，复杂度分别是O(n)、O(m)、O(max(m,n))，相加过程也是遍历较长的链表
空间复杂度：O(1)，常数级指针，没有额外辅助空间，返回的新链表属于必要空间

### BM12. 单链表的排序

题目的主要信息：
给定一个无序链表，要将其排序为升序链表
方法一：归并排序（推荐使用）
具体做法：

前面我们做合并两个有序链表不是使用归并思想吗？说明在链表中归并排序也不是不可能使用，合并阶段可以参照前面这道题，两个链表逐渐取最小的元素就可以了，但是划分阶段呢？

常规数组的归并排序，是将数组从中间个元素开始划分，然后将划分后的子数组作为一个要排序的数组，再将排好序的两个子数组合并成一个完整的有序数组，因此采用的是递归。而链表中我们也可以用同样的方式，只需要找到中间个元素的前一个节点，将其断开，就可以将链表分成两个子链表，然后继续划分，直到最小，然后往上依次合并。

step 1：首先判断链表为空或者只有一个元素，直接就是有序的。

step 2：准备三个指针，快指针right每次走两步，慢指针mid每次走一步，前序指针left每次跟在mid前一个位置。三个指针遍历链表，当快指针到达链表尾部的时候，慢指针mid刚好走了链表的一半，正好是中间位置。

step 3：从left位置将链表断开，刚好分成两个子问题开始递归。

终止条件： 当子链表划分到为空或者只剩一个节点时，不再继续划分，往上合并。
返回值： 每次返回两个排好序且合并好的子链表。
本级任务： 找到这个链表的中间节点，从前面断开，分为左右两个子链表，进入子问题排序。
step 4：将子问题得到的链表合并，参考合并两个有序链表。

```
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param head ListNode类 the head node
# @return ListNode类
#
class Solution:
    #合并两段有序链表
    def merge(self, pHead1:ListNode, pHead2:ListNode) : 
        #一个已经为空了，直接返回另一个
        if pHead1 == None: 
            return pHead2
        if pHead2 == None:
            return pHead1
        #加一个表头
        head = ListNode(0) 
        cur = head
        #两个链表都要不为空
        while pHead1 and pHead2: 
            #取较小值的节点
            if pHead1.val <= pHead2.val: 
                cur.next = pHead1
                #只移动取值的指针
                pHead1 = pHead1.next 
            else:
                cur.next = pHead2
                #只移动取值的指针
                pHead2 = pHead2.next 
            #指针后移
            cur = cur.next 
        #哪个链表还有剩，直接连在后面
        if pHead1: 
            cur.next = pHead1
        else:
            cur.next = pHead2
        #返回值去掉表头
        return head.next 
    
    def sortInList(self , head ):
        #链表为空或者只有一个元素，直接就是有序的
        if head == None or head.next == None: 
            return head
        left = head
        mid = head.next
        right = head.next.next
        #右边的指针到达末尾时，中间的指针指向该段链表的中间
        while right and right.next:
            left = left.next
            mid = mid.next
            right = right.next.next
        #左边指针指向左段的左右一个节点，从这里断开
        left.next = None 
        #分成两段排序，合并排好序的两段
        return self.merge(self.sortInList(head), self.sortInList(mid)) 
```

复杂度分析：

时间复杂度：O(nlog2n)，每级划分最坏需要遍历链表全部元素，因此为O(n)，每级合并都是将同级的子问题链表遍历合并，因此也为O(n)，分治划分为二叉树型，一共有O(log2n)层，因此复杂度为O((n+n)∗log2n)=O(nlog2n)
空间复杂度：O(log2n)，递归栈的深度最坏为树型递归的深度，log2n层

### BM13. 判断一个链表是否为回文结构

题目的主要信息：
给定一个链表的头节点，判读该链表是否为回文结构
回文结构即正序遍历与逆序遍历结果都是一样的，类似123321
空链表默认为回文结构

方法四：双指针找中点（推荐使用）
具体做法：

上述方法四找中点，我们遍历整个链表找到长度，又遍历长度一半找中点位置。过程过于繁琐，我们想想能不能优化一下，一次性找到中点。

我们首先来看看中点的特征，一个链表的中点，距离链表开头是一半的长度，距离链表结尾也是一半的长度，那如果从链表首遍历到链表中点位置，另一个每次遍历两个节点的指针是不是就到了链表尾，那这时候我们的快慢双指针就登场了：

step 1：慢指针每次走一个节点，快指针每次走两个节点，快指针到达链表尾的时候，慢指针刚好到了链表中点。
step 2：从中点的位置，开始往后将后半段链表反转。
step 3：按照方法四的思路，左右双指针，左指针从链表头往后遍历，右指针从链表尾往反转后的前遍历，依次比较遇到的值。

```
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param head ListNode类 the head
# @return bool布尔型
#
class Solution:
    #反转链表指针
    def reverse(self, head:ListNode): 
        #前序节点
        prev = None 
        while head:
            #断开后序
            next = head.next 
            #指向前序
            head.next = prev 
            prev = head
            head = next
        return prev
    
    def isPail(self , head: ListNode) -> bool:
        #空链表直接为回文
        if head == None:  
            return True
        #准备快慢双指针
        slow = head 
        fast = head
        #双指针找中点
        while fast and fast.next: 
            slow = slow.next
            fast = fast.next.next
        #中点处反转
        slow = self.reverse(slow) 
        fast = head
        while slow:
            #比较判断节点值是否相等
            if slow.val != fast.val: 
                return False
            fast = fast.next
            slow = slow.next
        return True
```

复杂度分析：

时间复杂度：O(n)，其中n为链表的长度，双指针找到中点遍历半个链表，后续反转链表为O(n)，然后再遍历两份半个链表
空间复杂度：O(1)，常数级变量，没有额外辅助空间

### BM14 链表的奇偶重排

题目主要信息:
给定一个链表，将奇数位的节点依次连在前半部分，偶数位的节点依次连在后半部分
返回连接后的链表头
方法：双指针（推荐使用）
具体做法：

如下图所示，第一个节点是奇数位，第二个节点是偶数，第二个节点后又是奇数位，因此可以断掉节点1和节点2之间的连接，指向节点2的后面即节点3，如红色箭头。如果此时我们将第一个节点指向第三个节点，就可以得到那么第三个节点后为偶数节点，因此我们又可以断掉节点2到节点3之间的连接，指向节点3后一个节点即节点4，如蓝色箭头。那么我们再将第二个节点指向第四个节点，又回到刚刚到情况了。

step 1：判断空链表的情况，如果链表为空，不用重排。
step 2：使用双指针odd和even分别遍历奇数节点和偶数节点，并给偶数节点链表一个头。
step 3：上述过程，每次遍历两个节点，且even在后面，因此每轮循环用even检查后两个元素是否为NULL，如果不为再进入循环进行上述连接过程。
step 4：将偶数节点头接在奇数最后一个节点后，再返回头部。

```
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param head ListNode类 
# @return ListNode类
#
class Solution:
    def oddEvenList(self , head: ListNode) -> ListNode:
         #如果链表为空，不用重排
        if head == None:
            return head
        #even开头指向第二个节点，可能为空
        even = head.next 
        #odd开头指向第一个节点
        odd = head 
        #指向even开头
        evenhead = even 
        while even and even.next:
            #odd连接even的后一个，即奇数位
            odd.next = even.next 
            #odd进入后一个奇数位
            odd = odd.next 
            #even连接后一个奇数的后一位，即偶数位
            even.next = odd.next 
            #even进入后一个偶数位
            even = even.next 
        #even整体接在odd后面
        odd.next = evenhead 
        return head
```

复杂度分析：

时间复杂度：O(n)，遍历一次链表的所有节点
空间复杂度：O(1)，常数级指针，无额外辅助空间

### BM15 删除有序链表中重复的元素-I

题目主要信息:
给定一个从小到大排好序的链表
删去链表中重复的元素，每个值只留下一个节点
方法：遍历删除（推荐使用）
具体做法：

既然相同的元素只留下一个，我们留下哪一个最好呢？当然是遇到的第一个元素了！因为第一个元素直接就与前面的链表节点连接好了，前面就不用管了，只需要跳过后面重复的元素，连接第一个不重复的元素就可以了，在链表中连接后面的元素总比连接前面的元素更方便嘛，因为不能逆序访问。

step 1：判断链表是否为空链表，空链表不处理直接返回。
step 2：使用一个指针遍历链表，如果指针当前节点与下一个节点的值相同，我们就跳过下一个节点，当前节点直接连接下个节点的后一位。
step 3：如果当前节点与下一个节点值不同，继续往后遍历。
step 4：循环过程中每次用到了两个节点值，要检查连续两个节点是否为空。

```
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param head ListNode类 
# @return ListNode类
#
class Solution:
    def deleteDuplicates(self , head: ListNode) -> ListNode:
        #空链表
        if head == None: 
            return None
        #遍历指针
        cur = head 
        #指针当前和下一位不为空
        while cur and cur.next: 
            #如果当前与下一位相等则忽略下一位
            if(cur.val == cur.next.val):  
                cur.next = cur.next.next
            #否则指针正常遍历
            else: 
                cur = cur.next
        return head
```

复杂度分析：

时间复杂度：O(n)，其中n为链表长度，遍历一次链表
空间复杂度：O(1)，常数级指针变量使用，没有使用额外的辅助空间

### BM16 删除有序链表中重复的元素-II

题目的主要信息：
在一个非降序的链表中，存在重复的节点，删除该链表中重复的节点
重复的节点一个元素也不保留
方法一：直接比较删除（推荐使用）
具体做法：

这是一个升序链表，重复的节点都连在一起，我们就可以很轻易地比较到重复的节点，然后去删除。

step 1：给链表前加上表头，方便可能的话删除第一个节点。
step 2：遍历链表，每次比较相邻两个节点，如果遇到了两个相邻结点相同，则新开内循环将这一段所有的相同都遍历过去。
step 3：在step 2中这一连串相同的节点前的节点直接连上后续第一个不相同值的节点。
step 4：返回时去掉添加的表头。

```
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param head ListNode类 
# @return ListNode类
#
class Solution:
    def deleteDuplicates(self , head: ListNode) -> ListNode:
        #空链表
        if head == None: 
            return None
        res = ListNode(0)
        #在链表前加一个表头
        res.next = head 
        cur = res
        while cur.next and cur.next.next: 
            #遇到相邻两个节点值相同
            if cur.next.val == cur.next.next.val: 
                temp = cur.next.val
                #将所有相同的都跳过
                while cur.next != None and cur.next.val == temp: 
                    cur.next = cur.next.next
            else:
                cur = cur.next
        #返回时去掉表头
        return res.next 
```

复杂度分析：

时间复杂度：O(n)，其中n为链表节点数，只有一次遍历
空间复杂度：O(1)，只开辟了临时指针，常数级空间

## 02二分查找/排序

### BM17 二分查找-I

题目的主要信息：
给定一个元素升序的、无重复数字的整型数组 nums 和一个目标值 target 
找到目标值的下标
如果找不到返回-1

方法一：二分法（推荐使用）
具体做法：

既然数组是升序且无重复的，可以使用二分法。

step 1：从数组首尾开始，每次取中点值。
step 2：如果中间值等于目标即找到了，可返回下标，如果中点值大于目标，说明中点以后的都大于目标，因此目标在中点左半区间，如果中点值小于目标，则相反。
step 3：根据比较进入对应的区间，直到区间左右端相遇，意味着没有找到。

```
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param nums int整型一维数组 
# @param target int整型 
# @return int整型
#
class Solution:
    def search(self , nums: List[int], target: int) -> int:
        l = 0
        r = len(nums) - 1
        # 从数组首尾开始，直到二者相遇
        while l <= r :
            # 每次检查中点的值 
            m = int((l+r)/2) 
            if nums[m] == target:
                return m
            # 进入左的区间
            if nums[m] > target: 
                r = m - 1
            # 进入右区间
            else: 
                l = m + 1
        # 未找到
        return -1 
```

复杂度分析：

时间复杂度：O(log2n)，对长度为nnn的数组进行二分，最坏情况就是取2的对数
空间复杂度：O(1)，常数级变量，无额外辅助空间

### BM18. 二维数组中的查找

题目的主要信息：
矩阵的行元素和列元素都是有序的，从左到右递增，从上到下递增，完全递增元素不会有重复
找到矩阵中有没有给定元素即可
方法一：二分查找（推荐使用）
具体做法：

既然矩阵里面的元素是有序且无重复的，我们可以好好利用一下。

首先看四个角，左上与右下必定为最小值与最大值，而左下与右上就有规律了：左下元素大于它上方的元素，小于它右方的元素，右上元素与之相反。我们可以在查找时使用二分法：

step 1：首先获取矩阵的两个边长，判断特殊情况。
step 2：首先以左下角为起点，若是它小于目标元素，则往右移动去找大的，若是他大于目标元素，则往上移动去找小的。
step 3：若是移动到了矩阵边界也没找到，说明矩阵中不存在目标值。

```
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param target int整型 
# @param array int整型二维数组 
# @return bool布尔型
#
class Solution:
    def Find(self , target: int, array: List[List[int]]) -> bool:
        # 优先判断特殊
        if len(array) == 0: 
            return False
        n = len(array)
        if len(array[0]) == 0:
            return False
        m = len(array[0])
        i = n-1
        j = 0
        # 从最左下角的元素开始往左或往上
        while i >=0 and j < m: 
            # 元素较大，往上走
            if array[i][j] > target: 
                i -= 1
            # 元素较小，往右走
            elif array[i][j] < target: 
                j += 1
            else:
                return True
        return False
```

复杂度分析：

时间复杂度：O(m+n)，遍历矩阵的时候，最多经过矩阵的一行一列
空间复杂度：O(1)，常数级变量，无额外辅助空间

### BM19 寻找峰值

题目主要信息:
给定一个长度为n的数组，返回其中任何一个峰值的索引
峰值元素是指其值严格大于左右相邻值的元素
数组两个边界可以看成是最小，
峰值不存在平的情况，即相邻元素不会相等
方法：二分查找（推荐使用）
具体做法：

因为数组边界看成最小值，因此只要不断地往高处走，一定会有波峰，最大值两边一定比它小。那可以考虑二分查找。

step 1：二分查找首先从数组首尾开始，每次取中间值，直到首尾相遇。
step 2：如果中间值的元素大于它右边的元素，说明往右是向下，我们不一定会遇到波峰，但是那就往左收缩区间。
step 3：如果中间值大于右边的元素，说明此时往右是向上，向上一定能有波峰，那我们往右收缩区间。
step 4：最后区间收尾相遇的点一定就是波峰。

```
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param nums int整型一维数组 
# @return int整型
#
class Solution:
    def findPeakElement(self , nums: List[int]) -> int:
        left = 0
        right = len(nums) - 1
        # 二分法
        while left < right: 
            mid = int((left + right) / 2)
            # 右边是往下，不一定有坡峰
            if nums[mid] > nums[mid+1]: 
                right = mid
            # 右边是往上，一定能找到波峰
            else: 
                left = mid + 1
        # 其中一个波峰
        return right 
```

复杂度分析：

时间复杂度：O(log2n)，二分法最坏情况对整个数组连续二分，最多能分log2n次
空间复杂度：O(1)，常数级变量，无额外辅助空间

### BM20. 数组中的逆序对

题目的主要信息：
在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。
输入一个数组，求一个数组的全部逆序对，答案对1000000007取模
保证输入的数组中没有的相同的数字
方法一：归并排序(推荐使用)
具体做法：

因为我们在归并排序过程中会将数组划分成最小为2个元素的子数组，然后依次比较子数组的长度，这里我们也可以用相同的方法统计逆序对。我们主要有三个阶段：

step 1： 划分阶段：将待划分区间从中点划分成两部分；
step 2： 排序阶段：使用归并排序递归地处理子序列，同时统计逆序对；
step 3： 合并阶段：将排好序的子序列合并，同时累加逆序对。
因为在归并排序中，右边大于左边时，它大于了左边的所有子序列，基于这个性质我们可以不用每次加1来统计，减少运算次数。

```
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param data int整型一维数组 
# @return int整型
#
class Solution:
    mod = 1000000007
    def MergeSort(self, left: int, right: int, data: List[int], temp: List[int]) -> int:
         # 停止划分
        if left >= right:
            return 0
        # 取中间
        mid = int((left + right) / 2) 
        # 左右划分合并
        res = self.MergeSort(left, mid, data, temp) + self.MergeSort(mid + 1, right, data, temp) 
        # 防止溢出
        res %= self.mod 
        i, j = left, mid + 1
        for k in range(left, right+1):
            temp[k] = data[k]
        for k in range(left, right+1):
            if i == mid + 1:
                data[k] = temp[j]
                j += 1
            elif j == right + 1 or temp[i] <= temp[j]:
                data[k] = temp[i]
                i += 1
            # 左边比右边大，答案增加
            else: 
                data[k] = temp[j]
                j += 1
                # 统计逆序对
                res += mid - i + 1 
        return res % self.mod
            
    def InversePairs(self , data: List[int]) -> int:
        n = len(data)
        res = [0 for i in range(n)]
        return self.MergeSort(0, n - 1, data, res)
```

复杂度分析：

时间复杂度：O(nlog2n)，归并排序利用分治思想，树型递归每次二分，总共能分为log2n层，每层合并都需要遍历数组所有元素即O(n)

空间复杂度：O(n)，辅助数组temp长度为n及递归栈最大深度不会超过n

### BM21. 旋转数组的最小数字

题目的主要信息：
有一个长度为 n 的非降序数组，把一个数组最开始的若干个元素“平移”到数组的末尾，变成一个旋转数组
找到这个旋转数组的最小值
方法一：二分法（推荐使用）
具体做法：

因为旋转数组将原本有序的数组分成了两部分有序的数组，因为在原始有序数组中，最小的元素一定是在首位，旋转后无序的点就是最小的数字。我们可以将旋转前的前半段命名为A，旋转后的前半段命名为B，旋转数组即将AB变成了BA。

可以依旧利用二分的思想，分情况讨论：

step 1：双指针指向旋转后数组的首尾，作为区间端点。
step 2：若是区间中点值大于区间右界值，则最小的数字一定在中点右边。
step 3：若是区间中点值等于区间右界值，则是不容易分辨最小数字在哪半个区间，比如[1,1,1,0,1]，应该逐个缩减右界；
step 4：若是区间中点值小于区间右界值，则最小的数字一定在中点左边。
step 5：通过调整区间最后即可锁定最小值所在。

```
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param rotateArray int整型一维数组 
# @return int整型
#
class Solution:
    def minNumberInRotateArray(self , rotateArray: List[int]) -> int:
        left = 0
        right = len(rotateArray) - 1
        while left < right:
            mid = int((left + right) / 2) 
            #最小的数字在mid右边
            if rotateArray[mid] > rotateArray[right]: 
                left = mid + 1 
            #无法判断，一个一个试
            elif rotateArray[mid] == rotateArray[right]: 
                right -= 1
            #最小数字要么是mid要么在mid左边
            else:
                right = mid 
        return rotateArray[left]
```

复杂度分析：

时间复杂度：O(log2n)，二分法最坏情况对n取2的对数
空间复杂度：O(1)，常数级变量，无额外辅助空间

### BM22. 比较版本号

题目的主要信息：

给出2个版本号version1和version2，比较它们的大小
版本号是由修订号组成，修订号与修订号之间由一个"."连接
修订号可能有前导0，按从左到右的顺序依次比较它们的修订号，比较修订号时，只需比较忽略任何前导零后的整数值
如果版本号没有指定某个下标处的修订号，则该修订号视为0
版本号中每一节可能超过int的表达范围
方法一：遍历直接截取（推荐使用）
具体做法：

既然是比较两个字符串每个点之间的数字是否相同，就直接遍历字符串比较，但是数字前导零不便于我们比较，因为我们不知道后面会出现多少前导零，因此应该将点之间的部分转化为数字再比较才方便。

step 1：利用两个指针表示字符串的下标，分别遍历两个字符串。
step 2：每次截取点之前的数字字符组成数字，即在遇到一个点之前，直接取数字，加在前面数字乘10的后面。（因为int会溢出，这里采用long记录数字）
step 3：然后比较两个数字大小，根据大小关系返回1或者-1，如果全部比较完都无法比较出大小关系，则返回0.

```
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 比较版本号
# @param version1 string字符串 
# @param version2 string字符串 
# @return int整型
#
class Solution:
    def compare(self , version1: str, version2: str) -> int:
        n1 = len(version1)
        n2 = len(version2)
        i, j = 0, 0
        # 直到某个字符串结束
        while i < n1 or j < n2: 
            num1 = 0
            # 从下一个点前截取数字
            while i < n1 and version1[i] != '.': 
                num1 = num1 * 10 + int(version1[i])
                i += 1
            # 跳过点
            i += 1 
            num2 = 0
            # 从下一个点前截取数字
            while j < n2 and version2[j] != '.': 
                num2 = num2 * 10 + int(version2[j])
                j += 1
            # 跳过点
            j += 1 
            # 比较数字大小
            if num1 > num2: 
                return 1
            if num1 < num2:
                return -1 
        # 版本号相同
        return 0
```

复杂度分析：

时间复杂度：O(max(n,m))，其中m和n分别为两个字符串的长度，遍历两个字符串，复杂度选取较高值
空间复杂度：O(1)，常数级变量，无额外辅助空间

## 03二叉树

### BM23 二叉树的前序遍历

题目的主要信息：
给定一颗二叉树的根节点，输出其前序遍历的结果
方法一：递归（推荐使用）
具体做法：

什么是二叉树的前序遍历？简单来说就是“根左右”，展开来说就是对于一颗二叉树优先访问其根节点，然后访问它的左子树，等左子树全部访问完了再访问其右子树，而对于子树也按照之前的访问方式，直到到达叶子节点。

从上述前序遍历的解释中我们不难发现，它存在递归的子问题：每次访问一个节点之后，它的左子树是一个要前序遍历的子问题，它的右子树同样是一个要前序遍历的子问题。那我们可以用递归处理：

终止条件： 当子问题到达叶子节点后，后一个不管左右都是空，因此遇到空节点就返回。
返回值： 每次处理完子问题后，就是将子问题访问过的元素返回，依次存入了数组中。
本级任务： 每个子问题优先访问这棵子树的根节点，然后递归进入左子树和右子树。
因此处理的时候，过程就是：

step 1：准备数组用来记录遍历到的节点值，Java可以用List，C++可以直接用vector。
step 2：从根节点开始进入递归，遇到空节点就返回，否则将该节点值加入数组。
step 3：依次进入左右子树进行递归。

```
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param root TreeNode类 
# @return int整型一维数组
#
class Solution:
    def preorder(self, list: List[int], root: TreeNode):
        # 遇到空节点则返回
        if root == None: 
            return
        # 先遍历根节点
        list.append(root.val) 
        # 再去左子树
        self.preorder(list, root.left) 
        # 最后去右子树
        self.preorder(list, root.right) 
        
    def preorderTraversal(self , root: TreeNode) -> List[int]:
        # 添加遍历结果的数组
        list = [] 
        # 递归前序遍历
        self.preorder(list, root) 
        return list
```

复杂度分析：

时间复杂度：O(n)，其中n为二叉树的节点数，遍历二叉树所有节点
空间复杂度：O(n)，最坏情况下二叉树化为链表，递归栈深度为n

方法二：非递归（扩展思路）
具体做法：

我们都知道递归，是不断调用自己，计算内部实现递归的时候，是将之前的父问题存储在栈中，先去计算子问题，等到子问题返回给父问题后再从栈中将父问题弹出，继续运算父问题。因此能够递归解决的问题，我们似乎也可以用栈来试一试。

根据前序遍历“根左右”的顺序，首先要遍历肯定是根节点，然后先遍历左子树，再遍历右子树。递归中我们是先进入左子节点作为子问题，等左子树结束，再进入右子节点作为子问题，这里我们同样可以这样做，它无非相当于把父问题挂进了栈中，等子问题结束再从栈中弹出父问题，从父问题进入右子树，我们这里已经访问过了父问题，不妨直接将右子节点挂入栈中，然后下一轮先访问左子节点。要怎么优先访问左子节点呢？同样将它挂入栈中，依据栈的后进先出原则，下一轮循环必然它要先出来，如此循环，原先父问题的右子节点被不断推入栈深处，只有左子树全部访问完毕，才会弹出继续访问。

step 1：优先判断树是否为空，空树不遍历。
step 2：准备辅助栈，首先记录根节点。
step 3：每次从栈中弹出一个元素，进行访问，然后验证该节点的左右子节点是否存在，存的话的加入栈中，优先加入右节点。

```
class Solution:
    def preorderTraversal(self , root: TreeNode) -> List[int]:
        res = []
        if not root:
            return res
        # 辅助栈
        s = [] 
        # 根节点先进栈
        s.append(root) 
        # 直到栈中没有节点
        while s: 
            # 每次栈顶就是访问的元素
            node = s[-1] 
            s.pop()
            res.append(node.val)
            # 如果右边还有右子节点进栈
            if node.right: 
                s.append(node.right)
            # 如果左边还有左子节点进栈
            if node.left: 
                s.append(node.left)
        return res
```

复杂度分析：

时间复杂度：O(n)，其中n为二叉树的节点数，遍历二叉树所有节点
空间复杂度：O(n)，辅助栈空间最坏为链表所有节点数

### BM24. 二叉树的中序遍历

题目的主要信息：
给定一颗二叉树的根节点，输出其前序遍历的结果
方法一：递归（推荐使用）
具体做法：

什么是二叉树的中序遍历，简单来说就是“左根右”，展开来说就是对于一棵二叉树，我们优先访问它的左子树，等到左子树全部节点都访问完毕，再访问根节点，最后访问右子树。同时访问子树的时候，顺序也与访问整棵树相同。

从上述对于中序遍历的解释中，我们不难发现它存在递归的子问题，根节点的左右子树访问方式与原本的树相同，可以看成一颗树进行中序遍历，因此可以用递归处理：

终止条件： 当子问题到达叶子节点后，后一个不管左右都是空，因此遇到空节点就返回。
返回值： 每次处理完子问题后，就是将子问题访问过的元素返回，依次存入了数组中。
本级任务： 每个子问题优先访问左子树的子问题，等到左子树的结果返回后，再访问自己的根节点，然后进入右子树。
因此处理的时候，过程就是：

step 1：准备数组用来记录遍历到的节点值，Java可以用List，C++可以直接用vector。
step 2：从根节点开始进入递归，遇到空节点就返回，否则优先进入左子树进行递归访问。
step 3：左子树访问完毕再回到根节点访问。
step 4：最后进入根节点的右子树进行递归。

```
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param root TreeNode类 
# @return int整型一维数组
#
import sys
class Solution:
    def inorder(self, list: List[int], root: TreeNode):
        # 遇到空节点则返回
        if not root: 
            return
        # 先遍历左子树
        self.inorder(list, root.left) 
        # 再遍历根节点
        list.append(root.val) 
        # 最后遍历右子树
        self.inorder(list, root.right) 
        
    def inorderTraversal(self , root: TreeNode) -> List[int]:
        # 由于python存在最大的递归深度约束，这一步是更改最大深度的限制
        sys.setrecursionlimit(1500) 
        res = [] # 添加遍历结果的list
        # 递归中序遍历
        self.inorder(res, root) 
        return res
```

复杂度分析：

时间复杂度：O(n)，其中nnn为二叉树的节点数，遍历二叉树所有节点
空间复杂度：O(n)，最坏情况下二叉树化为链表，递归栈深度为n

方法二：非递归（扩展思路）
具体做法：

与前序遍历类似，我们利用栈来代替递归。如果一棵二叉树，对于每个根节点都优先访问左子树，那结果是什么？从根节点开始不断往左，第一个被访问的肯定是最左边的节点，然后访问该节点的右子树，最后向上回到父问题。因为每次访问最左的元素不止对一整棵二叉树成立，而是对所有子问题都成立，因此循环的时候自然最开始都是遍历到最左，然后访问，然后再进入右子树，我们可以用栈来实现回归父问题。

step 1：优先判断树是否为空，空树不遍历。
step 2：准备辅助栈，当二叉树节点为空了且栈中没有节点了，我们就停止访问。
step 3：从根节点开始，每次优先进入每棵的子树的最左边一个节点，我们将其不断加入栈中，用来保存父问题。
step 4：到达最左后，可以开始访问，如果它还有右节点，则将右边也加入栈中，之后右子树的访问也是优先到最左。

```
class Solution:
    def inorderTraversal(self , root: TreeNode) -> List[int]:
        # s是辅助栈
        res, s = [], [] 
        # 当树节点不为空或栈中有节点时
        while root or s: 
            # 每次找到最左节点
            while root: 
                s.append(root)
                root = root.left
            # 访问该节点
            node = s[-1] 
            s.pop() 
            res.append(node.val)
            # 进入右节点
            root = node.right 
        return res
```

复杂度分析：

时间复杂度：O(n)，其中n为二叉树的节点数，遍历二叉树所有节点
空间复杂度：O(n)，辅助栈空间最大为链表所有节点数

### BM25. 二叉树的后序遍历

题目的主要信息：
给定一颗二叉树的根节点，输出其后序遍历的结果
方法一：递归（推荐使用）
具体做法：

什么是二叉树的后续遍历，简单来说就是“左右根”，展开来说就是优先访问根节点的左子树的全部节点，然后再访问根节点的右子树的全部节点，最后再访问根节点。对于每棵子树的访问也按照这个逻辑，因此叫做“左右根”的顺序。

从上述后序遍历的解释中我们不难发现，它存在递归的子问题：对每个子树的访问，可以看成对于上一级树的子问题。那我们可以用递归处理：

终止条件： 当子问题到达叶子节点后，后一个不管左右都是空，因此遇到空节点就返回。
返回值： 每次处理完子问题后，就是将子问题访问过的元素返回，依次存入了数组中。
本级任务： 对于每个子问题，优先进入左子树的子问题，访问完了再进入右子树的子问题，最后回到父问题访问根节点。
因此处理的时候，过程就是：

step 1：准备数组用来记录遍历到的节点值，Java可以用List，C++可以直接用vector。
step 2：从根节点开始进入递归，遇到空节点就返回，否则优先进入左子树进行递归访问。
step 3：左子树访问完毕再进入根节点的右子树递归访问。
step 4：最后回到根节点，访问该节点。

```
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param root TreeNode类 
# @return int整型一维数组
#
class Solution:
    def postorder(self, list: List[int], root: TreeNode):
        # 遇到空节点则返回
        if not root:
            return
        # 先去左子树
        self.postorder(list, root.left) 
        # 再去右子树
        self.postorder(list, root.right) 
        # 最后访问根节点
        list.append(root.val) 
        
    def postorderTraversal(self , root: TreeNode) -> List[int]:
        res = []
        # 递归后序遍历
        self.postorder(res, root) 
        return res
```

复杂度分析：

时间复杂度：O(n)，其中nnn为二叉树的节点数，遍历二叉树所有节点
空间复杂度：O(n)，最坏情况下二叉树化为链表，递归栈深度为n

方法二：非递归（扩展思路）
具体做法：

既然二叉树的前序遍历和中序遍历都可以使用栈来代替递归，那后序遍历是否也可以呢？答案是可以的，但是会比前二者复杂一点点。

根据后序遍历“左右中”的顺序，那么后序遍历也与中序遍历类似，要先找到每棵子树的最左端节点，然后我们就要访问该节点了嘛？不不不，如果它还有一个右节点呢？根据“左右根”的原则，我还要先访问右子树。我们只能说它是最左端的节点，它左边为空，但是右边不一定，因此这个节点必须被看成是这棵最小的子树的根。要怎么访问根节点呢？

我们都知道从栈中弹出根节点，一定是左节点已经被访问过了，因为左节点是子问题，访问完了才回到父问题，那么我们还必须要确保右边也已经被访问过了。如果右边为空，那肯定不用去了，如果右边不为空，那我们肯定优先进入右边，此时再将根节点加入栈中，等待右边的子树结束。不过，当右边被访问了，又回到了根，我们的根怎么知道右边被访问了呢？用一个前序指针pre标记一下，每个根节点只对它的右节点需要标记，而每个右节点自己本身就是一个根节点，因此每次访问根节点的时候，我们可以用pre标记为该节点，回到上一个根节点时，检查一下，如果pre确实是它的右子节点，哦那正好，刚刚已经访问过了，我现在可以安心访问这个根了。

step 1：开辟一个辅助栈，用于记录要访问的子节点，开辟一个前序指针pre。
step 2：从根节点开始，每次优先进入每棵的子树的最左边一个节点，我们将其不断加入栈中，用来保存父问题。
step 3：弹出一个栈元素，看成该子树的根，判断这个根的右边有没有节点或是有没有被访问过，如果没有右节点或是被访问过了，可以访问这个根，并将前序节点标记为这个根。
step 4：如果没有被访问，那这个根必须入栈，进入右子树继续访问，只有右子树结束了回到这里才能继续访问根。

```
class Solution:
    def postorderTraversal(self , root: TreeNode) -> List[int]:
        # 添加遍历结果的数组
        res, s = [], [] 
        pre = None
        while root or s:
            # 每次先找到最左边的节点
            while root: 
                s.append(root)
                root = root.left
            # 弹出栈顶
            node = s[-1] 
            s.pop()
            # 如果该元素的右边没有或是已经访问过
            if not node.right or node.right is pre: 
                # 访问中间的节点
                res.append(node.val) 
                # 且记录为访问过了
                pre = node 
            else:
                # 该节点入栈
                s.append(node) 
                # 先访问右边
                root = node.right 
        return res
```

复杂度分析：

时间复杂度：O(n)，其中n为二叉树的节点数，遍历二叉树所有节点
空间复杂度：O(n)，辅助栈空间最大为链表所有节点数

### BM26. 求二叉树的层序遍历

题目的主要信息：
将给定二叉树按行从上到下、从左到右的顺序输出
输出到一个二维数组中，数组中每行就是二叉树的一层
方法一：非递归（推荐使用）
具体做法：

二叉树的层次遍历就是按照从上到下每行，然后每行中从左到右依次遍历，得到的二叉树的元素值。对于层次遍历，我们通常会使用队列来辅助：
	
因为队列是一种先进先出的数据结构，我们依照它的性质，如果从左到右访问完一行节点，并在访问的时候依次把它们的子节点加入队列，那么它们的子节点也是从左到右的次序，且排在本行节点的后面，因此队列中出现的顺序正好是层次遍历。

那我们解决这道题目的思路就有了：

step 1：首先判断二叉树是否为空，空树没有遍历结果。
step 2：建立辅助队列，根节点首先进入队列。不管层次怎么访问，根节点一定是第一个，那它肯定排在队伍的最前面。
step 3：每次进入一层，统计队列中元素的个数。因为每当访问完一层，下一层作为这一层的子节点，一定都加入队列，而再下一层还没有加入，因此此时队列中的元素个数就是这一层的元素个数。
step 4：每次遍历这一层这么多的节点数，将其依次从队列中弹出，然后加入这一行的一维数组中，如果它们有子节点，依次加入队列排队等待访问。
step 5：访问完这一层的元素后，将这个一维数组加入二维数组中，再访问下一层。

```
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param root TreeNode类 
# @return int整型二维数组
#
import queue
class Solution:
    def levelOrder(self , root: TreeNode) -> List[List[int]]:
        res = []
        if not root:
            # 如果是空，则直接返回空数组
            return res 
        # 队列存储，进行层次遍历
        q = queue.Queue() 
        q.put(root)
        cur = None
        while not q.empty():
            # 记录二叉树的某一行
            row = [] 
            n = q.qsize()
            # 因先进入的是根节点，故每层节点多少，队列大小就是多少
            for i in range(n):
                cur = q.get()
                row.append(cur.val)
                # 若是左右孩子存在，则存入左右孩子作为下一个层次
                if cur.left:
                    q.put(cur.left)
                if cur.right:
                    q.put(cur.right)
            # 每一层加入输出
            res.append(row) 
        return res
```

复杂度分析：

时间复杂度：O(n)，其中nnn为二叉树的节点数，每个节点访问一次

空间复杂度：O(n)，队列的空间为二叉树的一层的节点数，最坏情况二叉树的一层为O(n)级

方法二：递归（扩展思路）
具体做法：

既然二叉树的前序、中序、后序遍历都可以轻松用递归实现，树型结构本来就是递归喜欢的形式，那我们的层次遍历是不是也可以尝试用递归来试试呢？按行遍历的关键是每一行的深度对应了它输出在二维数组中的深度，即深度可以与二维数组的下标对应，那我们递归的时候记录深度就可以了啊。

step 1：首先判断二叉树是否为空，空树没有遍历结果。
step 2：使用递归进行层次遍历输出，每次递归记录当前二叉树的深度，每当遍历到一个节点，如果为空直接返回。
step 3：如果遍历的节点不为空，输出二维数组中一维数组的个数（即代表了输出的行数）小于深度，说明这个节点应该是新的一层，我们在二维数组中增加一个一维数组，然后再加入二叉树元素。
step 4：如果不是step 3的情况说明这个深度我们已经有了数组，直接根据深度作为下标取出数组，将元素加在最后就可以了。
step 5：处理完这个节点，再依次递归进入左右节点，同时深度增加。因为我们进入递归的时候是先左后右，那么遍历的时候也是先左后右，正好是层次遍历的顺序。
再来看看这个递归过程中三段式：

终止条件： 遍历到了空节点，就不再继续，返回。
返回值： 将加入的输出数组中的结果往上返回。
本级任务： 处理按照上述思路处理非空节点，并进入该节点的子节点作为子问题。

```
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param root TreeNode类 
# @return int整型二维数组
#
import sys
sys.setrecursionlimit(999999999)
class Solution:
    # 记录输出
    res = [] 
    def traverse(self, root: TreeNode, depth: int):
        if root:
            # 新的一层
            if len(self.res) < depth: 
                row = []
                self.res.append(row)
                row.append(root.val)
            # 读取该层的一维数组，将元素加入末尾
            else: 
                row = self.res[depth -1]
                row.append(root.val)
        else: 
            return 
        # 递归左右时深度记得加1
        self.traverse(root.left, depth+1) 
        self.traverse(root.right, depth+1)
        
    def levelOrder(self , root: TreeNode) -> List[List[int]]:
        if not root:
            return self.res
        self.traverse(root, 1)
        return self.res
```

复杂度分析：

时间复杂度：O(n)，其中nnn为二叉树的节点数，每个节点访问一次
空间复杂度：O(n)，最坏二叉树退化为链表，递归栈的最大深度为n

### BM27. 按之字形顺序打印二叉树

题目的主要信息：
给定一个二叉树，返回该二叉树的之字形层序遍
第一层从左向右，下一层从右向左，一直这样交替
方法一：非递归层次遍历（推荐使用）
具体做法：

按照层次遍历按层打印二叉树的方式，每层分开打印，然后对于每一层利用flag标记，第一层为false，之后每到一层取反一次，如果该层的flag为true，则记录的数组整个反转即可。

但是难点在于如何每层分开存储，从哪里知晓分开的时机？在层次遍历的时候，我们通常会借助队列（queue）,事实上，队列中的值大有玄机，让我们一起来看看：当根节点进入队列时，队列长度为1，第一层结点数也为1；若是根节点有两个子节点，push进队列后，队列长度为2，第二层结点数也为2；若是根节点一个子节点，push进队列后，队列长度为为1，第二层结点数也为1.由此，我们可知，每层的结点数等于进入该层时队列长度，因为刚进入该层时，这一层每个结点都会push进队列，而上一层的结点都出去了。

step 1：首先判断二叉树是否为空，空树没有打印结果。
step 2：建立辅助队列，根节点首先进入队列。不管层次怎么访问，根节点一定是第一个，那它肯定排在队伍的最前面，初始化flag变量。
step 3：每次进入一层，统计队列中元素的个数，更改flag变量的值。因为每当访问完一层，下一层作为这一层的子节点，一定都加入队列，而再下一层还没有加入，因此此时队列中的元素个数就是这一层的元素个数。
step 4：每次遍历这一层这么多的节点数，将其依次从队列中弹出，然后加入这一行的一维数组中，如果它们有子节点，依次加入队列排队等待访问。
step 5：访问完这一层的元素后，根据flag变量决定将这个一维数组直接加入二维数组中还是反转后再加入，然后再访问下一层。

```
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param pRoot TreeNode类 
# @return int整型二维数组
#
import queue

class Solution:
    def Print(self , pRoot: TreeNode) -> List[List[int]]:
        head = pRoot
        res = []
        if not head:
            # 如果是空，则直接返回空list
            return res 
        # 队列存储，进行层次遍历
        temp = queue.Queue() 
        temp.put(head)
        flag = True
        while not temp.empty():
            # 记录二叉树的某一行
            row = [] 
            # 奇数行反转，偶数行不反转
            flag = not flag 
            n = temp.qsize()
            # 因先进入的是根节点，故每层节点多少，队列大小就是多少
            for i in range(n): 
                p = temp.get()
                row.append(p.val)
                # 若是左右孩子存在，则存入左右孩子作为下一个层次
                if p.left:
                    temp.put(p.left)
                if p.right:
                    temp.put(p.right)
            # 奇数行反转，偶数行不反转
            if flag: 
                row = row[::-1]
            res.append(row)
        return res
```

复杂度分析：

时间复杂度：O(n)，每个节点访问一次，因为reverse的时间复杂度为O(n)，按每层元素reverse也相当于O(n)
空间复杂度：O(n)，队列的空间最长为O(n)

### BM28. 二叉树的最大深度

题目的主要信息：
给定一棵二叉树的根节点，求这棵树的最大深度
深度是指树的根节点到任一叶子节点路径上节点的数量
最大深度是所有叶子节点的深度的最大值
叶子节点是指没有子节点的节点
方法一：递归（推荐使用）
具体做法：

最大深度是所有叶子节点的深度的最大值，深度是指树的根节点到任一叶子节点路径上节点的数量，因此从根节点每次往下一层深度就会加1。因此二叉树的深度就等于根结点这个1层加上左子树和右子树深度的最大值，即root depth=max(left depth,right depth)+1。而每个子树我们都可以看成一个根节点，继续用上述方法求的深度，于是我们可以对这个问题划为子问题，利用递归来解决：

step 1： 终止条件： 当进入叶子节点后，再进入子节点，即为空，没有深度可言，返回0.
step 2： 返回值： 每一级按照上述公式，返回两边子树深度的最大值加上本级的深度，即加1.
step 3：本级任务： 每一级的任务就是进入左右子树，求左右子树的深度。

```
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param root TreeNode类 
# @return int整型
#
class Solution:
    def maxDepth(self , root: TreeNode) -> int:
        # 空节点没有深度
        if not root: 
            return 0
        # 返回子树深度+1
        return max([self.maxDepth(root.left), self.maxDepth(root.right)]) + 1
```

复杂度分析：

时间复杂度：O(n)，其中n为二叉树的节点数，遍历整棵二叉树
空间复杂度：O(n)，最坏情况下，二叉树化为链表，递归栈深度最大为n

方法二：层次遍历（扩展思路）
具体做法：

既然是统计二叉树的最大深度，除了根据路径到达从根节点到达最远的叶子节点以外，我们还可以分层统计。对于一棵二叉树而言，必然是一层一层的，那一层就是一个深度，有的层可能会很多节点，有的层如根节点或者最远的叶子节点，只有一个节点，但是不管多少个节点，它们都是一层。因此我们可以使用层次遍历，二叉树的层次遍历就是从上到下按层遍历，每层从左到右，我们只要每层统计层数即是深度。

step 1：既然是层次遍历，我们遍历完一层要怎么进入下一层，可以用队列记录这一层中节点的子节点。队列类似栈，是一个先进先出的数据结构，可以理解为我们平时的食堂打饭的排队。因为每层都是按照从左到右开始访问的，那自然记录的子节点也是从左到右，那我们从队列出来的时候也是从左到右，完美契合。
step 2：在刚刚进入某一层的时候，队列中的元素个数就是当前层的节点数。比如第一层，根节点先入队，队列中只有一个节点，对应第一层只有一个节点，第一层访问结束后，它的子节点刚好都加入了队列，此时队列中的元素个数就是下一层的节点数。因此遍历的时候，每层开始统计该层个数，然后遍历相应节点数，精准进入下一层。
step 3：遍历完一层就可以节点深度就可以加1，

```
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param root TreeNode类 
# @return int整型
#
import queue
class Solution:
    def maxDepth(self , root: TreeNode) -> int:
        # 空节点没有深度
        if not root: 
            return 0
        # 队列维护层次后续节点
        q= queue.Queue() 
        # 根入队
        q.put(root) 
        # 记录深度
        res = 0
        # 层次遍历
        while not q.empty(): 
            # 记录当前层有多少节点
            n = q.qsize() 
            # 遍历完这一层，再进入下一层
            for i in range(n): 
                node = q.get()
                # 添加下一层的左右节点
                if node.left: 
                    q.put(node.left)
                if node.right:
                    q.put(node.right)
            # 深度加1
            res += 1 
        return res
```

复杂度分析：

时间复杂度：O(n)，其中nnn为二叉树的节点数，遍历整棵二叉树
空间复杂度：O(n)，辅助队列的空间最坏为n

### BM29. 二叉树中和为某一值的路径(一)

题目的主要信息：
给定一个二叉树root和一个值 sum ，判断是否有从根节点到叶子节点的节点值之和等于 sum 的路径
路径定义为从树的根结点开始往下一直到叶子结点所经过的结点
路径只能从父节点到子节点，不能从子节点到父节点
方法一：递归（推荐使用）
具体做法：

既然是检查从根到叶子有没有一条等于目标值的路径，那肯定需要从根节点遍历到叶子，我们可以在根节点每次往下一层的时候，将sum减去节点值，最后检查是否完整等于0. 而遍历的方法我们可以选取二叉树常用的递归先序遍历，因为每次进入一个子节点，更新sum值以后，相当于对子树查找有没有等于新目标值的路径，因此这就是子问题，递归的三段式为：

终止条件： 每当遇到节点为空，意味着过了叶子节点，返回。每当检查到某个节点没有子节点，它就是叶子节点，此时sum减去叶子节点值刚好为0，说明找到了路径。
返回值： 将子问题中是否有符合新目标值的路径层层往上返回。
本级任务： 每一级需要检查是否到了叶子节点，如果没有则递归地进入子节点，同时更新sum值减掉本层的节点值。
整个过程如下：

step 1：每次检查遍历到的节点是否为空节点，空节点就没有路径。
step 2：再检查遍历到是否为叶子节点，且当前sum值等于节点值，说明可以刚好找到。
step 3：检查左右子节点是否可以有完成路径的，如果任意一条路径可以都返回true，因此这里选用两个子节点递归的或。

```
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param root TreeNode类 
# @param sum int整型 
# @return bool布尔型
#
class Solution:
    def hasPathSum(self , root: TreeNode, sum: int) -> bool:
        # 空节点找不到路径
        if not root: 
            return False
        # 叶子节点，且路径和为sum
        if not root.left and not root.right and sum - root.val == 0:
            return True
        # 递归进入子节点
        return self.hasPathSum(root.left, sum - root.val) or self.hasPathSum(root.right, sum - root.val)
```

复杂度分析：

时间复杂度：O(n)，其中n为二叉树所有节点，前序遍历二叉树所有节点
空间复杂度：O(n)，最坏情况二叉树化为链表，递归栈空间最大为n

方法二：非递归（扩展思路）
具体做法：

在二叉树中能够用递归解决的问题，很多时候我们也可以用非递归来解决。这里遍历过程也可以使用栈辅助，进行dfs遍历，检查往下的路径中是否有等于sum的路径和。

注意，这里仅是dfs，而不是先序遍历，左右节点的顺序没有关系，因为每次往下都是单独添加某个节点的值相加然后继续往下，因此左右节点谁先遍历不管用。

step 1：首先检查空节点，空树没有路径。
step 2：使用两个栈同步遍历，一个栈记录节点，辅助深度优先搜索，另一个栈跟随记录到该节点为止的路径和（C++中可以在一个栈中嵌套pair实现）。根节点及根节点值先进栈。
step 3：遍历的时候每次弹出两个栈中的内容，判断是否是叶子节点且路径和是否等于目标值。
step 4：没有到叶子节点就将左右子节点（如果有）加入栈中，并跟随加入路径和。
step 5：如果遍历结束也没有找到路径和，则该二叉树中没有。

```
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param root TreeNode类 
# @param sum int整型 
# @return bool布尔型
#
class Solution:
    def hasPathSum(self , root: TreeNode, sum: int) -> bool:
        # 空节点找不到路径
        if not root: 
            return False
        # 栈辅助深度优先遍历，并记录到相应节点的路径和
        s = [] 
        # 根节点入栈
        s.append((root, root.val)) 
        while len(s):
            temp = s[-1]
            s.pop()
            # 叶子节点且路径和等于sum
            if (not temp[0].left) and (not temp[0].right) and (temp[1] == sum):
                return True
            # 左节点入栈
            if temp[0].left: 
                s.append((temp[0].left, temp[1] + temp[0].left.val))
            # 右节点入栈
            if temp[0].right: 
                s.append((temp[0].right, temp[1] + temp[0].right.val))
        return False
```

复杂度分析：

时间复杂度：O(n)，其中n为二叉树所有节点，dfs遍历二叉树所有节点
空间复杂度：O(n)，最坏情况二叉树化为链表，递归栈空间最大为n

### BM30. 二叉搜索树与双向链表

题目的主要信息：
将二叉搜索树转化成递增序的双向链表
不能添加新的结点，要在原结点基础上添加链表链接
返回链表中的第一个节点的指针
二叉树节点的左右指针看成双向链表的前后指针
方法一：递归中序遍历（推荐使用）
具体做法：

二叉搜索树的每个节点值大于它的左子节点，且大于全部左子树的节点值，小于它右子节点，且小于全部右子树的节点值。因此最左端的元素一定最小，最右端的元素一定最大，符合“左中右”的特性，因此二叉搜索树的中序遍历就是一个递增序列，我们只要对它中序遍历就可以组装称为递增双向链表。

step 1：创建两个指针，一个指向题目中要求的链表头（head），一个指向当前遍历的前一结点（pre)。
step 2：首先递归到最左，初始化head与pre。
step 3：然后处理中间根节点，依次连接pre与当前结点，连接后更新pre为当前节点。
step 4：最后递归进入右子树，继续处理。
step 5：递归出口即是节点为空则返回。

```
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

#
# 
# @param pRootOfTree TreeNode类 
# @return TreeNode类
#
class Solution:
    head = None
    pre = None
    def Convert(self , pRootOfTree ):
        if not pRootOfTree:
            # 中序递归，叶子为空则返回
            return None       
        # 首先递归到最左最小值
        self.Convert(pRootOfTree.left) 
        # 找到最小值，初始化head与pre
        if not self.pre:       
            self.head = pRootOfTree
            self.pre = pRootOfTree
        # 当前节点与上一节点建立连接，将pre设置为当前值
        else:       
            self.pre.right = pRootOfTree
            pRootOfTree.left = self.pre
            self.pre = pRootOfTree
        self.Convert(pRootOfTree.right)
        return self.head
```

复杂度分析

时间复杂度：O(n)，其中n为二叉树节点数，中序遍历所有节点
空间复杂度：O(n)，递归栈所需要的最大空间

方法二：非递归中序遍历（扩展思路）
具体做法：

二叉树中序遍历除了递归方法，我们还可以尝试非递归解法，与常规的非递归中序遍历几乎相同，只是增加了连接节点。

step 1：创建两个指针，一个指向题目中要求的链表头（head），一个指向当前遍历的前一结点（pre)，创建一个布尔型变量，标记是否是第一次到最左，因为第一次到最左就是链表头。
step 2：判断空树不能连接。
step 3：初始化一个栈辅助中序遍历。
step 4：依次将父节点加入栈中，直接进入二叉树最左端。
step 5：第一次进入最左，初始化head与pre，然后进入它的根节点开始连接。
step 6：最后将右子树加入栈中，栈中依次就弹出“左中右”的节点顺序，直到栈为空。

```
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

#
# 
# @param pRootOfTree TreeNode类 
# @return TreeNode类
#
class Solution:
    def Convert(self , pRootOfTree ):
        if not pRootOfTree:
            return None
        # 设置栈用于遍历
        s = [] 
        head = None
        pre = None
        # 确认第一个遍历到最左，即为首位
        isFirst = True  
        while pRootOfTree or s: 
            # 直到没有左节点
            while pRootOfTree:    
                s.append(pRootOfTree)
                pRootOfTree = pRootOfTree.left
            pRootOfTree = s[-1]
            s.pop()
            # 首位
            if isFirst:  
                head = pRootOfTree
                pre = head
                isFirst = False
            # 当前节点与上一节点建立连接，将pre设置为当前值
            else:          
                pre.right = pRootOfTree
                pRootOfTree.left = pre
                pre = pRootOfTree
            pRootOfTree = pRootOfTree.right
        return head
```

复杂度分析：

时间复杂度：O(n)，其中n为二叉树节点数，中序遍历二叉树所有节点
空间复杂度：O(n)，栈s最大空间为为O(n)

### BM31. 对称的二叉树

题目的主要信息：
判断一棵二叉树是否是镜像，即判断二叉树是否是轴对称图形

方法一：递归（推荐使用）
具体做法：

前序遍历的时候我们采用的是“根左右”的遍历次序，如果这棵二叉树是对称的，即相应的左右节点交换位置完全没有问题，那我们是不是可以尝试“根右左”遍历，按照轴对称图像的性质，这两种次序的遍历结果应该是一样的。不同的方式遍历两次，将结果拿出来比较看起来是一种可行的方法，但也仅仅可行，太过于麻烦。我们不如在遍历的过程就结果比较了。依据前序递归的次序，我们先访问根节点，然后递归地进入左子节点和右子节点，如果要采用“根右左”的顺序，那就应该是递归地进入右子节点，然后进入左子节点。我们可以准备两个指针啊，遍历的时候“根左右”走左边的时候“根右左”走右边，“根左右”走右边的时候“根右左”走左边，这样刚好可以同步遍历比较。

step 1： 终止条件： 当进入子问题的两个节点都为空，说明都到了叶子节点，且是同步的，因此结束本次子问题，返回true；当进入子问题的两个节点只有一个为空，或是元素值不相等，说明这里的对称不匹配，同样结束本次子问题，返回false。
step 2：返回值： 每一级将子问题是否匹配的结果往上传递。
step 3：本级任务： 每个子问题，需要按照上述思路，“根左右”走左边的时候“根右左”走右边，“根左右”走右边的时候“根右左”走左边，一起进入子问题，需要两边都是匹配才能对称。

```
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param pRoot TreeNode类 
# @return bool布尔型
#
class Solution:
    def recursion(self, root1: TreeNode, root2: TreeNode):
        # 可以两个都为空
        if not root1 and not root2: 
            return True
        # 只有一个为空或者节点值不同，必定不对称
        if not root1 or not root2 or root1.val != root2.val:
            return False
        # 每层对应的节点进入递归
        return self.recursion(root1.left, root2.right) and self.recursion(root1.right, root2.left)

    def isSymmetrical(self , pRoot: TreeNode) -> bool:
        return self.recursion(pRoot, pRoot)
```

复杂度分析：

时间复杂度：O(n)，其中n为二叉树的节点数，相当于遍历整个二叉树两次
空间复杂度：O(n)，最坏情况二叉树退化为链表，递归栈深度为n

方法二：层次遍历（扩展思路）
具体做法：

除了递归以外，我们还可以观察，对称的二叉树每一层都是回文的情况，即两边相互对应相等，有节点值的对应节点值，没有节点的连空节点都是对应着的呢。那我们从左往右遍历一层（包括空节点），和从右往左遍历一层（包括空节点），是不是就是得到一样的结果了。（注：必须包含空节点，因为空节点乱插入会导致不同，如题干第二个图所示）。

这时候二叉树每一层的遍历，我就需要用到了层次遍历。层次遍历从左往右经过第一层后，怎么进入第二层？我们可以借助队列——一个先进先出的容器，在遍历第一层的时候，将第一层节点的左右节点都加入到队列中，因为加入队列的顺序是遍历的顺序且先左后右，也就导致了我从队列出来的时候也是下一层的先左后右，正好一一对应。更巧的是，如果我们要从右到左遍历一层，加入队列后也是先右后左，简直完美对应！

而且我们不需要两个层次遍历都完整地遍历二叉树，只需要一半就行了，从左往右遍历左子树，从右往左遍历右子树，各自遍历一半相互比对，因为遍历到另一半都已经检查过了。

step 1：首先判断链表是否为空，空链表直接就是对称。
step 2：准备两个队列，分别作为从左往右层次遍历和从右往左层次遍历的辅助容器，初始第一个队列加入左节点，第二个队列加入右节点。
step 3：循环中每次从队列分别取出一个节点，如果都为空，暂时可以说是对称的，进入下一轮检查；如果某一个为空或是两个节点值不同，那必定不对称。其他情况暂时对称，可以依次从左往右加入子节点到第一个队列，从右往左加入子节点到第二个队列。（这里包括空节点）
step 4：遍历结束也没有检查到不匹配，说明就是对称的。

```
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param pRoot TreeNode类 
# @return bool布尔型
#
import queue
class Solution:
    def isSymmetrical(self , pRoot: TreeNode) -> bool:
        # 空树为对称的
        if not pRoot: 
            return True
        #辅助队列用于从两边层次遍历
        q1 = queue.Queue() 
        q2 = queue.Queue()
        q1.put(pRoot.left)
        q2.put(pRoot.right)
        while not q1.empty() and not q2.empty(): 
            # 分别从左边和右边弹出节点
            left = q1.get()  
            right = q2.get()
            # 都为空暂时对称
            if not left and not right:
                continue
            # 某一个为空或者数字不相等则不对称
            if not left or not right or left.val != right.val:
                return False
            # 从左往右加入队列
            q1.put(left.left) 
            q1.put(left.right)
            # 从右往左加入队列
            q2.put(right.right) 
            q2.put(right.left)
        # 都检验完都是对称的
        return True 
```

复杂度分析：

时间复杂度：O(n)，其中n为二叉树的节点个数，相当于遍历二叉树全部节点
空间复杂度：O(n)，两个辅助队列的最大空间为n

### BM32. 合并二叉树

题目的主要信息：
合并（相加）二叉树位置相同的结点
缺少的节点用另一棵树来补，若都缺则返回NULL
方法一：递归前序遍历（推荐使用）
具体做法：

要将一棵二叉树的节点与另一棵二叉树相加合并，肯定需要遍历两棵二叉树，那我们可以考虑同步遍历两棵二叉树，这样就可以将每次遍历到的值相加在一起。遍历的方式有多种，这里推荐前序递归遍历。

step 1：首先判断t1与t2是否为空，若为则用另一个代替，若都为空，返回的值也是空。
step 2：然后依据前序遍历的特点，优先访问根节点，将两个根点的值相加创建到新树中。
step 3：两棵树再依次同步进入左子树和右子树。

```
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param t1 TreeNode类 
# @param t2 TreeNode类 
# @return TreeNode类
#
class Solution:
    def mergeTrees(self , t1: TreeNode, t2: TreeNode) -> TreeNode:
        # 若只有一个节点返回另一个，两个都为NULL自然返回NULL
        if not t1: 
            return t2
        if not t2:
            return t1
        # 根左右的方式递归
        head = TreeNode(t1.val + t2.val)
        head.left = self.mergeTrees(t1.left, t2.left)
        head.right = self.mergeTrees(t1.right, t2.right)
        return head
```

复杂度分析：

时间复杂度：O(min(n,m))，m和n分别为两棵树的节点树，当一个树访问完时，自然就连接上另一个树的节点，故只访问了小树的节点数。
空间复杂度：O(min(n,m))，递归栈深度也同时间，只访问了小树的节点数。

方法二：非递归层次遍历（扩展思路）
具体做法：

除了递归的遍历以外，非递归的层次遍历，也可以实现两棵树同步遍历节点相加，重点是两棵树从根节点开始每个节点是同步走的。

step 1：首先判断t1与t2是否为空，若为则用另一个代替，若都为空，返回的值也是空。
step 2：使用三个辅助队列，第一个队列q用于暂存合并后的二叉树的层次遍历结点，第二个队列q1用于暂存t1的层次遍历结点，第三个队列q2用于暂存t2的层次遍历结点。
step 3：两棵树同步层次遍历，先将根节点加入队列中，同时根节点优先合并。
step 4：每次从队列分别弹出一个元素，判断分别二者的左右子结点是否存在，若是都存在，则相加合并，若是只存在一个则连接该存在的结点，若是都不存在则连接null。

```
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param t1 TreeNode类 
# @param t2 TreeNode类 
# @return TreeNode类
#
import queue
class Solution:
    # 若只有一个节点返回另一个，两个都为None自然返回None
    def mergeTrees(self , t1: TreeNode, t2: TreeNode) -> TreeNode:
        if not t1:
            return t2
        if not t2:
            return t1
        # 合并根节点
        head = TreeNode(t1.val + t2.val) 
        # 连接后的树的层次遍历节点
        q = queue.Queue() 
        # 分别存两棵树的层次遍历节点
        q1 = queue.Queue() 
        q2 = queue.Queue()
        q.put(head)
        q1.put(t1)  
        q2.put(t2)
        while not q1.empty() and not q2.empty():
            node = q.get()
            node1 = q1.get()
            node2 = q2.get()
            left1 = node1.left
            left2 = node2.left
            right1 = node1.right
            right2 = node2.right
            # 两个左节点都存在
            if left1 or left2:  
                if left1 and left2:
                    left = TreeNode(left1.val + left2.val)
                    node.left = left
                    # 新节点入队列
                    q.put(left)  
                    q1.put(left1)
                    q2.put(left2)
                # 只连接一个节点
                elif left1: 
                    node.left = left1
                elif left2:
                    node.left = left2
            if right1 or right2:
                # 两个右节点都存在
                if right1 and right2: 
                    right = TreeNode(right1.val + right2.val)
                    node.right = right
                    # 新节点入队列
                    q.put(right)
                    q1.put(right1)
                    q2.put(right2)
                # 只连接一个节点
                elif right1:  
                    node.right = right1
                else:
                    node.right = right2
        return head
```

复杂度分析：

时间复杂度：O(min(n,m))，m和n分别为两棵树的节点树，当一个树访问完时，自然就连接上另一个树的节点，故只访问了小树的节点数。
空间复杂度：O(min(n,m))，辅助队列同时间，只访问了小树的节点数。

### BM33. 二叉树的镜像

题目的主要信息：
将二叉树镜像，即将其所有左右子树交换
我们可以考虑自底向上依次交换二叉树的左右结点。

方法一：递归（推荐使用）
具体做法：

因为我们需要将二叉树镜像，意味着每个左右子树都会交换位置，如果我们从上到下对遍历到的节点交换位置，但是它们后面的节点无法跟着他们一起被交换，因此我们可以考虑自底向上对每两个相对位置的节点交换位置，这样往上各个子树也会被交换位置。

自底向上的遍历方式，我们可以采用后序递归的方法：

step 1：先深度最左端的节点，遇到空树返回。
step 2：然后进入子树的最右端。
step 3：再返回到父问题，交换父问题两个节点的值。

```
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param pRoot TreeNode类 
# @return TreeNode类
#
class Solution:
    def Mirror(self , pRoot: TreeNode) -> TreeNode:
        # 空树返回
        if not pRoot: 
            return None
        # 先递归子树
        left = self.Mirror(pRoot.left) 
        right = self.Mirror(pRoot.right)
        # 交换
        pRoot.left = right 
        pRoot.right = left
        return pRoot
```

复杂度分析：

时间复杂度：O(n)，其中nnn为二叉树的节点数，访问二叉树所有节点各一次
空间复杂度：O(n)，最坏情况下，二叉树退化为链表，递归栈最大值为n

方法二：栈（扩展思路）
具体做法：

二叉树中能够用递归的，我们大多也可以用栈来实现。栈的访问是一种自顶向下的访问，因此我们需要在左右子结点入栈后直接交换，然后再访问后续栈中内容。

step 1：优先检查空树的情况。
step 2：使用栈辅助遍历二叉树，根节点先进栈。
step 3：遍历过程中每次弹出栈中一个元素，然后该节点左右节点分别入栈，同时我们交换二者的值，因为子节点已经入栈了再交换，就不怕后续不能交换。

```
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param pRoot TreeNode类 
# @return TreeNode类
#
class Solution:
    def Mirror(self , pRoot: TreeNode) -> TreeNode:
        # 空树
        if not pRoot:  
            return None
        # 辅助栈
        s = [] 
        # 根节点先进栈
        s.append(pRoot) 
        while s:
            node = s[-1]
            s.pop()
            if node.left:
                # 左右节点入栈
                s.append(node.left) 
            if node.right:
                s.append(node.right)
            # 交换左右
            temp = node.left  
            node.left = node.right
            node.right = temp
        return pRoot
```

复杂度分析：

时间复杂度：O(n)，其中n为二叉树的节点数，访问二叉树所有节点各一次
空间复杂度：O(n)，最坏情况下，二叉树退化为链表，栈的最大空间为n

### BM34. 判断是不是二叉搜索树

题目主要信息：
判断给定的一棵二叉树是否是二叉搜索树
二叉搜索树每个左子树元素小于根节点，每个右子树元素大于根节点，中序遍历为递增序


方法一：递归（推荐使用）
具体做法：

还记得二叉搜索树与双向链表这个里面使用的中序遍历吗？既然是判断是否是二叉搜索树，那我们可以继续使用中序遍历。只要之前的节点是二叉树搜索树，那么如果当前的节点小于上一个节点值那么就可以向下判断。*只不过在过程中我们要求反退出。比如一个链表1->2->3->4  只要for循环遍历如果中间有不是递增的直接返回false即可。

step 1：首先递归到最左，初始化maxLeft与pre。
step 2：然后往后遍历整棵树，依次连接pre与当前结点，并更新pre。
step 3：左子树如果不是二叉搜索树返回false。
step 4：判断当前节点是不是小于前置节点，更新前置节点。
step 5：最后由右子树的后面节点决定。

```
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param root TreeNode类 
# @return bool布尔型
#
import sys
class Solution:
    pre = -sys.maxsize - 1
    def isValidBST(self , root: TreeNode) -> bool:
        if not root:
            return True
        # 先进入左子树
        if not self.isValidBST(root.left): 
            return False
        if(root.val <= self.pre):
            return False
        # 更新最值
        self.pre = root.val  
        # 再进入右子树
        if not self.isValidBST(root.right):  
            return False
        return True
```

复杂度分析：

时间复杂度：O(n)，其中n为二叉树的节点数，最坏遍历整个二叉树所有节点
空间复杂度：O(n)，最坏情况二叉树退化为链表，递归栈深度为n

方法二：非递归（扩展思路）
具体做法：

我们也可以利用栈来代替递归。如果一棵二叉树，对于每个根节点都优先访问左子树，那结果是什么？从根节点开始不断往左，第一个被访问的肯定是最左边的节点，然后访问该节点的右子树，最后向上回到父问题。因为每次访问最左的元素不止对一整棵二叉树成立，而是对所有子问题都成立，因此循环的时候自然最开始都是遍历到最左，然后访问，然后再进入右子树，我们可以用栈来实现回归父问题。

step 1：优先判断树是否为空，空树不遍历。
step 2：准备一个数组记录中序遍历的结果。
step 3：准备辅助栈，当二叉树节点为空了且栈中没有节点了，我们就停止访问。
step 4：从根节点开始，每次优先进入每棵的子树的最左边一个节点，我们将其不断加入栈中，用来保存父问题。
step 5：到达最左后，可以开始访问，如果它还有右节点，则将右边也加入栈中，之后右子树的访问也是优先到最左。
step 6：遍历数组，依次比较相邻两个元素是否为递增序。

```
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param root TreeNode类 
# @return bool布尔型
#
class Solution:
    def isValidBST(self , root: TreeNode) -> bool:
        # 设置栈用于遍历 和 记录中序遍历的数组
        s ,sort = [], [] 
        head = root
        while head or s:
            # 直到没有左节点
            while head:   
                s.append(head)
                head = head.left
            head = s[-1]
            s.pop()
            # 访问节点
            sort.append(head.val) 
            head = head.right
        # 遍历中序结果
        for i in range(1, len(sort)):  
            # 一旦有降序，则不是搜索树
            if sort[i - 1] > sort[i]: 
                return False
        return True
```

复杂度分析：

时间复杂度：O(n)，其中n为二叉树的节点数，遍历整个二叉树后又遍历数组
空间复杂度：O(n)，辅助栈及辅助数组的空间最坏为O(n)

### BM35. 判断是不是完全二叉树

题目主要信息：
判断给定二叉树是否为完全二叉树
首先我们需要知道什么是完全二叉树：叶子结点只能出现在最下层和次下层，且最下层的叶子结点集中在树的左部。
需要注意的是，满二叉树肯定是完全二叉树，而完全二叉树不一定是满二叉树。
方法：层次遍历（推荐使用）
具体做法：

对完全二叉树最重要的定义就是叶子结点只能出现在最下层和次下层，所以我们想到可以使用层序遍历，只有次下层和最下层才有叶子节点，其他层出现叶子节点就意味着不是完全二叉树。

step 1：先判断空树一定是完全二叉树。
step 2：初始化一个队列辅助层次遍历，将根节点加入。
step 3：逐渐从队列中弹出元素访问节点，如果遇到某个节点为空，进行标记，若是后续还有访问，则说明提前出线了叶子节点。
step 4：否则，继续加入左右子节点进入队列排队，等待访问。

```
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param root TreeNode类 
# @return bool布尔型
#
import queue

class Solution:
    def isCompleteTree(self , root: TreeNode) -> bool:
        # 空树一定是完全二叉树
        if not root:  
            return True
        q = queue.Queue()
        # 根节点先访问
        q.put(root) 
        # 定义一个首次出现的标记位
        flag = False 
        # 层次遍历
        while not q.empty(): 
            sz = q.qsize()
            for i in range(sz):
                cur = q.get()
                # 标记第一次遇到空节点
                if not cur: 
                    flag = True
                else:
                    # 后续访问已经遇到空节点了，说明经过了叶子
                    if flag:
                        return False
                    q.put(cur.left)
                    q.put(cur.right)
        return True
```

复杂度分析：

时间复杂度：O(n)，其中nnn为二叉树节点数，层次遍历最坏情况下遍历每一个节点
空间复杂度：O(n)，最坏情况下，层次队列的最大空间为O(n)

### BM36. 判断是不是平衡二叉树

题目主要信息：
判断给出的二叉树是否是平衡二叉树
需要判断任意一节点两边子树深度相差是否绝对值大于1，同时它的子树也符合平衡二叉树的规则
方法一：自顶向下（推荐使用）
具体做法：

上述提到了，平衡二叉树任意节点两边的子树深度相差绝对值不会超过1，且每个子树都满足这个条件，那我们可以对每个节点找到两边的深度以后，判断是否两边相差绝对值超过1，然后因为每个子树都满足这个条件，我们还需要遍历二叉树每个节点当成一棵子树进行判断，而对于每个每个节点判断后，其子节点就是子问题，因此可以用递归。

step 1：第一个函数递归遍历二叉树所有结点。
step 2：对于每个节点判断，调用第二个函数获取子树深度。
step 3：第二个函数递归获取子树深度，只需要不断往子节点深度遍历，累加左右深度的较大值。
step 4：根据深度判断该节点下的子树是否为平衡二叉树。

```
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param pRoot TreeNode类 
# @return bool布尔型
#
class Solution:
    #计算该子树深度函数
    def deep(self, root: TreeNode):
        if not root:
            return 0
        # 递归算左右子树的深度
        left = self.deep(root.left) 
        right = self.deep(root.right)
        # 子树最大深度加上自己
        return left + 1 if left > right else right + 1
        
    def IsBalanced_Solution(self , pRoot: TreeNode) -> bool:
        # 空树为平衡二叉树
        if not pRoot: 
            return True
        left = self.deep(pRoot.left)
        right = self.deep(pRoot.right)
        # 左子树深度减去右子树相差绝对值大于1
        if left - right > 1 or left - right < -1: 
            return False
        # 同时，左右子树还必须是平衡的
        return self.IsBalanced_Solution(pRoot.left) and self.IsBalanced_Solution(pRoot.right)
```

复杂度分析：

时间复杂度：O(n^2)，其中nnn为二叉树的节点数，第一个递归遍历二叉树所有节点，第二个递归查找深度最坏情况下（二叉树退化为链表）需要遍历二叉树所有节点
空间复杂度：O(n)，递归栈最大深度为n

方法二：自底向上（扩展思路）
上述一个函数算深度，一个函数遍历所有结点的方法，用了两个递归，做了很多不必要的运，这就是自顶向下的弊端。那我们可以考虑自底向上，在底部计算深度的同时，判断该子树是否为平衡二叉树，将是或否与深度信息往上传就行。

step 1：先判断空树，直接为平衡二叉树。
step 2：递归进行变计算深度边判断是否平衡二叉树。
step 3：递归计算当前节点左右子树的高度差，然后比较深度。
step 4：每次递归都将深度结果往上传，就能做到边判断边计算深度了。

```
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param pRoot TreeNode类 
# @return bool布尔型
#
class Solution:
    # 计算该子树深度
    def getdepth(self, root: TreeNode) -> int: 
        if not root: # 空节点深度为0
            return 0
        # 递归计算当前root左右子树的深度差
        left = self.getdepth(root.left) 
        # 当前节点左子树不平衡,则该树不平衡
        if left < 0: 
            return -1
        right = self.getdepth(root.right)
        # 当前节点右子树不平衡,则该树不平衡
        if right < 0: 
            return -1 
        return -1 if abs(left-right) > 1 else 1 + max([left, right])
    
    def IsBalanced_Solution(self , pRoot: TreeNode) -> bool:
        if not pRoot:
            return True
        return self.getdepth(pRoot) != -1
```

复杂度分析：

时间复杂度：O(n)，其中nnn为树的节点数，一次递归遍历二叉树所有节点
空间复杂度：O(n)，最坏情况下递归栈的深度为n

### BM37. 二叉搜索树的最近公共祖先

题目的主要信息：
给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先：

对于该题的最近的公共祖先定义：对于有根树T的两个结点p、q，最近公共祖先LCA(T,p,q)表示一个结点x，满足x是p和q的祖先且x的深度尽可能大
一个节点也可以是它自己的祖先
二叉搜索树是若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值
所有节点的值都是唯一的，可以通过节点值直接比较
p、q 为不同节点且均存在于给定的二叉搜索树中
方法一：两次遍历（推荐使用）
具体做法：

二叉搜索树没有相同值的节点，因此分别从根节点往下利用二叉搜索树可以轻松找到p、q，这样我们利用路径就可以找到最近公共祖先。

step 1：根据二叉搜索树的性质，从根节点开始查找目标节点，当前节点比目标小则进入右子树，当前节点比目标大则进入左子树，直到找到目标节点。这个过程成用数组记录遇到的元素。
step 2：分别在搜索二叉树中找到p和q两个点，并记录各自的路径为数组。
step 3：同时遍历两个数组，比较元素值，最后一个相等的元素就是最近的公共祖先。

```
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param root TreeNode类 
# @param p int整型 
# @param q int整型 
# @return int整型
#
class Solution:
    def getPath(self, root: TreeNode, target: int) -> List[int]:
        path = []
        node = root
        # 节点值都不同，可以直接用值比较
        while node.val != target: 
            path.append(node.val)
            # 小的在左子树
            if target < node.val: 
                node = node.left
            # 大的在右子树
            else: 
                node = node.right
        path.append(node.val)
        return path
    
    def lowestCommonAncestor(self , root: TreeNode, p: int, q: int) -> int:
        # 求根节点到两个节点的路径
        path_p = self.getPath(root, p) 
        path_q = self.getPath(root, q)
        # 比较两个路径，找到第一个不同的点
        i = 0
        while i < len(path_p) and i < len(path_q):
            if path_p[i] == path_q[i]:
                # 最后一个相同的节点就是最近公共祖先
                res = path_p[i]; 
                i += 1
            else:
                break
        return res
```

复杂度分析：

时间复杂度：O(n)，设二叉树共有n个节点，因此最坏情况二叉搜索树变成链表，搜索到目标节点需要O(n)，比较路径前半段的相同也需要O(n)
空间复杂度：O(n)，记录路径的数组最长为n

方法二：一次遍历（扩展思路）
具体做法：

我们也可以利用二叉搜索树的性质：对于某一个节点若是p与q都小于等于这个这个节点值，说明p、q都在这个节点的左子树，而最近的公共祖先也一定在这个节点的左子树；若是p与q都大于等于这个节点，说明p、q都在这个节点的右子树，而最近的公共祖先也一定在这个节点的右子树。而若是对于某个节点，p与q的值一个大于等于节点值，一个小于等于节点值，说明它们分布在该节点的两边，而这个节点就是最近的公共祖先，因此从上到下的其他祖先都将这个两个节点放到同一子树，只有最近公共祖先会将它们放入不同的子树，每次进入一个子树又回到刚刚的问题，因此可以使用递归。

step 1：首先检查空节点，空树没有公共祖先。
step 2：对于某个节点，比较与p、q的大小，若p、q在该节点两边说明这就是最近公共祖先。
step 3：如果p、q都在该节点的左边，则递归进入左子树。
step 4：如果p、q都在该节点的右边，则递归进入右子树。

```
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param root TreeNode类 
# @param p int整型 
# @param q int整型 
# @return int整型
#
class Solution:
    def lowestCommonAncestor(self , root: TreeNode, p: int, q: int) -> int:
        # 空树找不到公共祖先
        if not root: 
            return -1
        # pq在该节点两边说明这就是最近公共祖先
        if (p >= root.val and q <= root.val) or (p <= root.val and q >= root.val):
            return root.val
        # pq都在该节点的左边
        elif p <= root.val and q <= root.val: 
            # 进入左子树
            return self.lowestCommonAncestor(root.left, p, q) 
        #pq都在该节点的右边
        else: 
            # 进入右子树
            return self.lowestCommonAncestor(root.right, p, q) 
```

复杂度分析：

时间复杂度：O(n)，设二叉树共有n个节点，最坏情况递归遍历所有节点
空间复杂度：O(n)，递归栈深度最坏为n

### BM38. 在二叉树中找到两个节点的最近公共祖先

题目的主要信息：
给定一棵二叉树以及这棵树上的两个节点对应的val值 o1 和 o2，请找到 o1 和 o2 的最近公共祖先节点
二叉树非空，且每个节点值均不同
方法一：路径比较法(推荐使用)
具体做法：

既然要找到二叉树中两个节点的最近公共祖先，那我们可以考虑先找到两个节点全部祖先，然后依次比较的出谁是最近的祖先。

step 1：利用dfs求得根节点到两个目标节点的路径：每次选择二叉树的一棵子树往下找，同时路径数组增加这个遍历的节点值，一旦遍历到了叶子节点也没有，则回溯到父节点，寻找其他路径，回溯时要去掉数组中刚刚加入的元素。
step 2：然后遍历两条路径数组，依次比较元素值。
step 3：找到两条路径第一个不相同的节点即是最近公共祖先。

```
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param root TreeNode类 
# @param o1 int整型 
# @param o2 int整型 
# @return int整型
#
class Solution:
    # 记录是否找到到o的路径
    flag = False 
    # 求得根节点到目标节点的路径
    def dfs(self, root: TreeNode, path: List[int], o: int): 
        if self.flag or not root:
            return
        path.append(root.val)
        # 节点值都不同，可以直接用值比较
        if root.val == o: 
            self.flag = True
            return
        # dfs遍历查找
        self.dfs(root.left, path, o) 
        self.dfs(root.right, path, o)
        #找到
        if self.flag:
            return
        # 该子树没有，回溯
        path.pop() 
        
    def lowestCommonAncestor(self , root: TreeNode, o1: int, o2: int) -> int:
        path1, path2 = [], []
        # 求根节点到两个节点的路径
        self.dfs(root, path1, o1) 
        # 重置flag，查找下一个
        self.flag = False 
        self.dfs(root, path2, o2)
        i = 0
        res = None
        # 比较两个路径，找到第一个不同的点
        while i < len(path1) and i < len(path2): 
            if path1[i] == path2[i]: 
                # 最后一个相同的节点就是最近公共祖先
                res = path1[i] 
                i += 1
            else:
                break
        return res
```

复杂度分析：

时间复杂度：O(n)，其中n为二叉树节点数，递归遍历二叉树每一个节点求路径，后续又遍历路径
空间复杂度：O(n)，最坏情况二叉树化为链表，深度为n，递归栈深度和路径数组为n

方法二：递归（扩展思路）
具体做法：

我们可以从根节点开始思想几种情况：

step 1：如果o1和o2中的任一个和root匹配，那么root就是最近公共祖先。 
step 2：如果都不匹配，则分别递归左、右子树。
step 3：如果有一个节点出现在左子树，并且另一个节点出现在右子树，则root就是最近公共祖先.
step 4：如果两个节点都出现在左子树，则说明最低公共祖先在左子树中，否则在右子树。
因此可以使用递归直接解决。

```
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param root TreeNode类 
# @param o1 int整型 
# @param o2 int整型 
# @return int整型
#
class Solution:
    # 记录是否找到到o的路径
    flag = False 
    # 求得根节点到目标节点的路径
    def dfs(self, root: TreeNode, path: List[int], o: int): 
        if self.flag or not root:
            return
        path.append(root.val)
        # 节点值都不同，可以直接用值比较
        if root.val == o: 
            self.flag = True
            return
        # dfs遍历查找
        self.dfs(root.left, path, o) 
        self.dfs(root.right, path, o)
        #找到
        if self.flag:
            return
        # 该子树没有，回溯
        path.pop() 
        
    def lowestCommonAncestor(self , root: TreeNode, o1: int, o2: int) -> int:
        path1, path2 = [], []
        # 求根节点到两个节点的路径
        self.dfs(root, path1, o1) 
        # 重置flag，查找下一个
        self.flag = False 
        self.dfs(root, path2, o2)
        i = 0
        res = None
        # 比较两个路径，找到第一个不同的点
        while i < len(path1) and i < len(path2): 
            if path1[i] == path2[i]: 
                # 最后一个相同的节点就是最近公共祖先
                res = path1[i] 
                i += 1
            else:
                break
        return res
```

复杂度分析：

时间复杂度：O(n)，其中n为节点数，递归遍历二叉树每一个节点
空间复杂度：O(n)，最坏情况二叉树化为链表，递归栈深度为n

### BM39. 序列化二叉树

题目主要信息：
序列化二叉树即找一种顺序存储二叉树的节点，并以相同的方式能够读取序列重新构建。
换种说法，就是遍历二叉树，记录每个结点，再以同样的方式遍历就可以还原二叉树。
遍历的方法有四种：前序遍历、中序遍历、后序遍历、层次遍历，理论上只要以相同的方式序列化或者反序列化，都可以解题。
方法：前序遍历（推荐使用）
具体做法：

反序列化即按照前序遍历的思路，遍历二叉树每个节点，并将节点值存储在字符串中，我们用‘#’表示空节点，用‘!'表示节点与节点之间的分割。
序列化即根据给定的字符串，将二叉树重建，因为字符串中的顺序是前序遍历，因此我们重建的时候也是前序遍历。

step 1：优先处理序列化，SerializeFunction函数负责先序递归，遇到空节点在字符串中添加‘#’，遇到非空节点，添加相应节点数字和‘!’，然后依次进入左子树，右子树。
step 2：创建全局变量index表示序列中的下标（C++中直接指针完成）。
step 3：DeserializeFunction函数负责先序递归构建树，遇到‘#’则是空节点，遇到数字则根据感叹号分割，将字符串转换为数字后加入创建的节点中。然后依次创建左子树、右子树。

```
# -*- coding:utf-8 -*-
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
import sys
#设置递归深度
sys.setrecursionlimit(100000) 
class Solution:
    def __init__(self):
        self.index = 0 
        self.s = ""

    #处理序列化（递归）
    def SerializeFunction(self, root):
        #空节点
        if not root:
            self.s += '#'
            return
        #根节点
        self.s += (str)(root.val) + '!'
        #左子树
        self.SerializeFunction(root.left) 
        #右子树
        self.SerializeFunction(root.right) 
    
    def Serialize(self, root): 
        if not root:
            return '#'
        self.s = ""
        self.SerializeFunction(root)
        return self.s
    
    #处理反序列化的功能函数（递归）
    def DeserializeFunction(self, s: str):
        # 到达叶节点时，构建完毕，返回继续构建父节点
        #空节点
        if self.index >= len(s) or s[self.index] == "#": 
            self.index += 1
            return None
        # 数字转换
        val = 0
        #遇到分隔符或者结尾
        while s[self.index] != '!' and self.index != len(s):
            val = val * 10 + (int)(s[self.index])
            self.index += 1
        root = TreeNode(val)
        #序列到底了，构建完成
        if self.index == len(s): 
            return root
        else:
            self.index += 1
        #反序列化与序列化一致，都是前序
        root.left = self.DeserializeFunction(s)  
        root.right = self.DeserializeFunction(s)
        return root

    def Deserialize(self, s):
        if s == "#":
            return None
        return self.DeserializeFunction(s)
```

复杂度分析：

时间复杂度：O(n)，其中nnn为二叉树节点数，前序遍历，每个节点遍历一遍
空间复杂度：O(n)，最坏情况下，二叉树退化为链表，递归栈最大深度为n

### BM40. 重建二叉树

题目的主要信息：
根据二叉树的前序遍历序列和中序遍历序列，重建该二叉树，并返回根节点
两个遍历都没有重复的元素
方法一：递归（推荐使用）
具体做法：

对于二叉树的前序遍历，我们知道序列的第一个元素必定是根节点的值，因为序列没有重复的元素，因此中序遍历中可以找到相同的这个元素，而我们又知道中序遍历中根节点将二叉树分成了左右子树两个部分，如下图所示：


![图片说明](https://uploadfiles.nowcoder.com/images/20220308/588579017_1646737384726/2939E21521C22C46A95A8B8DFA62CE0D) 

我们可以发现，数字1是根节点，并将二叉树分成了(247)和(3568)两棵子树，而子树的的根也是相应前序序列的首位，比如左子树的根是数字2，右子树的根是数字3，这样我们就可以利用前序遍历序列找子树的根节点，利用中序遍历序列区分每个子树的节点数。

step 1：先根据前序遍历第一个点建立根节点。
step 2：然后遍历中序遍历找到根节点在数组中的位置。‘
step 2：再按照子树的节点数将两个遍历的序列分割成子数组，将子数组送入函数建立子树。
step 4：知道子树的序列长度为0，结束递归。

```
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param pre int整型一维数组 
# @param vin int整型一维数组 
# @return TreeNode类
#
class Solution:
    def reConstructBinaryTree(self , pre: List[int], vin: List[int]) -> TreeNode:
        n = len(pre)
        m = len(vin)
        # 每个遍历都不能为0
        if n == 0 or m == 0: 
            return None
        # 构建根节点
        root = TreeNode(pre[0]) 
        for i in range(len(vin)):
            # 找到中序遍历中的前序第一个元素
            if pre[0] == vin[i]: 
                # 左子树的前序遍历
                leftpre = pre[1:i+1] 
                # 左子树的中序遍历
                leftvin = vin[:i] 
                # 构建左子树
                root.left = self.reConstructBinaryTree(leftpre, leftvin) 
                # 右子树的前序遍历
                rightpre = pre[i+1:] 
                # 右子树的中序遍历
                rightvin = vin[i+1:] 
                # 构建右子树
                root.right = self.reConstructBinaryTree(rightpre, rightvin) 
                break
        return root
```

复杂度分析：

时间复杂度：O(n)，其中n为数组长度，即二叉树的节点数，构建每个节点进一次递归，递归中所有的循环加起来一共n次
空间复杂度：O(n)，递归栈最大深度不超过n，辅助数组长度也不超过n，重建的二叉树空间属于必要空间，不属于辅助空间

方法二：栈（思路扩展）
具体做法：

除了递归，我们也可以用类似非递归前序遍历的方式建立二叉树。

step 1：首先前序遍历第一个数字依然是根节点，并建立栈辅助遍历。
step 2：然后我们就开始判断，在前序遍历中相邻的两个数字必定是只有两种情况：要么前序后一个是前一个的左节点；要么前序后一个是前一个的右节点或者其祖先的右节点。
step 3：我们可以同时顺序遍历pre和vin两个序列，判断是否是左节点，如果是左节点则不断向左深入，用栈记录祖先，如果不是需要弹出栈回到相应的祖先，然后进入右子树，整个过程类似非递归前序遍历。

```
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param pre int整型一维数组 
# @param vin int整型一维数组 
# @return TreeNode类
#
class Solution:
    def reConstructBinaryTree(self , pre: List[int], vin: List[int]) -> TreeNode:
        n = len(pre)
        m = len(vin)
        # 每个遍历都不能为0
        if n == 0 or m == 0: 
            return None
        s = []
        # 首先建立前序第一个即根节点
        root = TreeNode(pre[0]) 
        cur = root
        j = 0
        for i in range(1, n):
            # 要么旁边这个是它的左节点
            if cur.val != vin[j]: 
                cur.left = TreeNode(pre[i])
                s.append(cur)
                # 要么旁边这个是它的右节点，或者祖先的右节点
                cur = cur.left 
            else:
                j += 1
                # 弹出到符合的祖先
                while s and s[-1].val == vin[j]: 
                    cur = s[-1]
                    s.pop()
                    j += 1
                # 添加右节点
                cur.right = TreeNode(pre[i]) 
                cur = cur.right
        return root
```

复杂度分析：

时间复杂度：O(n)，其中nnn为数组长度，即二叉树的节点数，遍历一次数组，弹出栈的循环最多进行n次
空间复杂度：O(n)，栈空间最大深度为n，重建的二叉树空间属于必要空间，不属于辅助空间

### BM41. 输出二叉树的右视图

题目的主要信息：
利用二叉树中序遍历结果及前序遍历结果构建一棵二叉树
打印二叉树的右视图，即二叉树每层最右边的结点元素
节点值互不相同
方法一：递归建树+深度优先搜索（推荐使用）
具体做法：

可以发现解这道题，我们有两个步骤：

建树
打印右视图
首先建树方面，前序遍历是根左右的顺序，中序遍历是左根右的顺序，因为节点值互不相同，我们可以根据在前序遍历中找到根节点（每个子树部分第一个就是），再在中序遍历中找到对应的值，从其左右分割开，左边就是该树的左子树，右边就是该树的右子树，于是将问题划分为了子问题。

而打印右视图即找到二叉树每层最右边的节点元素，我们可以采取dfs（深度优先搜索）遍历树，根据记录的深度找到最右值。

step 1：首先检查两个遍历序列的大小，若是为0，则空树不用打印。
step 2：建树函数根据上述说，每次利用前序遍历第一个元素就是根节点，在中序遍历中找到它将二叉树划分为左右子树，利用l1 r1 l2 r2分别记录子树部分在数组中分别对应的下标，并将子树的数组部分送入函数进行递归。
step 3：dfs打印右视图时，使用哈希表存储每个深度对应的最右边节点，初始化两个栈辅助遍历，第一个栈记录dfs时的节点，第二个栈记录遍历到的深度，根节点先入栈。
step 4：对于每个访问的节点，每次左子节点先进栈，右子节点再进栈，这样访问完一层后，因为栈的先进后出原理，每次都是右边被优先访问，因此我们在哈希表该层没有元素时，添加第一个该层遇到的元素就是最右边的节点。
step 5：使用一个变量逐层维护深度最大值，最后遍历每个深度，从哈希表中读出每个深度的最右边节点加入数组中。

```
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 求二叉树的右视图
# @param xianxu int整型一维数组 先序遍历
# @param zhongxu int整型一维数组 中序遍历
# @return int整型一维数组
#
from collections import defaultdict

class Solution:
    # 建树函数
    # 四个int参数分别是前序最左节点下标，前序最右节点下标
    # 中序最左节点下标，中序最右节点坐标
    def buildTree(self, xianxu: List[int], l1: int, r1: int, zhongxu: List[int], l2: int, r2: int) -> TreeNode:
        if l1 > r1 or l2 > r2:
            return None
        # 构建节点
        root = TreeNode(xianxu[l1])    
        # 用来保存根节点在中序遍历列表的下标
        rootIndex = 0    
        # 寻找根节点
        for i in range(l2, r2+1):
            if zhongxu[i] == xianxu[l1]:
                rootIndex = i
                break
        # 左子树大小
        leftsize = rootIndex - l2    
        # 右子树大小
        rightsize = r2 - rootIndex    
        # 递归构建左子树和右子树
        root.left = self.buildTree(xianxu, l1 + 1, l1 + leftsize, zhongxu, l2 , l2 + leftsize - 1)
        root.right = self.buildTree(xianxu, r1 - rightsize + 1, r1, zhongxu, rootIndex + 1, r2)
        return root
    def rightSideView(self, root: TreeNode):
        # 右边最深处的值
        mp = defaultdict(int) 
        # 记录最大深度
        max_depth = -1 
        # 维护深度访问节点和维护dfs时的深度
        nodes, depths= [], [] 
        nodes.append(root)
        depths.append(0)
        while nodes:
            node = nodes[-1]
            nodes.pop()
            depth = depths[-1]
            depths.pop()
            if node:
            	# 维护二叉树的最大深度
                max_depth = max([max_depth, depth])
                # 如果不存在对应深度的节点我们才插入
                if mp[depth] == 0:
                    mp[depth] =  node.val
                nodes.append(node.left)
                nodes.append(node.right)
                depths.append(depth + 1)
                depths.append(depth + 1)
        res = []
        for i in range(max_depth + 1):
            res.append(mp[i])
        return res
    def solve(self , xianxu: List[int], zhongxu: List[int]) -> List[int]:
        res = []
        # 空节点
        if(len(xianxu) == 0): 
            return res
        # 建树
        root = self.buildTree(xianxu, 0, len(xianxu) - 1, zhongxu, 0, len(zhongxu) - 1)
        # 找每一层最右边的节点
        return self.rightSideView(root)
```

复杂度分析：

时间复杂度：O(n^2^)，建树部分递归为O(n)，中序遍历中寻找根节点最坏O(n)，dfs每个节点访问一遍O(n)，故为O(n^2^)
空间复杂度：O(n)，递归栈、哈希表、栈的空间都为O(n)

方法二：哈希表优化的递归建树+层次遍历(扩展思路)
具体做法：

对于方法一中每次要寻找中序遍历中的根节点很浪费时间，我们可以利用一个哈希表直接将中序遍历的元素与前序遍历中的下标做一个映射，后续查找中序根结点便可以直接访问了。
同时除了深度优先搜索可以找最右节点，我们也可以利用层次遍历，借助队列，找到每一层的最右。值得注意的是：每进入一层，队列中的元素个数就是该层的节点数。因为在上一层他们的父节点将它们加入队列中的，父节点访问完之后，刚好就是这一层的所有节点。

step 1：首先检查两个遍历序列的大小，若是为0，则空树不用打印。
step 2：遍历前序遍历序列，用哈希表将中序遍历中的数值与前序遍历的下标建立映射。
step 3：按照方法一递归划分子树，只是可以利用哈希表直接在中序遍历中定位根节点的位置。
step 4：建立队列辅助层次遍历，根节点先进队。
step 5：用一个size变量，每次进入一层的时候记录当前队列大小，等到size为0时，便到了最右边，记录下该节点元素。

```
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 求二叉树的右视图
# @param xianxu int整型一维数组 先序遍历
# @param zhongxu int整型一维数组 中序遍历
# @return int整型一维数组
#
from collections import defaultdict
import queue

class Solution:
    index = defaultdict(int)
    # 建树函数
    # 四个int参数分别是前序最左节点下标，前序最右节点下标
    # 中序最左节点下标，中序最右节点坐标
    def buildTree(self, xianxu: List[int], l1: int, r1: int, zhongxu: List[int], l2: int, r2:int) -> TreeNode:
        if l1 > r1 or l2 > r2:
            return None
        # 前序遍历中的第一个节点就是根节点
        xianxu_root = l1 
        # 在中序遍历中定位根节点
        zhongxu_root = self.index[xianxu[xianxu_root]] 
        root = TreeNode(xianxu[xianxu_root])
        # 得到左子树中的节点数目
        leftsize = zhongxu_root - l2 
        root.left = self.buildTree(xianxu, l1 + 1, l1 + leftsize, zhongxu, l2, zhongxu_root - 1)
        root.right = self.buildTree(xianxu, l1 + leftsize + 1, r1, zhongxu, zhongxu_root + 1, r2)
        return root
    
    #层次遍历
    def rightSideView(self, root: TreeNode) -> List[int]:
        res = []
        q = queue.Queue()
        q.put(root)
        while not q.empty():
            #队列中的大小即是这一层的节点树
            size = q.qsize()
            while size:
                size -= 1
                temp = q.get()
                if temp.left:
                    q.put(temp.left)
                if temp.right:
                    q.put(temp.right)
                #最右元素
                if size == 0:
                    res.append(temp.val)
        return res
    
    def solve(self , xianxu: List[int], zhongxu: List[int]) -> List[int]:
        res = []
        # 空节点
        if len(xianxu) == 0: 
            return res
        for i in range(len(xianxu)):
            self.index[zhongxu[i]] = i
        # 建树
        root = self.buildTree(xianxu, 0, len(xianxu) - 1, zhongxu, 0, len(zhongxu) - 1)
        # 找每一层最右边的节点
        return self.rightSideView(root)
```

复杂度分析：

时间复杂度：O(n)，其中nnn为二叉树节点个数，每个节点访问一次，哈希表直接访问数组中的元素
空间复杂度：O(n)，递归栈深度、哈希表、队列的空间都为O(n)

## 04堆/栈/队列

### BM42. 用两个栈实现队列

题目主要信息:
队列：元素不可直接下标访问，先进先出
栈：元素不可直接访问，先进后出
使用两个栈模拟在队列中插入n个元素和弹出n个元素，顺序不定，但是保证操作都是合法的
方法：双栈法（推荐使用）
具体做法：

元素进栈以后，只能优先弹出末尾元素，但是队列每次弹出的却是最先进去的元素，如果能够将栈中元素全部取出来，才能访问到最前面的元素，此时，另一个栈就起作用了。

step 1：push操作就正常push到第一个栈末尾。
step 2：pop操作时，优先将第一个栈的元素弹出，并依次进入第二个栈中。
step 3：第一个栈中最后取出的元素也就是最后进入第二个栈的元素就是队列首部元素，要弹出，此时在第二个栈中可以直接弹出。
step 4：再将第二个中保存的内容，依次弹出，依次进入第一个栈中，这样第一个栈中虽然取出了最里面的元素，但是顺序并没有变。

```
# -*- coding:utf-8 -*-
class Solution:
    def __init__(self):
        self.stack1 = []
        self.stack2 = []
    def push(self, node):
        self.stack1.append(node)
    def pop(self):
        #将第一个栈中内容弹出放入第二个栈中
        while self.stack1: 
            self.stack2.append(self.stack1.pop()) 
        #第二个栈栈顶就是最先进来的元素，即队首
        res = self.stack2.pop() 
        #再将第二个栈的元素放回第一个栈
        while self.stack2: 
            self.stack1.append(self.stack2.pop())
        return res
```

复杂度分析：

时间复杂度：push的时间复杂度为O(1)，pop的时间复杂度为O(n)，push是直接加到栈尾，相当于遍历了两次栈
空间复杂度：O(n)，借助了另一个辅助栈空间
