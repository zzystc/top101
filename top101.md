# top101

## 01链表

### BM1 反转链表

给定一个长度为n的链表，反转该链表，输出表头

方法一：迭代（推荐使用）
具体做法：

step 1：优先处理空链表，空链表不需要反转。
step 2：我们可以设置两个指针，一个当前节点的指针，一个上一个节点的指针（初始为空）。
step 3：遍历整个链表，每到一个节点，断开当前节点与后面节点的指针，并用临时变量记录后一个节点，然后当前节点指向上一个节点。
step 4：再轮换当前指针与上一个指针，让它们进入下一个节点及下一个节点的前序节点。

```
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param head ListNode类 
# @return ListNode类
#
class Solution:
    def ReverseList(self , head: ListNode) -> ListNode:
        # write code here
        pre = None
        phead = head
        while phead:
            temp = phead.next
            phead.next = pre
            pre = phead
            phead = temp
        return pre
```

复杂度分析：

时间复杂度：O（N），遍历链表一次

空间复杂度：O（1），无额外空间使用

### BM2.链表内指定区间反转

题目的主要信息：
将一个节点数为 size 链表 m 位置到 n 位置之间的区间反转
链表其他部分不变，返回头节点
方法一：头插法迭代（推荐使用）
具体做法：

肯定是要先找到了第m个位置才能开始反转链表，而反转的部分就是从第m个位置到第n个位置。

step 1：我们可以在链表前加一个表头，后续返回时去掉就好了，因为如果要从链表头的位置反转，也很方便。
step 2：使用两个指针，一个指向当前节点，一个指向前序节点。
step 3：依次遍历链表，到第m个的位置。
step 4：对于从m到n这些个位置的节点，依次断掉指向后续的指针，反转指针方向。
step 5：返回时去掉我们添加的表头。

```
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param head ListNode类 
# @param m int整型 
# @param n int整型 
# @return ListNode类
#
class Solution:
    def reverseBetween(self , head: ListNode, m: int, n: int) -> ListNode:
        #加个表头
        res = ListNode(-1)
        res.next = head
        #前序节点
        pre = res 
        #当前节点
        cur = head 
        #找到m
        for i in range(1,m): 
            pre = cur
            cur = cur.next
        #从m反转到n
        for i in range(m, n): 
            temp = cur.next
            cur.next = temp.next
            temp.next = pre.next
            pre.next = temp
        #返回去掉表头
        return res.next 
```

复杂度分析：

时间复杂度：O(n)，最坏情况下递归遍历全部链表节点，比如m为链表最后一个位置，或者n为链表最后一个位置时

空间复杂度：O(n)，遍历全部节点时递归栈深度最坏为n

### BM3.链表中的节点每k个一组翻转

题目主要信息:
给定一个链表，从头开始每k个作为一组，将每组的链表结点翻转
组与组之间的位置不变
如果最后链表末尾剩余不足k个元素，则不翻转，直接放在最后
方法：递归（推荐使用）
具体做法：

step 1：现在我们想一想，如果拿到一个链表，想要像上述一样分组翻转应该做些什么？首先肯定是分段吧，至少我们要先分成一组一组，才能够在组内翻转。分组很容易，只要每次遍历k个元素，就是一组。
step 2：然后是组内翻转，翻转完了再连接起来。翻转即指定区间内的翻转，也很容易，可以参考链表指定区间内的翻转。
step 3：最后是将反转后的分组连接，但是连接的时候遇到问题了：首先如果能够翻转，链表第一个元素一定是第一组，它翻转之后就跑到后面去了，而第一组的末尾元素才是新的链表首，我们要返回的也是这个元素，而原本的链表首要连接下一组翻转后的头部，即翻转前的尾部，如果不建立新的链表，看起来就会非常难。
step 4：如果我们从最后的一个组开始翻转，得到了最后一个组的链表首，是不是可以直接连在倒数第二个组翻转后的尾（即翻转前的头）后面，是不是看起来就容易多了。
怎样从后往前呢？我们这时候可以用到自上而下再自下而上的递归或者说栈。接下来我们说说为什么能用递归？如果这个链表有n个分组可以翻转，我们首先对第一个分组翻转，那么是不是接下来将剩余n-1个分组翻转后的结果接在第一组后面就行了，那这剩余的n-1组就是一个子问题。我们来看看递归的三段式模版：

终止条件： 当进行到最后一个分组，即不足k次遍历到链表尾（0次也算），就将剩余的部分直接返回。
返回值： 每一级要返回的就是翻转后的这一分组的头，以及连接好它后面所有翻转好的分组链表。
本级任务： 对于每个子问题，先遍历k次，找到该组结尾在哪里，然后从这一组开头遍历到结尾，依次翻转，结尾就可以作为下一个分组的开头，而先前指向开头的元素已经跑到了这一分组的最后，可以用它来连接它后面的子问题，即后面分组的头。

```
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param head ListNode类 
# @param k int整型 
# @return ListNode类
#
class Solution:
    def reverseKGroup(self , head: ListNode, k: int) -> ListNode:
        #找到每次翻转的尾部
        tail = head 
        #遍历k次到尾部
        for i in range(0,k): 
            #如果不足k到了链表尾，直接返回，不翻转
            if tail == None: 
                return head
            tail = tail.next
        #翻转时需要的前序和当前节点
        pre = None 
        cur = head
        #在到达当前段尾节点前
        while cur != tail: 
            #翻转
            temp = cur.next 
            cur.next = pre
            pre = cur
            cur = temp
        #当前尾指向下一段要翻转的链表
        head.next = self.reverseKGroup(tail, k) 
        return pre
```

复杂度分析：

时间复杂度：O(n)，一共遍历链表n个节点

空间复杂度：O(n)，递归栈最大深度为n/k

### BM4. 合并有序链表

题目的主要信息：
两个元素值递增的链表，单个链表的长度为n
合并这两个链表并使新链表中的节点仍然是递增排序的
方法一：迭代（推荐使用）
具体做法：

既然两个链表已经是排好序的，都是从小到大的顺序，那我们要将其组合，可以使用归并排序的思想：每次比较两个头部，从中取出最小的元素，然后依次往后。这样就能最快速地将最小的元素依次取出来排好序。

step 1：判断空链表的情况，只要有一个链表为空，那答案必定就是另一个链表了，就算另一个链表也为空。
step 2：新建一个空的表头后面连接两个链表排序后的结点。
step 3：遍历两个链表都不为空的情况，取较小值添加在新的链表后面，每次只把被添加的链表的指针后移。
step 4：遍历到最后肯定有一个链表还有剩余的结点，它们的值将大于前面所有的，直接连在新的链表后面即可。

```
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param pHead1 ListNode类 
# @param pHead2 ListNode类 
# @return ListNode类
#
class Solution:
    def Merge(self, pHead1, pHead2):
        # write code here
        dummy = cur = ListNode(0)
        while pHead1 and pHead2:
            if pHead1.val <pHead2.val:
                cur.next = pHead1
                pHead1 = pHead1.next
            else:
                cur.next = pHead2
                pHead2 =pHead2.next
            cur = cur.next
        cur.next = pHead1 or pHead2
        return dummy.next
```

复杂度分析：

时间复杂度：O（n），最坏情况遍历2*n个结点
空间复杂度：O（1），无额外空间使用，新建的链表属于返回必要空间

### BM5. 合并k个已排序的链表

题目的主要信息：
给定k个排好序的升序链表
将这k个链表合并成一个大的升序链表，并返回这个升序链表的头
方法一：归并排序思想（推荐使用）
具体做法：

如果是两个有序链表合并，我们可能会利用归并排序合并阶段的思想：准备双指针分别放在两个链表头，每次取出较小的一个元素加入新的大链表，将其指针后移，继续比较，这样我们出去的都是最小的元素，自然就完成了排序。

其实这道题我们也可以两两比较啊，只要遍历链表数组，取出开头的两个链表，按照上述思路合并，然后新链表再与后一个继续合并，如此循环，知道全部合并完成。但是，这样太浪费时间了。

既然都是归并排序的思想了，那我们可不可以直接归并的分治来做，而不是顺序遍历合并链表呢？答案是可以的！

归并排序是什么？简单来说就是将一个数组每次划分成等长的两部分，对两部分进行排序即是子问题。对子问题继续划分，直到子问题只有1个元素。还原的时候呢，将每个子问题和它相邻的另一个子问题利用上述双指针的方式，1个与1个合并成2个，2个与2个合并成4个，因为这每个单独的子问题合并好的都是有序的，直到合并成原本长度的数组。

step 1：对于这k个链表，就相当于上述合并阶段的k个子问题，需要两个合并，不断往上，最终合并成完整的一个链表。
step 2：从链表数组的首和尾开始，每次划分从中间开始划分，划分成两半。
step 3：将这两半子问题合并好了就成了两个有序链表，最后将这两个有序链表合并就成了，依据子问题递归处理。
终止条件： 划分的时候直到左右区间相等或事左边大于右边。
返回值： 每级返回已经合并好的子问题链表。
本级任务： 对半划分，将划分后的子问题合并成新的链表。

```
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param lists ListNode类一维数组 
# @return ListNode类
#
# import sys
#设置递归深度
# sys.setrecursionlimit(100000) 

class Solution:
    #两个有序链表合并函数
    def Merge2(self, pHead1: ListNode, pHead2: ListNode) -> ListNode: 
        #一个已经为空了，直接返回另一个
        if pHead1 == None: 
            return pHead2
        if pHead2 == None:
            return pHead1
        #加一个表头
        head = ListNode(0) 
        cur = head
        #两个链表都要不为空
        while pHead1 and pHead2: 
            #取较小值的节点
            if pHead1.val <= pHead2.val: 
                cur.next = pHead1
                #只移动取值的指针
                pHead1 = pHead1.next 
            else:
                cur.next = pHead2
                #只移动取值的指针
                pHead2 = pHead2.next 
            #指针后移
            cur = cur.next 
        #哪个链表还有剩，直接连在后面
        if pHead1: 
            cur.next = pHead1
        else:
            cur.next = pHead2
        #返回值去掉表头
        return head.next 
    
    #划分合并区间函数
    def divideMerge(self, lists: List[ListNode], left: int, right: int) -> ListNode:         
        if left > right :
            return None
        #中间一个的情况
        elif left == right: 
            return lists[left]
        #从中间分成两段，再将合并好的两段合并
        mid = (int)((left + right) / 2) 
        return self.Merge2(self.divideMerge(lists, left, mid), self.divideMerge(lists, mid + 1, right))
    
    def mergeKLists(self , lists: List[ListNode]) -> ListNode:
        #k个链表归并排序
        return self.divideMerge(lists, 0, len(lists) - 1) 
```

复杂度分析：

时间复杂度：O(n*k)，其中n为所有链表的总节点数，最坏情况下每次合并都是O(n)，分治为二叉树型递归，每个节点都要使用一次合并，需要合并k-1次
空间复杂度：O(log~2~k)，最坏情况下递归log~2~k层，需要log~2~k的递归栈

### BM6. 判断链表中是否有环

题目主要信息:
给定一个链表的头节点，判断这个链表是否有环

方法：双指针（推荐使用）
具体做法：

我们都知道链表不像二叉树，每个节点只有一个val值和一个next指针，也就是说一个节点只能有一个指针指向下一个节点，不能有两个指针，那这时我们就可以说一个性质：环形链表的环一定在末尾，末尾没有NULL了。为什么这样说呢？仔细看上图，在环2，0，-4中，没有任何一个节点可以指针指出环，它们只能在环内不断循环，因此环后面不可能还有一条尾巴。如果是普通线形链表末尾一定有NULL，那我们可以根据链表中是否有NULL判断是不是有环。

但是，环形链表遍历过程中会不断循环，线形链表遍历到NULL结束了，但是环形链表何时能结束呢？我们可以用一种双指针技巧，这也是处理环形链表常用的技巧：

step 1：设置快慢两个指针，初始都指向链表头。
step 2：遍历链表，快指针每次走两步，慢指针每次走一步。
step 3：如果快指针到了链表末尾，说明没有环，因为它每次走两步，所以要验证连续两步是否为NULL。
step 4：如果链表有环，那快慢双指针会在环内循环，因为快指针每次走两步，因此快指针会在环内追到慢指针，二者相遇就代表有环。

```
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

#
# 
# @param head ListNode类 
# @return bool布尔型
#
class Solution:
    def hasCycle(self , head: ListNode) -> bool:
        #先判断链表为空的情况
        if head == None: 
            return False
        #快慢双指针
        fast = head 
        slow = head
        #如果没环快指针会先到链表尾
        while fast != None and fast.next != None: 
            #快指针移动两步
            fast = fast.next.next 
            #慢指针移动一步
            slow = slow.next 
            #相遇则有环
            if fast == slow: 
                return True
        #到末尾则没有环
        return False 
```

复杂度分析：

时间复杂度：O(n)，最坏情况下遍历链表n个节点
空间复杂度：O(1)，仅使用了两个指针，没有额外辅助空间

### BM7. 链表中环的入口节点

题目主要信息:
给定一个链表，首先判断其是否有环，然后找到环的入口
方法：双指针（推荐使用）
具体做法：

根据题干，不说别的，我们能发现这道题需要完成两个任务：

判断链表是否有环。
在有环的链表中找到环的入口。
对于第一个任务，可以参考判断链表中是否有环，主要思想是利用环没有末尾NULL，后半部分一定是环，然后快慢双指针相遇就代表有环。（具体分析可以参考BM6）

那我们现在假定已经是一个有环的链表了，那么这个链表中怎么找到环的入口呢？在慢指针进入链表环之前，快指针已经进入了环，且在里面循环，这才能在慢指针进入环之后，快指针追到了慢指针，不妨假设快指针在环中走了n圈，慢指针在环中走了m圈，它们才相遇，而进入环之前的距离为x，环入口到相遇点的距离为y，相遇点到环入口的距离为z。快指针一共走了x+n(y+z)+y步，慢指针一共走了x+m(y+z)+y，这个时候快指针走的倍数是慢指针的两倍，则x+n(y+z)+y=2(x+m(y+z)+y)，这时候x+y=(n−2m)(y+z)，因为环的大小是y+z，说明从链表头经过环入口到达相遇地方经过的距离等于整数倍环的大小：那我们从头开始遍历到相遇位置，和从相遇位置开始在环中遍历，会使用相同的步数，而双方最后都会经过入口到相遇位置这y个节点，那说明这y个节点它们就是重叠遍历的，那它们从入口位置就相遇了，这我们不就找到了吗？

step 1：使用判断链表中是否有环中的方法判断链表是否有环，并找到相遇的节点。
step 2：慢指针继续在相遇节点，快指针回到链表头，两个指针同步逐个元素逐个元素开始遍历链表。
step 3：再次相遇的地方就是环的入口。

```
# -*- coding:utf-8 -*-
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None
class Solution:
    def EntryNodeOfLoop(self, pHead):
        # write code here
        slow = self.hasCycle(pHead)
        #没有环
        if slow == None: 
            return None
        #快指针回到表头
        fast = pHead 
        #再次相遇即是环入口
        while fast != slow: 
            fast = fast.next
            slow = slow.next
        return slow
    
    def hasCycle(self , head):
        #先判断链表为空的情况
        if head == None: 
            return None
        #快慢双指针
        fast = head 
        slow = head
        #如果没环快指针会先到链表尾
        while fast != None and fast.next != None: 
            #快指针移动两步
            fast = fast.next.next 
            #慢指针移动一步
            slow = slow.next 
            #相遇则有环
            if fast == slow: 
                #返回相遇的地方
                return slow 
        #到末尾则没有环
        return None 
```

复杂度分析：

时间复杂度：O(n)，最坏情况下遍历链表两次
空间复杂度：O(1)，使用了常数个指针，没有额外辅助空间

### BM8. 链表中倒数最后k个结点

题目的主要信息：
一个长度为n的链表，返回原链表中从倒数第k个结点至尾节点的全部节点
如果该链表长度小于k，请返回一个长度为 0 的链表
方法一：快慢双指针（推荐使用）
具体做法：

我们无法逆序遍历链表，就很难得到链表的倒数第k个元素，那我们可以试试反过来考虑，如果当前我们处于倒数第k的位置上，即距离链表尾的距离是k，那我们假设双指针指向这两个位置，二者同步向前移动，当前面个指针到了链表头的时候，两个指针之间的距离还是k。虽然我们没有办法让指针逆向移动，但是我们刚刚这个思路却可以正向实施：

step 1：准备一个快指针，从链表头开始，在链表上先走k步。
step 2：准备慢指针指向原始链表头，代表当前元素，则慢指针与快指针之间的距离一直都是k。
step 3：快慢指针同步移动，当快指针到达链表尾部的时候，慢指针正好到了倒数个元素的位置。

```
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param pHead ListNode类 
# @param k int整型 
# @return ListNode类
#
class Solution:
    def FindKthToTail(self , pHead: ListNode, k: int) -> ListNode:
        # write code here
        fast = pHead
        slow = pHead
        #快指针先行k步
        for i in range(0,k): 
            if fast != None:
                fast = fast.next
            #达不到k步说明链表过短，没有倒数k
            else: 
                return None
        #快慢指针同步，快指针先到底，慢指针指向倒数第k个
        while fast:
            fast = fast.next
            slow = slow.next
        return slow
```

复杂度分析：

时间复杂度：O(n)，总共遍历n个链表元素
空间复杂度：O(1)，常数级指针变量，无额外辅助空间使用

### BM9. 删除链表的倒数第n个节点

题目的主要信息：
给定一个链表，要删除链表倒数第n个节点，并返回链表的头
题目保证链表长度一定大于等于n
方法一：双指针（推荐使用）
具体做法：

我们无法逆序遍历链表，就很难得到链表的倒数第n个元素，那我们可以试试反过来考虑，如果当前我们处于倒数第n的位置上，即距离链表尾的距离是n，那我们假设双指针指向这两个位置，二者同步向前移动，当前面个指针到了链表头的时候，两个指针之间的距离还是n。虽然我们没有办法让指针逆向移动，但是我们刚刚这个思路却可以正向实施：

step 1：给链表添加一个表头，处理删掉第一个元素时比较方便。
step 2：准备一个快指针，在链表上先走n步。
step 3：准备慢指针指向原始链表头，代表当前元素，前序节点指向添加的表头，这样两个指针之间相距就是一直都是n。
step 4：快慢指针同步移动，当快指针到达链表尾部的时候，慢指针正好到了倒数n个元素的位置。

```
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param head ListNode类 
# @param n int整型 
# @return ListNode类
#
class Solution:
    def removeNthFromEnd(self , head: ListNode, n: int) -> ListNode:
        # write code here
        #添加表头
        res = ListNode(-1) 
        res.next = head
        #当前节点
        cur = head 
        #前序节点
        pre = res 
        fast = head
        #快指针先行n步
        while n: 
            fast = fast.next
            n = n - 1
        #快慢指针同步，快指针到达末尾，慢指针就到了倒数第n个位置
        while fast: 
            fast = fast.next
            pre = cur
            cur = cur.next
        #删除该位置的节点
        pre.next = cur.next 
        #返回去掉头
        return res.next 
```

复杂度分析：

时间复杂度：O(n)，其中n为链表长度，最坏情况遍历整个链表1次
空间复杂度：O(1)，常数级指针，无额外辅助空间使用

### BM10. 两个链表的第一个公共结点

题目中的信息：
两个链表含有公共结点或没有，有公共结点则返回第一公共结点指针
单链表，无循环
没有公共节点返回空
方法一：双指针长度比较法（推荐使用）
具体做法：

如果两个链表有公共节点，那么它们后半部分都是相同的，我们要找的也就是后半部分的第一个节点，只要遍历两个指针同时抵达第一个相同的节点，我们就找到了它。

step 1：单独的遍历两个链表，得到各自的长度。
step 2：求得两链表的长度差n，其中较长的链表的指针从头先走n步。
step 3：两链表指针同步向后遍历，遇到第一个相同的节点就是第一个公共结点。

```
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

#
# 
# @param pHead1 ListNode类 
# @param pHead2 ListNode类 
# @return ListNode类
#
class Solution:
    def FindFirstCommonNode(self , pHead1 , pHead2 ):
        # write code here
        count1 = 0
        count2 = 0
        temp1 = pHead1
        temp2 = pHead2
        while temp1:
            temp1 = temp1.next 
            count1 += 1
        while temp2:
            temp2 = temp2.next 
            count2 += 1
        if count1 > count2:
            count1,count2 = count2,count1 
            pHead1,pHead2 = pHead2,pHead1
        delta = count2 - count1
        
        i = 1
        while i <= delta:
            pHead2 = pHead2.next
            i += 1
        while pHead1 != pHead2:
            pHead1 = pHead1.next
            pHead2 = pHead2.next
        return pHead1
```

复杂度分析：

时间复杂度：O(n)，其中n为两链表较长者的长度，虽是多次循环，但都为单循环，取最大值即为O(n)
空间复杂度：O(1)，没有其他空间申请

### BM11. 两个链表生成相加链表

题目主要信息:
给定两个链表，每个链表中节点值都是0-9，每个链表就可以表示一个数字
将两个链表表示的数字相加，结果也存在链表中
方法：反转链表法（推荐使用）
具体做法：

既然链表每个节点表示数字的每一位，那相加的时候自然可以按照加法法则，从后往前依次相加。但是，链表是没有办法逆序访问的，这是我们要面对第一只拦路虎。解决它也很简单，既然从后往前不行，那从前往后总是可行的吧，将两个链表反转一下，即可得到个十百千……各个数字从前往后的排列，相加结果也是个位在前，怎么办？再次反转，结果不就正常了。

step 1：任意一个链表为空，返回另一个链表就行了，因为链表为空相当于0，0加任何数为0，包括另一个加数为0的情况。
step 2：相继反转两个待相加的链表，反转过程可以参考反转链表。
step 3：设置返回链表的链表头，设置进位carry=0.
step 4：从头开始遍历两个链表，直到两个链表节点都为空且carry也不为1. 每次取出不为空的链表节点值，为空就设置为0，将两个数字与carry相加，然后查看是否进位，将进位后的结果（对10取模）加入新的链表节点，连接在返回链表后面，并继续往后遍历。
step 5：返回前将结果链表再反转回来。

```
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param head1 ListNode类 
# @param head2 ListNode类 
# @return ListNode类
#
class Solution:
    #反转链表
    def ReverseList(self, pHead:ListNode): 
        if pHead == None:
            return None
        cur = pHead
        pre = None
        while cur:
            #断开链表，要记录后续一个
            temp = cur.next 
            #当前的next指向前一个
            cur.next = pre 
            #前一个更新为当前
            pre = cur 
            #当前更新为刚刚记录的后一个
            cur = temp 
        return pre
    
    def addInList(self , head1: ListNode, head2: ListNode) -> ListNode:
        #任意一个链表为空，返回另一个
        if head1 == None: 
            return head2
        if head2 == None:
            return head1
        #反转两个链表
        head1 = self.ReverseList(head1) 
        head2 = self.ReverseList(head2)
        #添加表头
        res = ListNode(-1) 
        head = res
        #进位符号
        carry = 0 
        #只要某个链表还有或者进位还有
        while head1 != None or head2 != None or carry != 0: 
            #链表不为空则取其值
            val1 = 0 if head1 == None else head1.val 
            val2 = 0 if head2 == None else head2.val
            #相加
            temp = val1 + val2 + carry 
            #获取进位
            carry = (int)(temp / 10) 
            temp %= 10
            #添加元素
            head.next = ListNode(temp) 
            head = head.next
            #移动下一个
            if head1: 
                head1 = head1.next
            if head2:
                head2 = head2.next
        #结果反转回来
        return self.ReverseList(res.next) 
```

复杂度分析：

时间复杂度：O(max(m,n))，其中m与n分别为两个链表的长度，翻转链表三次，复杂度分别是O(n)、O(m)、O(max(m,n))，相加过程也是遍历较长的链表
空间复杂度：O(1)，常数级指针，没有额外辅助空间，返回的新链表属于必要空间

### BM12. 单链表的排序

题目的主要信息：
给定一个无序链表，要将其排序为升序链表
方法一：归并排序（推荐使用）
具体做法：

前面我们做合并两个有序链表不是使用归并思想吗？说明在链表中归并排序也不是不可能使用，合并阶段可以参照前面这道题，两个链表逐渐取最小的元素就可以了，但是划分阶段呢？

常规数组的归并排序，是将数组从中间个元素开始划分，然后将划分后的子数组作为一个要排序的数组，再将排好序的两个子数组合并成一个完整的有序数组，因此采用的是递归。而链表中我们也可以用同样的方式，只需要找到中间个元素的前一个节点，将其断开，就可以将链表分成两个子链表，然后继续划分，直到最小，然后往上依次合并。

step 1：首先判断链表为空或者只有一个元素，直接就是有序的。

step 2：准备三个指针，快指针right每次走两步，慢指针mid每次走一步，前序指针left每次跟在mid前一个位置。三个指针遍历链表，当快指针到达链表尾部的时候，慢指针mid刚好走了链表的一半，正好是中间位置。

step 3：从left位置将链表断开，刚好分成两个子问题开始递归。

终止条件： 当子链表划分到为空或者只剩一个节点时，不再继续划分，往上合并。
返回值： 每次返回两个排好序且合并好的子链表。
本级任务： 找到这个链表的中间节点，从前面断开，分为左右两个子链表，进入子问题排序。
step 4：将子问题得到的链表合并，参考合并两个有序链表。

```
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param head ListNode类 the head node
# @return ListNode类
#
class Solution:
    #合并两段有序链表
    def merge(self, pHead1:ListNode, pHead2:ListNode) : 
        #一个已经为空了，直接返回另一个
        if pHead1 == None: 
            return pHead2
        if pHead2 == None:
            return pHead1
        #加一个表头
        head = ListNode(0) 
        cur = head
        #两个链表都要不为空
        while pHead1 and pHead2: 
            #取较小值的节点
            if pHead1.val <= pHead2.val: 
                cur.next = pHead1
                #只移动取值的指针
                pHead1 = pHead1.next 
            else:
                cur.next = pHead2
                #只移动取值的指针
                pHead2 = pHead2.next 
            #指针后移
            cur = cur.next 
        #哪个链表还有剩，直接连在后面
        if pHead1: 
            cur.next = pHead1
        else:
            cur.next = pHead2
        #返回值去掉表头
        return head.next 
    
    def sortInList(self , head ):
        #链表为空或者只有一个元素，直接就是有序的
        if head == None or head.next == None: 
            return head
        left = head
        mid = head.next
        right = head.next.next
        #右边的指针到达末尾时，中间的指针指向该段链表的中间
        while right and right.next:
            left = left.next
            mid = mid.next
            right = right.next.next
        #左边指针指向左段的左右一个节点，从这里断开
        left.next = None 
        #分成两段排序，合并排好序的两段
        return self.merge(self.sortInList(head), self.sortInList(mid)) 
```

复杂度分析：

时间复杂度：O(nlog2n)，每级划分最坏需要遍历链表全部元素，因此为O(n)，每级合并都是将同级的子问题链表遍历合并，因此也为O(n)，分治划分为二叉树型，一共有O(log2n)层，因此复杂度为O((n+n)∗log2n)=O(nlog2n)
空间复杂度：O(log2n)，递归栈的深度最坏为树型递归的深度，log2n层

### BM13. 判断一个链表是否为回文结构

题目的主要信息：
给定一个链表的头节点，判读该链表是否为回文结构
回文结构即正序遍历与逆序遍历结果都是一样的，类似123321
空链表默认为回文结构

方法四：双指针找中点（推荐使用）
具体做法：

上述方法四找中点，我们遍历整个链表找到长度，又遍历长度一半找中点位置。过程过于繁琐，我们想想能不能优化一下，一次性找到中点。

我们首先来看看中点的特征，一个链表的中点，距离链表开头是一半的长度，距离链表结尾也是一半的长度，那如果从链表首遍历到链表中点位置，另一个每次遍历两个节点的指针是不是就到了链表尾，那这时候我们的快慢双指针就登场了：

step 1：慢指针每次走一个节点，快指针每次走两个节点，快指针到达链表尾的时候，慢指针刚好到了链表中点。
step 2：从中点的位置，开始往后将后半段链表反转。
step 3：按照方法四的思路，左右双指针，左指针从链表头往后遍历，右指针从链表尾往反转后的前遍历，依次比较遇到的值。

```
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param head ListNode类 the head
# @return bool布尔型
#
class Solution:
    #反转链表指针
    def reverse(self, head:ListNode): 
        #前序节点
        prev = None 
        while head:
            #断开后序
            next = head.next 
            #指向前序
            head.next = prev 
            prev = head
            head = next
        return prev
    
    def isPail(self , head: ListNode) -> bool:
        #空链表直接为回文
        if head == None:  
            return True
        #准备快慢双指针
        slow = head 
        fast = head
        #双指针找中点
        while fast and fast.next: 
            slow = slow.next
            fast = fast.next.next
        #中点处反转
        slow = self.reverse(slow) 
        fast = head
        while slow:
            #比较判断节点值是否相等
            if slow.val != fast.val: 
                return False
            fast = fast.next
            slow = slow.next
        return True
```

复杂度分析：

时间复杂度：O(n)，其中n为链表的长度，双指针找到中点遍历半个链表，后续反转链表为O(n)，然后再遍历两份半个链表
空间复杂度：O(1)，常数级变量，没有额外辅助空间

### BM14 链表的奇偶重排

题目主要信息:
给定一个链表，将奇数位的节点依次连在前半部分，偶数位的节点依次连在后半部分
返回连接后的链表头
方法：双指针（推荐使用）
具体做法：

如下图所示，第一个节点是奇数位，第二个节点是偶数，第二个节点后又是奇数位，因此可以断掉节点1和节点2之间的连接，指向节点2的后面即节点3，如红色箭头。如果此时我们将第一个节点指向第三个节点，就可以得到那么第三个节点后为偶数节点，因此我们又可以断掉节点2到节点3之间的连接，指向节点3后一个节点即节点4，如蓝色箭头。那么我们再将第二个节点指向第四个节点，又回到刚刚到情况了。

step 1：判断空链表的情况，如果链表为空，不用重排。
step 2：使用双指针odd和even分别遍历奇数节点和偶数节点，并给偶数节点链表一个头。
step 3：上述过程，每次遍历两个节点，且even在后面，因此每轮循环用even检查后两个元素是否为NULL，如果不为再进入循环进行上述连接过程。
step 4：将偶数节点头接在奇数最后一个节点后，再返回头部。

```
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param head ListNode类 
# @return ListNode类
#
class Solution:
    def oddEvenList(self , head: ListNode) -> ListNode:
         #如果链表为空，不用重排
        if head == None:
            return head
        #even开头指向第二个节点，可能为空
        even = head.next 
        #odd开头指向第一个节点
        odd = head 
        #指向even开头
        evenhead = even 
        while even and even.next:
            #odd连接even的后一个，即奇数位
            odd.next = even.next 
            #odd进入后一个奇数位
            odd = odd.next 
            #even连接后一个奇数的后一位，即偶数位
            even.next = odd.next 
            #even进入后一个偶数位
            even = even.next 
        #even整体接在odd后面
        odd.next = evenhead 
        return head
```

复杂度分析：

时间复杂度：O(n)，遍历一次链表的所有节点
空间复杂度：O(1)，常数级指针，无额外辅助空间

### BM15 删除有序链表中重复的元素-I

题目主要信息:
给定一个从小到大排好序的链表
删去链表中重复的元素，每个值只留下一个节点
方法：遍历删除（推荐使用）
具体做法：

既然相同的元素只留下一个，我们留下哪一个最好呢？当然是遇到的第一个元素了！因为第一个元素直接就与前面的链表节点连接好了，前面就不用管了，只需要跳过后面重复的元素，连接第一个不重复的元素就可以了，在链表中连接后面的元素总比连接前面的元素更方便嘛，因为不能逆序访问。

step 1：判断链表是否为空链表，空链表不处理直接返回。
step 2：使用一个指针遍历链表，如果指针当前节点与下一个节点的值相同，我们就跳过下一个节点，当前节点直接连接下个节点的后一位。
step 3：如果当前节点与下一个节点值不同，继续往后遍历。
step 4：循环过程中每次用到了两个节点值，要检查连续两个节点是否为空。

```
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param head ListNode类 
# @return ListNode类
#
class Solution:
    def deleteDuplicates(self , head: ListNode) -> ListNode:
        #空链表
        if head == None: 
            return None
        #遍历指针
        cur = head 
        #指针当前和下一位不为空
        while cur and cur.next: 
            #如果当前与下一位相等则忽略下一位
            if(cur.val == cur.next.val):  
                cur.next = cur.next.next
            #否则指针正常遍历
            else: 
                cur = cur.next
        return head
```

复杂度分析：

时间复杂度：O(n)，其中n为链表长度，遍历一次链表
空间复杂度：O(1)，常数级指针变量使用，没有使用额外的辅助空间

### BM16 删除有序链表中重复的元素-II

题目的主要信息：
在一个非降序的链表中，存在重复的节点，删除该链表中重复的节点
重复的节点一个元素也不保留
方法一：直接比较删除（推荐使用）
具体做法：

这是一个升序链表，重复的节点都连在一起，我们就可以很轻易地比较到重复的节点，然后去删除。

step 1：给链表前加上表头，方便可能的话删除第一个节点。
step 2：遍历链表，每次比较相邻两个节点，如果遇到了两个相邻结点相同，则新开内循环将这一段所有的相同都遍历过去。
step 3：在step 2中这一连串相同的节点前的节点直接连上后续第一个不相同值的节点。
step 4：返回时去掉添加的表头。

```
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param head ListNode类 
# @return ListNode类
#
class Solution:
    def deleteDuplicates(self , head: ListNode) -> ListNode:
        #空链表
        if head == None: 
            return None
        res = ListNode(0)
        #在链表前加一个表头
        res.next = head 
        cur = res
        while cur.next and cur.next.next: 
            #遇到相邻两个节点值相同
            if cur.next.val == cur.next.next.val: 
                temp = cur.next.val
                #将所有相同的都跳过
                while cur.next != None and cur.next.val == temp: 
                    cur.next = cur.next.next
            else:
                cur = cur.next
        #返回时去掉表头
        return res.next 
```

复杂度分析：

时间复杂度：O(n)，其中n为链表节点数，只有一次遍历
空间复杂度：O(1)，只开辟了临时指针，常数级空间

## 02二分查找/排序

### BM17 二分查找-I

题目的主要信息：
给定一个元素升序的、无重复数字的整型数组 nums 和一个目标值 target 
找到目标值的下标
如果找不到返回-1

方法一：二分法（推荐使用）
具体做法：

既然数组是升序且无重复的，可以使用二分法。

step 1：从数组首尾开始，每次取中点值。
step 2：如果中间值等于目标即找到了，可返回下标，如果中点值大于目标，说明中点以后的都大于目标，因此目标在中点左半区间，如果中点值小于目标，则相反。
step 3：根据比较进入对应的区间，直到区间左右端相遇，意味着没有找到。

```
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param nums int整型一维数组 
# @param target int整型 
# @return int整型
#
class Solution:
    def search(self , nums: List[int], target: int) -> int:
        l = 0
        r = len(nums) - 1
        # 从数组首尾开始，直到二者相遇
        while l <= r :
            # 每次检查中点的值 
            m = int((l+r)/2) 
            if nums[m] == target:
                return m
            # 进入左的区间
            if nums[m] > target: 
                r = m - 1
            # 进入右区间
            else: 
                l = m + 1
        # 未找到
        return -1 
```

复杂度分析：

时间复杂度：O(log2n)，对长度为nnn的数组进行二分，最坏情况就是取2的对数
空间复杂度：O(1)，常数级变量，无额外辅助空间

### BM18. 二维数组中的查找

题目的主要信息：
矩阵的行元素和列元素都是有序的，从左到右递增，从上到下递增，完全递增元素不会有重复
找到矩阵中有没有给定元素即可
方法一：二分查找（推荐使用）
具体做法：

既然矩阵里面的元素是有序且无重复的，我们可以好好利用一下。

首先看四个角，左上与右下必定为最小值与最大值，而左下与右上就有规律了：左下元素大于它上方的元素，小于它右方的元素，右上元素与之相反。我们可以在查找时使用二分法：

step 1：首先获取矩阵的两个边长，判断特殊情况。
step 2：首先以左下角为起点，若是它小于目标元素，则往右移动去找大的，若是他大于目标元素，则往上移动去找小的。
step 3：若是移动到了矩阵边界也没找到，说明矩阵中不存在目标值。

```
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param target int整型 
# @param array int整型二维数组 
# @return bool布尔型
#
class Solution:
    def Find(self , target: int, array: List[List[int]]) -> bool:
        # 优先判断特殊
        if len(array) == 0: 
            return False
        n = len(array)
        if len(array[0]) == 0:
            return False
        m = len(array[0])
        i = n-1
        j = 0
        # 从最左下角的元素开始往左或往上
        while i >=0 and j < m: 
            # 元素较大，往上走
            if array[i][j] > target: 
                i -= 1
            # 元素较小，往右走
            elif array[i][j] < target: 
                j += 1
            else:
                return True
        return False
```

复杂度分析：

时间复杂度：O(m+n)，遍历矩阵的时候，最多经过矩阵的一行一列
空间复杂度：O(1)，常数级变量，无额外辅助空间

### BM19 寻找峰值

题目主要信息:
给定一个长度为n的数组，返回其中任何一个峰值的索引
峰值元素是指其值严格大于左右相邻值的元素
数组两个边界可以看成是最小，
峰值不存在平的情况，即相邻元素不会相等
方法：二分查找（推荐使用）
具体做法：

因为数组边界看成最小值，因此只要不断地往高处走，一定会有波峰，最大值两边一定比它小。那可以考虑二分查找。

step 1：二分查找首先从数组首尾开始，每次取中间值，直到首尾相遇。
step 2：如果中间值的元素大于它右边的元素，说明往右是向下，我们不一定会遇到波峰，但是那就往左收缩区间。
step 3：如果中间值大于右边的元素，说明此时往右是向上，向上一定能有波峰，那我们往右收缩区间。
step 4：最后区间收尾相遇的点一定就是波峰。

```
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param nums int整型一维数组 
# @return int整型
#
class Solution:
    def findPeakElement(self , nums: List[int]) -> int:
        left = 0
        right = len(nums) - 1
        # 二分法
        while left < right: 
            mid = int((left + right) / 2)
            # 右边是往下，不一定有坡峰
            if nums[mid] > nums[mid+1]: 
                right = mid
            # 右边是往上，一定能找到波峰
            else: 
                left = mid + 1
        # 其中一个波峰
        return right 
```

复杂度分析：

时间复杂度：O(log2n)，二分法最坏情况对整个数组连续二分，最多能分log2n次
空间复杂度：O(1)，常数级变量，无额外辅助空间

### BM20. 数组中的逆序对

题目的主要信息：
在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。
输入一个数组，求一个数组的全部逆序对，答案对1000000007取模
保证输入的数组中没有的相同的数字
方法一：归并排序(推荐使用)
具体做法：

因为我们在归并排序过程中会将数组划分成最小为2个元素的子数组，然后依次比较子数组的长度，这里我们也可以用相同的方法统计逆序对。我们主要有三个阶段：

step 1： 划分阶段：将待划分区间从中点划分成两部分；
step 2： 排序阶段：使用归并排序递归地处理子序列，同时统计逆序对；
step 3： 合并阶段：将排好序的子序列合并，同时累加逆序对。
因为在归并排序中，右边大于左边时，它大于了左边的所有子序列，基于这个性质我们可以不用每次加1来统计，减少运算次数。

```
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param data int整型一维数组 
# @return int整型
#
class Solution:
    mod = 1000000007
    def MergeSort(self, left: int, right: int, data: List[int], temp: List[int]) -> int:
         # 停止划分
        if left >= right:
            return 0
        # 取中间
        mid = int((left + right) / 2) 
        # 左右划分合并
        res = self.MergeSort(left, mid, data, temp) + self.MergeSort(mid + 1, right, data, temp) 
        # 防止溢出
        res %= self.mod 
        i, j = left, mid + 1
        for k in range(left, right+1):
            temp[k] = data[k]
        for k in range(left, right+1):
            if i == mid + 1:
                data[k] = temp[j]
                j += 1
            elif j == right + 1 or temp[i] <= temp[j]:
                data[k] = temp[i]
                i += 1
            # 左边比右边大，答案增加
            else: 
                data[k] = temp[j]
                j += 1
                # 统计逆序对
                res += mid - i + 1 
        return res % self.mod
            
    def InversePairs(self , data: List[int]) -> int:
        n = len(data)
        res = [0 for i in range(n)]
        return self.MergeSort(0, n - 1, data, res)
```

复杂度分析：

时间复杂度：O(nlog2n)，归并排序利用分治思想，树型递归每次二分，总共能分为log2n层，每层合并都需要遍历数组所有元素即O(n)

空间复杂度：O(n)，辅助数组temp长度为n及递归栈最大深度不会超过n

### BM21. 旋转数组的最小数字

题目的主要信息：
有一个长度为 n 的非降序数组，把一个数组最开始的若干个元素“平移”到数组的末尾，变成一个旋转数组
找到这个旋转数组的最小值
方法一：二分法（推荐使用）
具体做法：

因为旋转数组将原本有序的数组分成了两部分有序的数组，因为在原始有序数组中，最小的元素一定是在首位，旋转后无序的点就是最小的数字。我们可以将旋转前的前半段命名为A，旋转后的前半段命名为B，旋转数组即将AB变成了BA。

可以依旧利用二分的思想，分情况讨论：

step 1：双指针指向旋转后数组的首尾，作为区间端点。
step 2：若是区间中点值大于区间右界值，则最小的数字一定在中点右边。
step 3：若是区间中点值等于区间右界值，则是不容易分辨最小数字在哪半个区间，比如[1,1,1,0,1]，应该逐个缩减右界；
step 4：若是区间中点值小于区间右界值，则最小的数字一定在中点左边。
step 5：通过调整区间最后即可锁定最小值所在。

```
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param rotateArray int整型一维数组 
# @return int整型
#
class Solution:
    def minNumberInRotateArray(self , rotateArray: List[int]) -> int:
        left = 0
        right = len(rotateArray) - 1
        while left < right:
            mid = int((left + right) / 2) 
            #最小的数字在mid右边
            if rotateArray[mid] > rotateArray[right]: 
                left = mid + 1 
            #无法判断，一个一个试
            elif rotateArray[mid] == rotateArray[right]: 
                right -= 1
            #最小数字要么是mid要么在mid左边
            else:
                right = mid 
        return rotateArray[left]
```

复杂度分析：

时间复杂度：O(log2n)，二分法最坏情况对n取2的对数
空间复杂度：O(1)，常数级变量，无额外辅助空间

### BM22. 比较版本号

题目的主要信息：

给出2个版本号version1和version2，比较它们的大小
版本号是由修订号组成，修订号与修订号之间由一个"."连接
修订号可能有前导0，按从左到右的顺序依次比较它们的修订号，比较修订号时，只需比较忽略任何前导零后的整数值
如果版本号没有指定某个下标处的修订号，则该修订号视为0
版本号中每一节可能超过int的表达范围
方法一：遍历直接截取（推荐使用）
具体做法：

既然是比较两个字符串每个点之间的数字是否相同，就直接遍历字符串比较，但是数字前导零不便于我们比较，因为我们不知道后面会出现多少前导零，因此应该将点之间的部分转化为数字再比较才方便。

step 1：利用两个指针表示字符串的下标，分别遍历两个字符串。
step 2：每次截取点之前的数字字符组成数字，即在遇到一个点之前，直接取数字，加在前面数字乘10的后面。（因为int会溢出，这里采用long记录数字）
step 3：然后比较两个数字大小，根据大小关系返回1或者-1，如果全部比较完都无法比较出大小关系，则返回0.

```
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 比较版本号
# @param version1 string字符串 
# @param version2 string字符串 
# @return int整型
#
class Solution:
    def compare(self , version1: str, version2: str) -> int:
        n1 = len(version1)
        n2 = len(version2)
        i, j = 0, 0
        # 直到某个字符串结束
        while i < n1 or j < n2: 
            num1 = 0
            # 从下一个点前截取数字
            while i < n1 and version1[i] != '.': 
                num1 = num1 * 10 + int(version1[i])
                i += 1
            # 跳过点
            i += 1 
            num2 = 0
            # 从下一个点前截取数字
            while j < n2 and version2[j] != '.': 
                num2 = num2 * 10 + int(version2[j])
                j += 1
            # 跳过点
            j += 1 
            # 比较数字大小
            if num1 > num2: 
                return 1
            if num1 < num2:
                return -1 
        # 版本号相同
        return 0
```

复杂度分析：

时间复杂度：O(max(n,m))，其中m和n分别为两个字符串的长度，遍历两个字符串，复杂度选取较高值
空间复杂度：O(1)，常数级变量，无额外辅助空间

## 03二叉树

### BM23 二叉树的前序遍历

题目的主要信息：
给定一颗二叉树的根节点，输出其前序遍历的结果
方法一：递归（推荐使用）
具体做法：

什么是二叉树的前序遍历？简单来说就是“根左右”，展开来说就是对于一颗二叉树优先访问其根节点，然后访问它的左子树，等左子树全部访问完了再访问其右子树，而对于子树也按照之前的访问方式，直到到达叶子节点。

从上述前序遍历的解释中我们不难发现，它存在递归的子问题：每次访问一个节点之后，它的左子树是一个要前序遍历的子问题，它的右子树同样是一个要前序遍历的子问题。那我们可以用递归处理：

终止条件： 当子问题到达叶子节点后，后一个不管左右都是空，因此遇到空节点就返回。
返回值： 每次处理完子问题后，就是将子问题访问过的元素返回，依次存入了数组中。
本级任务： 每个子问题优先访问这棵子树的根节点，然后递归进入左子树和右子树。
因此处理的时候，过程就是：

step 1：准备数组用来记录遍历到的节点值，Java可以用List，C++可以直接用vector。
step 2：从根节点开始进入递归，遇到空节点就返回，否则将该节点值加入数组。
step 3：依次进入左右子树进行递归。

```
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param root TreeNode类 
# @return int整型一维数组
#
class Solution:
    def preorder(self, list: List[int], root: TreeNode):
        # 遇到空节点则返回
        if root == None: 
            return
        # 先遍历根节点
        list.append(root.val) 
        # 再去左子树
        self.preorder(list, root.left) 
        # 最后去右子树
        self.preorder(list, root.right) 
        
    def preorderTraversal(self , root: TreeNode) -> List[int]:
        # 添加遍历结果的数组
        list = [] 
        # 递归前序遍历
        self.preorder(list, root) 
        return list
```

复杂度分析：

时间复杂度：O(n)，其中n为二叉树的节点数，遍历二叉树所有节点
空间复杂度：O(n)，最坏情况下二叉树化为链表，递归栈深度为n

方法二：非递归（扩展思路）
具体做法：

我们都知道递归，是不断调用自己，计算内部实现递归的时候，是将之前的父问题存储在栈中，先去计算子问题，等到子问题返回给父问题后再从栈中将父问题弹出，继续运算父问题。因此能够递归解决的问题，我们似乎也可以用栈来试一试。

根据前序遍历“根左右”的顺序，首先要遍历肯定是根节点，然后先遍历左子树，再遍历右子树。递归中我们是先进入左子节点作为子问题，等左子树结束，再进入右子节点作为子问题，这里我们同样可以这样做，它无非相当于把父问题挂进了栈中，等子问题结束再从栈中弹出父问题，从父问题进入右子树，我们这里已经访问过了父问题，不妨直接将右子节点挂入栈中，然后下一轮先访问左子节点。要怎么优先访问左子节点呢？同样将它挂入栈中，依据栈的后进先出原则，下一轮循环必然它要先出来，如此循环，原先父问题的右子节点被不断推入栈深处，只有左子树全部访问完毕，才会弹出继续访问。

step 1：优先判断树是否为空，空树不遍历。
step 2：准备辅助栈，首先记录根节点。
step 3：每次从栈中弹出一个元素，进行访问，然后验证该节点的左右子节点是否存在，存的话的加入栈中，优先加入右节点。

```
class Solution:
    def preorderTraversal(self , root: TreeNode) -> List[int]:
        res = []
        if not root:
            return res
        # 辅助栈
        s = [] 
        # 根节点先进栈
        s.append(root) 
        # 直到栈中没有节点
        while s: 
            # 每次栈顶就是访问的元素
            node = s[-1] 
            s.pop()
            res.append(node.val)
            # 如果右边还有右子节点进栈
            if node.right: 
                s.append(node.right)
            # 如果左边还有左子节点进栈
            if node.left: 
                s.append(node.left)
        return res
```

复杂度分析：

时间复杂度：O(n)，其中n为二叉树的节点数，遍历二叉树所有节点
空间复杂度：O(n)，辅助栈空间最坏为链表所有节点数

### BM24. 二叉树的中序遍历

题目的主要信息：
给定一颗二叉树的根节点，输出其前序遍历的结果
方法一：递归（推荐使用）
具体做法：

什么是二叉树的中序遍历，简单来说就是“左根右”，展开来说就是对于一棵二叉树，我们优先访问它的左子树，等到左子树全部节点都访问完毕，再访问根节点，最后访问右子树。同时访问子树的时候，顺序也与访问整棵树相同。

从上述对于中序遍历的解释中，我们不难发现它存在递归的子问题，根节点的左右子树访问方式与原本的树相同，可以看成一颗树进行中序遍历，因此可以用递归处理：

终止条件： 当子问题到达叶子节点后，后一个不管左右都是空，因此遇到空节点就返回。
返回值： 每次处理完子问题后，就是将子问题访问过的元素返回，依次存入了数组中。
本级任务： 每个子问题优先访问左子树的子问题，等到左子树的结果返回后，再访问自己的根节点，然后进入右子树。
因此处理的时候，过程就是：

step 1：准备数组用来记录遍历到的节点值，Java可以用List，C++可以直接用vector。
step 2：从根节点开始进入递归，遇到空节点就返回，否则优先进入左子树进行递归访问。
step 3：左子树访问完毕再回到根节点访问。
step 4：最后进入根节点的右子树进行递归。

```
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param root TreeNode类 
# @return int整型一维数组
#
import sys
class Solution:
    def inorder(self, list: List[int], root: TreeNode):
        # 遇到空节点则返回
        if not root: 
            return
        # 先遍历左子树
        self.inorder(list, root.left) 
        # 再遍历根节点
        list.append(root.val) 
        # 最后遍历右子树
        self.inorder(list, root.right) 
        
    def inorderTraversal(self , root: TreeNode) -> List[int]:
        # 由于python存在最大的递归深度约束，这一步是更改最大深度的限制
        sys.setrecursionlimit(1500) 
        res = [] # 添加遍历结果的list
        # 递归中序遍历
        self.inorder(res, root) 
        return res
```

复杂度分析：

时间复杂度：O(n)，其中nnn为二叉树的节点数，遍历二叉树所有节点
空间复杂度：O(n)，最坏情况下二叉树化为链表，递归栈深度为n

方法二：非递归（扩展思路）
具体做法：

与前序遍历类似，我们利用栈来代替递归。如果一棵二叉树，对于每个根节点都优先访问左子树，那结果是什么？从根节点开始不断往左，第一个被访问的肯定是最左边的节点，然后访问该节点的右子树，最后向上回到父问题。因为每次访问最左的元素不止对一整棵二叉树成立，而是对所有子问题都成立，因此循环的时候自然最开始都是遍历到最左，然后访问，然后再进入右子树，我们可以用栈来实现回归父问题。

step 1：优先判断树是否为空，空树不遍历。
step 2：准备辅助栈，当二叉树节点为空了且栈中没有节点了，我们就停止访问。
step 3：从根节点开始，每次优先进入每棵的子树的最左边一个节点，我们将其不断加入栈中，用来保存父问题。
step 4：到达最左后，可以开始访问，如果它还有右节点，则将右边也加入栈中，之后右子树的访问也是优先到最左。

```
class Solution:
    def inorderTraversal(self , root: TreeNode) -> List[int]:
        # s是辅助栈
        res, s = [], [] 
        # 当树节点不为空或栈中有节点时
        while root or s: 
            # 每次找到最左节点
            while root: 
                s.append(root)
                root = root.left
            # 访问该节点
            node = s[-1] 
            s.pop() 
            res.append(node.val)
            # 进入右节点
            root = node.right 
        return res
```

复杂度分析：

时间复杂度：O(n)，其中n为二叉树的节点数，遍历二叉树所有节点
空间复杂度：O(n)，辅助栈空间最大为链表所有节点数

### BM25. 二叉树的后序遍历

题目的主要信息：
给定一颗二叉树的根节点，输出其后序遍历的结果
方法一：递归（推荐使用）
具体做法：

什么是二叉树的后续遍历，简单来说就是“左右根”，展开来说就是优先访问根节点的左子树的全部节点，然后再访问根节点的右子树的全部节点，最后再访问根节点。对于每棵子树的访问也按照这个逻辑，因此叫做“左右根”的顺序。

从上述后序遍历的解释中我们不难发现，它存在递归的子问题：对每个子树的访问，可以看成对于上一级树的子问题。那我们可以用递归处理：

终止条件： 当子问题到达叶子节点后，后一个不管左右都是空，因此遇到空节点就返回。
返回值： 每次处理完子问题后，就是将子问题访问过的元素返回，依次存入了数组中。
本级任务： 对于每个子问题，优先进入左子树的子问题，访问完了再进入右子树的子问题，最后回到父问题访问根节点。
因此处理的时候，过程就是：

step 1：准备数组用来记录遍历到的节点值，Java可以用List，C++可以直接用vector。
step 2：从根节点开始进入递归，遇到空节点就返回，否则优先进入左子树进行递归访问。
step 3：左子树访问完毕再进入根节点的右子树递归访问。
step 4：最后回到根节点，访问该节点。

```
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param root TreeNode类 
# @return int整型一维数组
#
class Solution:
    def postorder(self, list: List[int], root: TreeNode):
        # 遇到空节点则返回
        if not root:
            return
        # 先去左子树
        self.postorder(list, root.left) 
        # 再去右子树
        self.postorder(list, root.right) 
        # 最后访问根节点
        list.append(root.val) 
        
    def postorderTraversal(self , root: TreeNode) -> List[int]:
        res = []
        # 递归后序遍历
        self.postorder(res, root) 
        return res
```

复杂度分析：

时间复杂度：O(n)，其中nnn为二叉树的节点数，遍历二叉树所有节点
空间复杂度：O(n)，最坏情况下二叉树化为链表，递归栈深度为n

方法二：非递归（扩展思路）
具体做法：

既然二叉树的前序遍历和中序遍历都可以使用栈来代替递归，那后序遍历是否也可以呢？答案是可以的，但是会比前二者复杂一点点。

根据后序遍历“左右中”的顺序，那么后序遍历也与中序遍历类似，要先找到每棵子树的最左端节点，然后我们就要访问该节点了嘛？不不不，如果它还有一个右节点呢？根据“左右根”的原则，我还要先访问右子树。我们只能说它是最左端的节点，它左边为空，但是右边不一定，因此这个节点必须被看成是这棵最小的子树的根。要怎么访问根节点呢？

我们都知道从栈中弹出根节点，一定是左节点已经被访问过了，因为左节点是子问题，访问完了才回到父问题，那么我们还必须要确保右边也已经被访问过了。如果右边为空，那肯定不用去了，如果右边不为空，那我们肯定优先进入右边，此时再将根节点加入栈中，等待右边的子树结束。不过，当右边被访问了，又回到了根，我们的根怎么知道右边被访问了呢？用一个前序指针pre标记一下，每个根节点只对它的右节点需要标记，而每个右节点自己本身就是一个根节点，因此每次访问根节点的时候，我们可以用pre标记为该节点，回到上一个根节点时，检查一下，如果pre确实是它的右子节点，哦那正好，刚刚已经访问过了，我现在可以安心访问这个根了。

step 1：开辟一个辅助栈，用于记录要访问的子节点，开辟一个前序指针pre。
step 2：从根节点开始，每次优先进入每棵的子树的最左边一个节点，我们将其不断加入栈中，用来保存父问题。
step 3：弹出一个栈元素，看成该子树的根，判断这个根的右边有没有节点或是有没有被访问过，如果没有右节点或是被访问过了，可以访问这个根，并将前序节点标记为这个根。
step 4：如果没有被访问，那这个根必须入栈，进入右子树继续访问，只有右子树结束了回到这里才能继续访问根。

```
class Solution:
    def postorderTraversal(self , root: TreeNode) -> List[int]:
        # 添加遍历结果的数组
        res, s = [], [] 
        pre = None
        while root or s:
            # 每次先找到最左边的节点
            while root: 
                s.append(root)
                root = root.left
            # 弹出栈顶
            node = s[-1] 
            s.pop()
            # 如果该元素的右边没有或是已经访问过
            if not node.right or node.right is pre: 
                # 访问中间的节点
                res.append(node.val) 
                # 且记录为访问过了
                pre = node 
            else:
                # 该节点入栈
                s.append(node) 
                # 先访问右边
                root = node.right 
        return res
```

复杂度分析：

时间复杂度：O(n)，其中n为二叉树的节点数，遍历二叉树所有节点
空间复杂度：O(n)，辅助栈空间最大为链表所有节点数

### BM26. 求二叉树的层序遍历

题目的主要信息：
将给定二叉树按行从上到下、从左到右的顺序输出
输出到一个二维数组中，数组中每行就是二叉树的一层
方法一：非递归（推荐使用）
具体做法：

二叉树的层次遍历就是按照从上到下每行，然后每行中从左到右依次遍历，得到的二叉树的元素值。对于层次遍历，我们通常会使用队列来辅助：
	
因为队列是一种先进先出的数据结构，我们依照它的性质，如果从左到右访问完一行节点，并在访问的时候依次把它们的子节点加入队列，那么它们的子节点也是从左到右的次序，且排在本行节点的后面，因此队列中出现的顺序正好是层次遍历。

那我们解决这道题目的思路就有了：

step 1：首先判断二叉树是否为空，空树没有遍历结果。
step 2：建立辅助队列，根节点首先进入队列。不管层次怎么访问，根节点一定是第一个，那它肯定排在队伍的最前面。
step 3：每次进入一层，统计队列中元素的个数。因为每当访问完一层，下一层作为这一层的子节点，一定都加入队列，而再下一层还没有加入，因此此时队列中的元素个数就是这一层的元素个数。
step 4：每次遍历这一层这么多的节点数，将其依次从队列中弹出，然后加入这一行的一维数组中，如果它们有子节点，依次加入队列排队等待访问。
step 5：访问完这一层的元素后，将这个一维数组加入二维数组中，再访问下一层。

```
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param root TreeNode类 
# @return int整型二维数组
#
import queue
class Solution:
    def levelOrder(self , root: TreeNode) -> List[List[int]]:
        res = []
        if not root:
            # 如果是空，则直接返回空数组
            return res 
        # 队列存储，进行层次遍历
        q = queue.Queue() 
        q.put(root)
        cur = None
        while not q.empty():
            # 记录二叉树的某一行
            row = [] 
            n = q.qsize()
            # 因先进入的是根节点，故每层节点多少，队列大小就是多少
            for i in range(n):
                cur = q.get()
                row.append(cur.val)
                # 若是左右孩子存在，则存入左右孩子作为下一个层次
                if cur.left:
                    q.put(cur.left)
                if cur.right:
                    q.put(cur.right)
            # 每一层加入输出
            res.append(row) 
        return res
```

复杂度分析：

时间复杂度：O(n)，其中nnn为二叉树的节点数，每个节点访问一次

空间复杂度：O(n)，队列的空间为二叉树的一层的节点数，最坏情况二叉树的一层为O(n)级

方法二：递归（扩展思路）
具体做法：

既然二叉树的前序、中序、后序遍历都可以轻松用递归实现，树型结构本来就是递归喜欢的形式，那我们的层次遍历是不是也可以尝试用递归来试试呢？按行遍历的关键是每一行的深度对应了它输出在二维数组中的深度，即深度可以与二维数组的下标对应，那我们递归的时候记录深度就可以了啊。

step 1：首先判断二叉树是否为空，空树没有遍历结果。
step 2：使用递归进行层次遍历输出，每次递归记录当前二叉树的深度，每当遍历到一个节点，如果为空直接返回。
step 3：如果遍历的节点不为空，输出二维数组中一维数组的个数（即代表了输出的行数）小于深度，说明这个节点应该是新的一层，我们在二维数组中增加一个一维数组，然后再加入二叉树元素。
step 4：如果不是step 3的情况说明这个深度我们已经有了数组，直接根据深度作为下标取出数组，将元素加在最后就可以了。
step 5：处理完这个节点，再依次递归进入左右节点，同时深度增加。因为我们进入递归的时候是先左后右，那么遍历的时候也是先左后右，正好是层次遍历的顺序。
再来看看这个递归过程中三段式：

终止条件： 遍历到了空节点，就不再继续，返回。
返回值： 将加入的输出数组中的结果往上返回。
本级任务： 处理按照上述思路处理非空节点，并进入该节点的子节点作为子问题。

```
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param root TreeNode类 
# @return int整型二维数组
#
import sys
sys.setrecursionlimit(999999999)
class Solution:
    # 记录输出
    res = [] 
    def traverse(self, root: TreeNode, depth: int):
        if root:
            # 新的一层
            if len(self.res) < depth: 
                row = []
                self.res.append(row)
                row.append(root.val)
            # 读取该层的一维数组，将元素加入末尾
            else: 
                row = self.res[depth -1]
                row.append(root.val)
        else: 
            return 
        # 递归左右时深度记得加1
        self.traverse(root.left, depth+1) 
        self.traverse(root.right, depth+1)
        
    def levelOrder(self , root: TreeNode) -> List[List[int]]:
        if not root:
            return self.res
        self.traverse(root, 1)
        return self.res
```

复杂度分析：

时间复杂度：O(n)，其中nnn为二叉树的节点数，每个节点访问一次
空间复杂度：O(n)，最坏二叉树退化为链表，递归栈的最大深度为n

### BM27. 按之字形顺序打印二叉树

题目的主要信息：
给定一个二叉树，返回该二叉树的之字形层序遍
第一层从左向右，下一层从右向左，一直这样交替
方法一：非递归层次遍历（推荐使用）
具体做法：

按照层次遍历按层打印二叉树的方式，每层分开打印，然后对于每一层利用flag标记，第一层为false，之后每到一层取反一次，如果该层的flag为true，则记录的数组整个反转即可。

但是难点在于如何每层分开存储，从哪里知晓分开的时机？在层次遍历的时候，我们通常会借助队列（queue）,事实上，队列中的值大有玄机，让我们一起来看看：当根节点进入队列时，队列长度为1，第一层结点数也为1；若是根节点有两个子节点，push进队列后，队列长度为2，第二层结点数也为2；若是根节点一个子节点，push进队列后，队列长度为为1，第二层结点数也为1.由此，我们可知，每层的结点数等于进入该层时队列长度，因为刚进入该层时，这一层每个结点都会push进队列，而上一层的结点都出去了。

step 1：首先判断二叉树是否为空，空树没有打印结果。
step 2：建立辅助队列，根节点首先进入队列。不管层次怎么访问，根节点一定是第一个，那它肯定排在队伍的最前面，初始化flag变量。
step 3：每次进入一层，统计队列中元素的个数，更改flag变量的值。因为每当访问完一层，下一层作为这一层的子节点，一定都加入队列，而再下一层还没有加入，因此此时队列中的元素个数就是这一层的元素个数。
step 4：每次遍历这一层这么多的节点数，将其依次从队列中弹出，然后加入这一行的一维数组中，如果它们有子节点，依次加入队列排队等待访问。
step 5：访问完这一层的元素后，根据flag变量决定将这个一维数组直接加入二维数组中还是反转后再加入，然后再访问下一层。

```
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param pRoot TreeNode类 
# @return int整型二维数组
#
import queue

class Solution:
    def Print(self , pRoot: TreeNode) -> List[List[int]]:
        head = pRoot
        res = []
        if not head:
            # 如果是空，则直接返回空list
            return res 
        # 队列存储，进行层次遍历
        temp = queue.Queue() 
        temp.put(head)
        flag = True
        while not temp.empty():
            # 记录二叉树的某一行
            row = [] 
            # 奇数行反转，偶数行不反转
            flag = not flag 
            n = temp.qsize()
            # 因先进入的是根节点，故每层节点多少，队列大小就是多少
            for i in range(n): 
                p = temp.get()
                row.append(p.val)
                # 若是左右孩子存在，则存入左右孩子作为下一个层次
                if p.left:
                    temp.put(p.left)
                if p.right:
                    temp.put(p.right)
            # 奇数行反转，偶数行不反转
            if flag: 
                row = row[::-1]
            res.append(row)
        return res
```

复杂度分析：

时间复杂度：O(n)，每个节点访问一次，因为reverse的时间复杂度为O(n)，按每层元素reverse也相当于O(n)
空间复杂度：O(n)，队列的空间最长为O(n)

### BM28. 二叉树的最大深度

题目的主要信息：
给定一棵二叉树的根节点，求这棵树的最大深度
深度是指树的根节点到任一叶子节点路径上节点的数量
最大深度是所有叶子节点的深度的最大值
叶子节点是指没有子节点的节点
方法一：递归（推荐使用）
具体做法：

最大深度是所有叶子节点的深度的最大值，深度是指树的根节点到任一叶子节点路径上节点的数量，因此从根节点每次往下一层深度就会加1。因此二叉树的深度就等于根结点这个1层加上左子树和右子树深度的最大值，即root depth=max(left depth,right depth)+1。而每个子树我们都可以看成一个根节点，继续用上述方法求的深度，于是我们可以对这个问题划为子问题，利用递归来解决：

step 1： 终止条件： 当进入叶子节点后，再进入子节点，即为空，没有深度可言，返回0.
step 2： 返回值： 每一级按照上述公式，返回两边子树深度的最大值加上本级的深度，即加1.
step 3：本级任务： 每一级的任务就是进入左右子树，求左右子树的深度。

```
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param root TreeNode类 
# @return int整型
#
class Solution:
    def maxDepth(self , root: TreeNode) -> int:
        # 空节点没有深度
        if not root: 
            return 0
        # 返回子树深度+1
        return max([self.maxDepth(root.left), self.maxDepth(root.right)]) + 1
```

复杂度分析：

时间复杂度：O(n)，其中n为二叉树的节点数，遍历整棵二叉树
空间复杂度：O(n)，最坏情况下，二叉树化为链表，递归栈深度最大为n

方法二：层次遍历（扩展思路）
具体做法：

既然是统计二叉树的最大深度，除了根据路径到达从根节点到达最远的叶子节点以外，我们还可以分层统计。对于一棵二叉树而言，必然是一层一层的，那一层就是一个深度，有的层可能会很多节点，有的层如根节点或者最远的叶子节点，只有一个节点，但是不管多少个节点，它们都是一层。因此我们可以使用层次遍历，二叉树的层次遍历就是从上到下按层遍历，每层从左到右，我们只要每层统计层数即是深度。

step 1：既然是层次遍历，我们遍历完一层要怎么进入下一层，可以用队列记录这一层中节点的子节点。队列类似栈，是一个先进先出的数据结构，可以理解为我们平时的食堂打饭的排队。因为每层都是按照从左到右开始访问的，那自然记录的子节点也是从左到右，那我们从队列出来的时候也是从左到右，完美契合。
step 2：在刚刚进入某一层的时候，队列中的元素个数就是当前层的节点数。比如第一层，根节点先入队，队列中只有一个节点，对应第一层只有一个节点，第一层访问结束后，它的子节点刚好都加入了队列，此时队列中的元素个数就是下一层的节点数。因此遍历的时候，每层开始统计该层个数，然后遍历相应节点数，精准进入下一层。
step 3：遍历完一层就可以节点深度就可以加1，

```
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param root TreeNode类 
# @return int整型
#
import queue
class Solution:
    def maxDepth(self , root: TreeNode) -> int:
        # 空节点没有深度
        if not root: 
            return 0
        # 队列维护层次后续节点
        q= queue.Queue() 
        # 根入队
        q.put(root) 
        # 记录深度
        res = 0
        # 层次遍历
        while not q.empty(): 
            # 记录当前层有多少节点
            n = q.qsize() 
            # 遍历完这一层，再进入下一层
            for i in range(n): 
                node = q.get()
                # 添加下一层的左右节点
                if node.left: 
                    q.put(node.left)
                if node.right:
                    q.put(node.right)
            # 深度加1
            res += 1 
        return res
```

复杂度分析：

时间复杂度：O(n)，其中nnn为二叉树的节点数，遍历整棵二叉树
空间复杂度：O(n)，辅助队列的空间最坏为n

### BM29. 二叉树中和为某一值的路径(一)

题目的主要信息：
给定一个二叉树root和一个值 sum ，判断是否有从根节点到叶子节点的节点值之和等于 sum 的路径
路径定义为从树的根结点开始往下一直到叶子结点所经过的结点
路径只能从父节点到子节点，不能从子节点到父节点
方法一：递归（推荐使用）
具体做法：

既然是检查从根到叶子有没有一条等于目标值的路径，那肯定需要从根节点遍历到叶子，我们可以在根节点每次往下一层的时候，将sum减去节点值，最后检查是否完整等于0. 而遍历的方法我们可以选取二叉树常用的递归先序遍历，因为每次进入一个子节点，更新sum值以后，相当于对子树查找有没有等于新目标值的路径，因此这就是子问题，递归的三段式为：

终止条件： 每当遇到节点为空，意味着过了叶子节点，返回。每当检查到某个节点没有子节点，它就是叶子节点，此时sum减去叶子节点值刚好为0，说明找到了路径。
返回值： 将子问题中是否有符合新目标值的路径层层往上返回。
本级任务： 每一级需要检查是否到了叶子节点，如果没有则递归地进入子节点，同时更新sum值减掉本层的节点值。
整个过程如下：

step 1：每次检查遍历到的节点是否为空节点，空节点就没有路径。
step 2：再检查遍历到是否为叶子节点，且当前sum值等于节点值，说明可以刚好找到。
step 3：检查左右子节点是否可以有完成路径的，如果任意一条路径可以都返回true，因此这里选用两个子节点递归的或。

```
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param root TreeNode类 
# @param sum int整型 
# @return bool布尔型
#
class Solution:
    def hasPathSum(self , root: TreeNode, sum: int) -> bool:
        # 空节点找不到路径
        if not root: 
            return False
        # 叶子节点，且路径和为sum
        if not root.left and not root.right and sum - root.val == 0:
            return True
        # 递归进入子节点
        return self.hasPathSum(root.left, sum - root.val) or self.hasPathSum(root.right, sum - root.val)
```

复杂度分析：

时间复杂度：O(n)，其中n为二叉树所有节点，前序遍历二叉树所有节点
空间复杂度：O(n)，最坏情况二叉树化为链表，递归栈空间最大为n

方法二：非递归（扩展思路）
具体做法：

在二叉树中能够用递归解决的问题，很多时候我们也可以用非递归来解决。这里遍历过程也可以使用栈辅助，进行dfs遍历，检查往下的路径中是否有等于sum的路径和。

注意，这里仅是dfs，而不是先序遍历，左右节点的顺序没有关系，因为每次往下都是单独添加某个节点的值相加然后继续往下，因此左右节点谁先遍历不管用。

step 1：首先检查空节点，空树没有路径。
step 2：使用两个栈同步遍历，一个栈记录节点，辅助深度优先搜索，另一个栈跟随记录到该节点为止的路径和（C++中可以在一个栈中嵌套pair实现）。根节点及根节点值先进栈。
step 3：遍历的时候每次弹出两个栈中的内容，判断是否是叶子节点且路径和是否等于目标值。
step 4：没有到叶子节点就将左右子节点（如果有）加入栈中，并跟随加入路径和。
step 5：如果遍历结束也没有找到路径和，则该二叉树中没有。

```
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param root TreeNode类 
# @param sum int整型 
# @return bool布尔型
#
class Solution:
    def hasPathSum(self , root: TreeNode, sum: int) -> bool:
        # 空节点找不到路径
        if not root: 
            return False
        # 栈辅助深度优先遍历，并记录到相应节点的路径和
        s = [] 
        # 根节点入栈
        s.append((root, root.val)) 
        while len(s):
            temp = s[-1]
            s.pop()
            # 叶子节点且路径和等于sum
            if (not temp[0].left) and (not temp[0].right) and (temp[1] == sum):
                return True
            # 左节点入栈
            if temp[0].left: 
                s.append((temp[0].left, temp[1] + temp[0].left.val))
            # 右节点入栈
            if temp[0].right: 
                s.append((temp[0].right, temp[1] + temp[0].right.val))
        return False
```

复杂度分析：

时间复杂度：O(n)，其中n为二叉树所有节点，dfs遍历二叉树所有节点
空间复杂度：O(n)，最坏情况二叉树化为链表，递归栈空间最大为n

### BM30. 二叉搜索树与双向链表

题目的主要信息：
将二叉搜索树转化成递增序的双向链表
不能添加新的结点，要在原结点基础上添加链表链接
返回链表中的第一个节点的指针
二叉树节点的左右指针看成双向链表的前后指针
方法一：递归中序遍历（推荐使用）
具体做法：

二叉搜索树的每个节点值大于它的左子节点，且大于全部左子树的节点值，小于它右子节点，且小于全部右子树的节点值。因此最左端的元素一定最小，最右端的元素一定最大，符合“左中右”的特性，因此二叉搜索树的中序遍历就是一个递增序列，我们只要对它中序遍历就可以组装称为递增双向链表。

step 1：创建两个指针，一个指向题目中要求的链表头（head），一个指向当前遍历的前一结点（pre)。
step 2：首先递归到最左，初始化head与pre。
step 3：然后处理中间根节点，依次连接pre与当前结点，连接后更新pre为当前节点。
step 4：最后递归进入右子树，继续处理。
step 5：递归出口即是节点为空则返回。

```
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

#
# 
# @param pRootOfTree TreeNode类 
# @return TreeNode类
#
class Solution:
    head = None
    pre = None
    def Convert(self , pRootOfTree ):
        if not pRootOfTree:
            # 中序递归，叶子为空则返回
            return None       
        # 首先递归到最左最小值
        self.Convert(pRootOfTree.left) 
        # 找到最小值，初始化head与pre
        if not self.pre:       
            self.head = pRootOfTree
            self.pre = pRootOfTree
        # 当前节点与上一节点建立连接，将pre设置为当前值
        else:       
            self.pre.right = pRootOfTree
            pRootOfTree.left = self.pre
            self.pre = pRootOfTree
        self.Convert(pRootOfTree.right)
        return self.head
```

复杂度分析

时间复杂度：O(n)，其中n为二叉树节点数，中序遍历所有节点
空间复杂度：O(n)，递归栈所需要的最大空间

方法二：非递归中序遍历（扩展思路）
具体做法：

二叉树中序遍历除了递归方法，我们还可以尝试非递归解法，与常规的非递归中序遍历几乎相同，只是增加了连接节点。

step 1：创建两个指针，一个指向题目中要求的链表头（head），一个指向当前遍历的前一结点（pre)，创建一个布尔型变量，标记是否是第一次到最左，因为第一次到最左就是链表头。
step 2：判断空树不能连接。
step 3：初始化一个栈辅助中序遍历。
step 4：依次将父节点加入栈中，直接进入二叉树最左端。
step 5：第一次进入最左，初始化head与pre，然后进入它的根节点开始连接。
step 6：最后将右子树加入栈中，栈中依次就弹出“左中右”的节点顺序，直到栈为空。

```
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

#
# 
# @param pRootOfTree TreeNode类 
# @return TreeNode类
#
class Solution:
    def Convert(self , pRootOfTree ):
        if not pRootOfTree:
            return None
        # 设置栈用于遍历
        s = [] 
        head = None
        pre = None
        # 确认第一个遍历到最左，即为首位
        isFirst = True  
        while pRootOfTree or s: 
            # 直到没有左节点
            while pRootOfTree:    
                s.append(pRootOfTree)
                pRootOfTree = pRootOfTree.left
            pRootOfTree = s[-1]
            s.pop()
            # 首位
            if isFirst:  
                head = pRootOfTree
                pre = head
                isFirst = False
            # 当前节点与上一节点建立连接，将pre设置为当前值
            else:          
                pre.right = pRootOfTree
                pRootOfTree.left = pre
                pre = pRootOfTree
            pRootOfTree = pRootOfTree.right
        return head
```

复杂度分析：

时间复杂度：O(n)，其中n为二叉树节点数，中序遍历二叉树所有节点
空间复杂度：O(n)，栈s最大空间为为O(n)

### BM31. 对称的二叉树

题目的主要信息：
判断一棵二叉树是否是镜像，即判断二叉树是否是轴对称图形

方法一：递归（推荐使用）
具体做法：

前序遍历的时候我们采用的是“根左右”的遍历次序，如果这棵二叉树是对称的，即相应的左右节点交换位置完全没有问题，那我们是不是可以尝试“根右左”遍历，按照轴对称图像的性质，这两种次序的遍历结果应该是一样的。不同的方式遍历两次，将结果拿出来比较看起来是一种可行的方法，但也仅仅可行，太过于麻烦。我们不如在遍历的过程就结果比较了。依据前序递归的次序，我们先访问根节点，然后递归地进入左子节点和右子节点，如果要采用“根右左”的顺序，那就应该是递归地进入右子节点，然后进入左子节点。我们可以准备两个指针啊，遍历的时候“根左右”走左边的时候“根右左”走右边，“根左右”走右边的时候“根右左”走左边，这样刚好可以同步遍历比较。

step 1： 终止条件： 当进入子问题的两个节点都为空，说明都到了叶子节点，且是同步的，因此结束本次子问题，返回true；当进入子问题的两个节点只有一个为空，或是元素值不相等，说明这里的对称不匹配，同样结束本次子问题，返回false。
step 2：返回值： 每一级将子问题是否匹配的结果往上传递。
step 3：本级任务： 每个子问题，需要按照上述思路，“根左右”走左边的时候“根右左”走右边，“根左右”走右边的时候“根右左”走左边，一起进入子问题，需要两边都是匹配才能对称。

```
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param pRoot TreeNode类 
# @return bool布尔型
#
class Solution:
    def recursion(self, root1: TreeNode, root2: TreeNode):
        # 可以两个都为空
        if not root1 and not root2: 
            return True
        # 只有一个为空或者节点值不同，必定不对称
        if not root1 or not root2 or root1.val != root2.val:
            return False
        # 每层对应的节点进入递归
        return self.recursion(root1.left, root2.right) and self.recursion(root1.right, root2.left)

    def isSymmetrical(self , pRoot: TreeNode) -> bool:
        return self.recursion(pRoot, pRoot)
```

复杂度分析：

时间复杂度：O(n)，其中n为二叉树的节点数，相当于遍历整个二叉树两次
空间复杂度：O(n)，最坏情况二叉树退化为链表，递归栈深度为n

方法二：层次遍历（扩展思路）
具体做法：

除了递归以外，我们还可以观察，对称的二叉树每一层都是回文的情况，即两边相互对应相等，有节点值的对应节点值，没有节点的连空节点都是对应着的呢。那我们从左往右遍历一层（包括空节点），和从右往左遍历一层（包括空节点），是不是就是得到一样的结果了。（注：必须包含空节点，因为空节点乱插入会导致不同，如题干第二个图所示）。

这时候二叉树每一层的遍历，我就需要用到了层次遍历。层次遍历从左往右经过第一层后，怎么进入第二层？我们可以借助队列——一个先进先出的容器，在遍历第一层的时候，将第一层节点的左右节点都加入到队列中，因为加入队列的顺序是遍历的顺序且先左后右，也就导致了我从队列出来的时候也是下一层的先左后右，正好一一对应。更巧的是，如果我们要从右到左遍历一层，加入队列后也是先右后左，简直完美对应！

而且我们不需要两个层次遍历都完整地遍历二叉树，只需要一半就行了，从左往右遍历左子树，从右往左遍历右子树，各自遍历一半相互比对，因为遍历到另一半都已经检查过了。

step 1：首先判断链表是否为空，空链表直接就是对称。
step 2：准备两个队列，分别作为从左往右层次遍历和从右往左层次遍历的辅助容器，初始第一个队列加入左节点，第二个队列加入右节点。
step 3：循环中每次从队列分别取出一个节点，如果都为空，暂时可以说是对称的，进入下一轮检查；如果某一个为空或是两个节点值不同，那必定不对称。其他情况暂时对称，可以依次从左往右加入子节点到第一个队列，从右往左加入子节点到第二个队列。（这里包括空节点）
step 4：遍历结束也没有检查到不匹配，说明就是对称的。

```
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param pRoot TreeNode类 
# @return bool布尔型
#
import queue
class Solution:
    def isSymmetrical(self , pRoot: TreeNode) -> bool:
        # 空树为对称的
        if not pRoot: 
            return True
        #辅助队列用于从两边层次遍历
        q1 = queue.Queue() 
        q2 = queue.Queue()
        q1.put(pRoot.left)
        q2.put(pRoot.right)
        while not q1.empty() and not q2.empty(): 
            # 分别从左边和右边弹出节点
            left = q1.get()  
            right = q2.get()
            # 都为空暂时对称
            if not left and not right:
                continue
            # 某一个为空或者数字不相等则不对称
            if not left or not right or left.val != right.val:
                return False
            # 从左往右加入队列
            q1.put(left.left) 
            q1.put(left.right)
            # 从右往左加入队列
            q2.put(right.right) 
            q2.put(right.left)
        # 都检验完都是对称的
        return True 
```

复杂度分析：

时间复杂度：O(n)，其中n为二叉树的节点个数，相当于遍历二叉树全部节点
空间复杂度：O(n)，两个辅助队列的最大空间为n

### BM32. 合并二叉树

题目的主要信息：
合并（相加）二叉树位置相同的结点
缺少的节点用另一棵树来补，若都缺则返回NULL
方法一：递归前序遍历（推荐使用）
具体做法：

要将一棵二叉树的节点与另一棵二叉树相加合并，肯定需要遍历两棵二叉树，那我们可以考虑同步遍历两棵二叉树，这样就可以将每次遍历到的值相加在一起。遍历的方式有多种，这里推荐前序递归遍历。

step 1：首先判断t1与t2是否为空，若为则用另一个代替，若都为空，返回的值也是空。
step 2：然后依据前序遍历的特点，优先访问根节点，将两个根点的值相加创建到新树中。
step 3：两棵树再依次同步进入左子树和右子树。

```
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param t1 TreeNode类 
# @param t2 TreeNode类 
# @return TreeNode类
#
class Solution:
    def mergeTrees(self , t1: TreeNode, t2: TreeNode) -> TreeNode:
        # 若只有一个节点返回另一个，两个都为NULL自然返回NULL
        if not t1: 
            return t2
        if not t2:
            return t1
        # 根左右的方式递归
        head = TreeNode(t1.val + t2.val)
        head.left = self.mergeTrees(t1.left, t2.left)
        head.right = self.mergeTrees(t1.right, t2.right)
        return head
```

复杂度分析：

时间复杂度：O(min(n,m))，m和n分别为两棵树的节点树，当一个树访问完时，自然就连接上另一个树的节点，故只访问了小树的节点数。
空间复杂度：O(min(n,m))，递归栈深度也同时间，只访问了小树的节点数。

方法二：非递归层次遍历（扩展思路）
具体做法：

除了递归的遍历以外，非递归的层次遍历，也可以实现两棵树同步遍历节点相加，重点是两棵树从根节点开始每个节点是同步走的。

step 1：首先判断t1与t2是否为空，若为则用另一个代替，若都为空，返回的值也是空。
step 2：使用三个辅助队列，第一个队列q用于暂存合并后的二叉树的层次遍历结点，第二个队列q1用于暂存t1的层次遍历结点，第三个队列q2用于暂存t2的层次遍历结点。
step 3：两棵树同步层次遍历，先将根节点加入队列中，同时根节点优先合并。
step 4：每次从队列分别弹出一个元素，判断分别二者的左右子结点是否存在，若是都存在，则相加合并，若是只存在一个则连接该存在的结点，若是都不存在则连接null。

```
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param t1 TreeNode类 
# @param t2 TreeNode类 
# @return TreeNode类
#
import queue
class Solution:
    # 若只有一个节点返回另一个，两个都为None自然返回None
    def mergeTrees(self , t1: TreeNode, t2: TreeNode) -> TreeNode:
        if not t1:
            return t2
        if not t2:
            return t1
        # 合并根节点
        head = TreeNode(t1.val + t2.val) 
        # 连接后的树的层次遍历节点
        q = queue.Queue() 
        # 分别存两棵树的层次遍历节点
        q1 = queue.Queue() 
        q2 = queue.Queue()
        q.put(head)
        q1.put(t1)  
        q2.put(t2)
        while not q1.empty() and not q2.empty():
            node = q.get()
            node1 = q1.get()
            node2 = q2.get()
            left1 = node1.left
            left2 = node2.left
            right1 = node1.right
            right2 = node2.right
            # 两个左节点都存在
            if left1 or left2:  
                if left1 and left2:
                    left = TreeNode(left1.val + left2.val)
                    node.left = left
                    # 新节点入队列
                    q.put(left)  
                    q1.put(left1)
                    q2.put(left2)
                # 只连接一个节点
                elif left1: 
                    node.left = left1
                elif left2:
                    node.left = left2
            if right1 or right2:
                # 两个右节点都存在
                if right1 and right2: 
                    right = TreeNode(right1.val + right2.val)
                    node.right = right
                    # 新节点入队列
                    q.put(right)
                    q1.put(right1)
                    q2.put(right2)
                # 只连接一个节点
                elif right1:  
                    node.right = right1
                else:
                    node.right = right2
        return head
```

复杂度分析：

时间复杂度：O(min(n,m))，m和n分别为两棵树的节点树，当一个树访问完时，自然就连接上另一个树的节点，故只访问了小树的节点数。
空间复杂度：O(min(n,m))，辅助队列同时间，只访问了小树的节点数。

### BM33. 二叉树的镜像

题目的主要信息：
将二叉树镜像，即将其所有左右子树交换
我们可以考虑自底向上依次交换二叉树的左右结点。

方法一：递归（推荐使用）
具体做法：

因为我们需要将二叉树镜像，意味着每个左右子树都会交换位置，如果我们从上到下对遍历到的节点交换位置，但是它们后面的节点无法跟着他们一起被交换，因此我们可以考虑自底向上对每两个相对位置的节点交换位置，这样往上各个子树也会被交换位置。

自底向上的遍历方式，我们可以采用后序递归的方法：

step 1：先深度最左端的节点，遇到空树返回。
step 2：然后进入子树的最右端。
step 3：再返回到父问题，交换父问题两个节点的值。

```
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param pRoot TreeNode类 
# @return TreeNode类
#
class Solution:
    def Mirror(self , pRoot: TreeNode) -> TreeNode:
        # 空树返回
        if not pRoot: 
            return None
        # 先递归子树
        left = self.Mirror(pRoot.left) 
        right = self.Mirror(pRoot.right)
        # 交换
        pRoot.left = right 
        pRoot.right = left
        return pRoot
```

复杂度分析：

时间复杂度：O(n)，其中nnn为二叉树的节点数，访问二叉树所有节点各一次
空间复杂度：O(n)，最坏情况下，二叉树退化为链表，递归栈最大值为n

方法二：栈（扩展思路）
具体做法：

二叉树中能够用递归的，我们大多也可以用栈来实现。栈的访问是一种自顶向下的访问，因此我们需要在左右子结点入栈后直接交换，然后再访问后续栈中内容。

step 1：优先检查空树的情况。
step 2：使用栈辅助遍历二叉树，根节点先进栈。
step 3：遍历过程中每次弹出栈中一个元素，然后该节点左右节点分别入栈，同时我们交换二者的值，因为子节点已经入栈了再交换，就不怕后续不能交换。

```
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param pRoot TreeNode类 
# @return TreeNode类
#
class Solution:
    def Mirror(self , pRoot: TreeNode) -> TreeNode:
        # 空树
        if not pRoot:  
            return None
        # 辅助栈
        s = [] 
        # 根节点先进栈
        s.append(pRoot) 
        while s:
            node = s[-1]
            s.pop()
            if node.left:
                # 左右节点入栈
                s.append(node.left) 
            if node.right:
                s.append(node.right)
            # 交换左右
            temp = node.left  
            node.left = node.right
            node.right = temp
        return pRoot
```

复杂度分析：

时间复杂度：O(n)，其中n为二叉树的节点数，访问二叉树所有节点各一次
空间复杂度：O(n)，最坏情况下，二叉树退化为链表，栈的最大空间为n

### BM34. 判断是不是二叉搜索树

题目主要信息：
判断给定的一棵二叉树是否是二叉搜索树
二叉搜索树每个左子树元素小于根节点，每个右子树元素大于根节点，中序遍历为递增序


方法一：递归（推荐使用）
具体做法：

还记得二叉搜索树与双向链表这个里面使用的中序遍历吗？既然是判断是否是二叉搜索树，那我们可以继续使用中序遍历。只要之前的节点是二叉树搜索树，那么如果当前的节点小于上一个节点值那么就可以向下判断。*只不过在过程中我们要求反退出。比如一个链表1->2->3->4  只要for循环遍历如果中间有不是递增的直接返回false即可。

step 1：首先递归到最左，初始化maxLeft与pre。
step 2：然后往后遍历整棵树，依次连接pre与当前结点，并更新pre。
step 3：左子树如果不是二叉搜索树返回false。
step 4：判断当前节点是不是小于前置节点，更新前置节点。
step 5：最后由右子树的后面节点决定。

```
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param root TreeNode类 
# @return bool布尔型
#
import sys
class Solution:
    pre = -sys.maxsize - 1
    def isValidBST(self , root: TreeNode) -> bool:
        if not root:
            return True
        # 先进入左子树
        if not self.isValidBST(root.left): 
            return False
        if(root.val <= self.pre):
            return False
        # 更新最值
        self.pre = root.val  
        # 再进入右子树
        if not self.isValidBST(root.right):  
            return False
        return True
```

复杂度分析：

时间复杂度：O(n)，其中n为二叉树的节点数，最坏遍历整个二叉树所有节点
空间复杂度：O(n)，最坏情况二叉树退化为链表，递归栈深度为n

方法二：非递归（扩展思路）
具体做法：

我们也可以利用栈来代替递归。如果一棵二叉树，对于每个根节点都优先访问左子树，那结果是什么？从根节点开始不断往左，第一个被访问的肯定是最左边的节点，然后访问该节点的右子树，最后向上回到父问题。因为每次访问最左的元素不止对一整棵二叉树成立，而是对所有子问题都成立，因此循环的时候自然最开始都是遍历到最左，然后访问，然后再进入右子树，我们可以用栈来实现回归父问题。

step 1：优先判断树是否为空，空树不遍历。
step 2：准备一个数组记录中序遍历的结果。
step 3：准备辅助栈，当二叉树节点为空了且栈中没有节点了，我们就停止访问。
step 4：从根节点开始，每次优先进入每棵的子树的最左边一个节点，我们将其不断加入栈中，用来保存父问题。
step 5：到达最左后，可以开始访问，如果它还有右节点，则将右边也加入栈中，之后右子树的访问也是优先到最左。
step 6：遍历数组，依次比较相邻两个元素是否为递增序。

```
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param root TreeNode类 
# @return bool布尔型
#
class Solution:
    def isValidBST(self , root: TreeNode) -> bool:
        # 设置栈用于遍历 和 记录中序遍历的数组
        s ,sort = [], [] 
        head = root
        while head or s:
            # 直到没有左节点
            while head:   
                s.append(head)
                head = head.left
            head = s[-1]
            s.pop()
            # 访问节点
            sort.append(head.val) 
            head = head.right
        # 遍历中序结果
        for i in range(1, len(sort)):  
            # 一旦有降序，则不是搜索树
            if sort[i - 1] > sort[i]: 
                return False
        return True
```

复杂度分析：

时间复杂度：O(n)，其中n为二叉树的节点数，遍历整个二叉树后又遍历数组
空间复杂度：O(n)，辅助栈及辅助数组的空间最坏为O(n)

### BM35. 判断是不是完全二叉树

题目主要信息：
判断给定二叉树是否为完全二叉树
首先我们需要知道什么是完全二叉树：叶子结点只能出现在最下层和次下层，且最下层的叶子结点集中在树的左部。
需要注意的是，满二叉树肯定是完全二叉树，而完全二叉树不一定是满二叉树。
方法：层次遍历（推荐使用）
具体做法：

对完全二叉树最重要的定义就是叶子结点只能出现在最下层和次下层，所以我们想到可以使用层序遍历，只有次下层和最下层才有叶子节点，其他层出现叶子节点就意味着不是完全二叉树。

step 1：先判断空树一定是完全二叉树。
step 2：初始化一个队列辅助层次遍历，将根节点加入。
step 3：逐渐从队列中弹出元素访问节点，如果遇到某个节点为空，进行标记，若是后续还有访问，则说明提前出线了叶子节点。
step 4：否则，继续加入左右子节点进入队列排队，等待访问。

```
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param root TreeNode类 
# @return bool布尔型
#
import queue

class Solution:
    def isCompleteTree(self , root: TreeNode) -> bool:
        # 空树一定是完全二叉树
        if not root:  
            return True
        q = queue.Queue()
        # 根节点先访问
        q.put(root) 
        # 定义一个首次出现的标记位
        flag = False 
        # 层次遍历
        while not q.empty(): 
            sz = q.qsize()
            for i in range(sz):
                cur = q.get()
                # 标记第一次遇到空节点
                if not cur: 
                    flag = True
                else:
                    # 后续访问已经遇到空节点了，说明经过了叶子
                    if flag:
                        return False
                    q.put(cur.left)
                    q.put(cur.right)
        return True
```

复杂度分析：

时间复杂度：O(n)，其中nnn为二叉树节点数，层次遍历最坏情况下遍历每一个节点
空间复杂度：O(n)，最坏情况下，层次队列的最大空间为O(n)

### BM36. 判断是不是平衡二叉树

题目主要信息：
判断给出的二叉树是否是平衡二叉树
需要判断任意一节点两边子树深度相差是否绝对值大于1，同时它的子树也符合平衡二叉树的规则
方法一：自顶向下（推荐使用）
具体做法：

上述提到了，平衡二叉树任意节点两边的子树深度相差绝对值不会超过1，且每个子树都满足这个条件，那我们可以对每个节点找到两边的深度以后，判断是否两边相差绝对值超过1，然后因为每个子树都满足这个条件，我们还需要遍历二叉树每个节点当成一棵子树进行判断，而对于每个每个节点判断后，其子节点就是子问题，因此可以用递归。

step 1：第一个函数递归遍历二叉树所有结点。
step 2：对于每个节点判断，调用第二个函数获取子树深度。
step 3：第二个函数递归获取子树深度，只需要不断往子节点深度遍历，累加左右深度的较大值。
step 4：根据深度判断该节点下的子树是否为平衡二叉树。

```
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param pRoot TreeNode类 
# @return bool布尔型
#
class Solution:
    #计算该子树深度函数
    def deep(self, root: TreeNode):
        if not root:
            return 0
        # 递归算左右子树的深度
        left = self.deep(root.left) 
        right = self.deep(root.right)
        # 子树最大深度加上自己
        return left + 1 if left > right else right + 1
        
    def IsBalanced_Solution(self , pRoot: TreeNode) -> bool:
        # 空树为平衡二叉树
        if not pRoot: 
            return True
        left = self.deep(pRoot.left)
        right = self.deep(pRoot.right)
        # 左子树深度减去右子树相差绝对值大于1
        if left - right > 1 or left - right < -1: 
            return False
        # 同时，左右子树还必须是平衡的
        return self.IsBalanced_Solution(pRoot.left) and self.IsBalanced_Solution(pRoot.right)
```

复杂度分析：

时间复杂度：O(n^2)，其中nnn为二叉树的节点数，第一个递归遍历二叉树所有节点，第二个递归查找深度最坏情况下（二叉树退化为链表）需要遍历二叉树所有节点
空间复杂度：O(n)，递归栈最大深度为n

方法二：自底向上（扩展思路）
上述一个函数算深度，一个函数遍历所有结点的方法，用了两个递归，做了很多不必要的运，这就是自顶向下的弊端。那我们可以考虑自底向上，在底部计算深度的同时，判断该子树是否为平衡二叉树，将是或否与深度信息往上传就行。

step 1：先判断空树，直接为平衡二叉树。
step 2：递归进行变计算深度边判断是否平衡二叉树。
step 3：递归计算当前节点左右子树的高度差，然后比较深度。
step 4：每次递归都将深度结果往上传，就能做到边判断边计算深度了。

```
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param pRoot TreeNode类 
# @return bool布尔型
#
class Solution:
    # 计算该子树深度
    def getdepth(self, root: TreeNode) -> int: 
        if not root: # 空节点深度为0
            return 0
        # 递归计算当前root左右子树的深度差
        left = self.getdepth(root.left) 
        # 当前节点左子树不平衡,则该树不平衡
        if left < 0: 
            return -1
        right = self.getdepth(root.right)
        # 当前节点右子树不平衡,则该树不平衡
        if right < 0: 
            return -1 
        return -1 if abs(left-right) > 1 else 1 + max([left, right])
    
    def IsBalanced_Solution(self , pRoot: TreeNode) -> bool:
        if not pRoot:
            return True
        return self.getdepth(pRoot) != -1
```

复杂度分析：

时间复杂度：O(n)，其中nnn为树的节点数，一次递归遍历二叉树所有节点
空间复杂度：O(n)，最坏情况下递归栈的深度为n

### BM37. 二叉搜索树的最近公共祖先

题目的主要信息：
给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先：

对于该题的最近的公共祖先定义：对于有根树T的两个结点p、q，最近公共祖先LCA(T,p,q)表示一个结点x，满足x是p和q的祖先且x的深度尽可能大
一个节点也可以是它自己的祖先
二叉搜索树是若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值
所有节点的值都是唯一的，可以通过节点值直接比较
p、q 为不同节点且均存在于给定的二叉搜索树中
方法一：两次遍历（推荐使用）
具体做法：

二叉搜索树没有相同值的节点，因此分别从根节点往下利用二叉搜索树可以轻松找到p、q，这样我们利用路径就可以找到最近公共祖先。

step 1：根据二叉搜索树的性质，从根节点开始查找目标节点，当前节点比目标小则进入右子树，当前节点比目标大则进入左子树，直到找到目标节点。这个过程成用数组记录遇到的元素。
step 2：分别在搜索二叉树中找到p和q两个点，并记录各自的路径为数组。
step 3：同时遍历两个数组，比较元素值，最后一个相等的元素就是最近的公共祖先。

```
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param root TreeNode类 
# @param p int整型 
# @param q int整型 
# @return int整型
#
class Solution:
    def getPath(self, root: TreeNode, target: int) -> List[int]:
        path = []
        node = root
        # 节点值都不同，可以直接用值比较
        while node.val != target: 
            path.append(node.val)
            # 小的在左子树
            if target < node.val: 
                node = node.left
            # 大的在右子树
            else: 
                node = node.right
        path.append(node.val)
        return path
    
    def lowestCommonAncestor(self , root: TreeNode, p: int, q: int) -> int:
        # 求根节点到两个节点的路径
        path_p = self.getPath(root, p) 
        path_q = self.getPath(root, q)
        # 比较两个路径，找到第一个不同的点
        i = 0
        while i < len(path_p) and i < len(path_q):
            if path_p[i] == path_q[i]:
                # 最后一个相同的节点就是最近公共祖先
                res = path_p[i]; 
                i += 1
            else:
                break
        return res
```

复杂度分析：

时间复杂度：O(n)，设二叉树共有n个节点，因此最坏情况二叉搜索树变成链表，搜索到目标节点需要O(n)，比较路径前半段的相同也需要O(n)
空间复杂度：O(n)，记录路径的数组最长为n

方法二：一次遍历（扩展思路）
具体做法：

我们也可以利用二叉搜索树的性质：对于某一个节点若是p与q都小于等于这个这个节点值，说明p、q都在这个节点的左子树，而最近的公共祖先也一定在这个节点的左子树；若是p与q都大于等于这个节点，说明p、q都在这个节点的右子树，而最近的公共祖先也一定在这个节点的右子树。而若是对于某个节点，p与q的值一个大于等于节点值，一个小于等于节点值，说明它们分布在该节点的两边，而这个节点就是最近的公共祖先，因此从上到下的其他祖先都将这个两个节点放到同一子树，只有最近公共祖先会将它们放入不同的子树，每次进入一个子树又回到刚刚的问题，因此可以使用递归。

step 1：首先检查空节点，空树没有公共祖先。
step 2：对于某个节点，比较与p、q的大小，若p、q在该节点两边说明这就是最近公共祖先。
step 3：如果p、q都在该节点的左边，则递归进入左子树。
step 4：如果p、q都在该节点的右边，则递归进入右子树。

```
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param root TreeNode类 
# @param p int整型 
# @param q int整型 
# @return int整型
#
class Solution:
    def lowestCommonAncestor(self , root: TreeNode, p: int, q: int) -> int:
        # 空树找不到公共祖先
        if not root: 
            return -1
        # pq在该节点两边说明这就是最近公共祖先
        if (p >= root.val and q <= root.val) or (p <= root.val and q >= root.val):
            return root.val
        # pq都在该节点的左边
        elif p <= root.val and q <= root.val: 
            # 进入左子树
            return self.lowestCommonAncestor(root.left, p, q) 
        #pq都在该节点的右边
        else: 
            # 进入右子树
            return self.lowestCommonAncestor(root.right, p, q) 
```

复杂度分析：

时间复杂度：O(n)，设二叉树共有n个节点，最坏情况递归遍历所有节点
空间复杂度：O(n)，递归栈深度最坏为n

### BM38. 在二叉树中找到两个节点的最近公共祖先

题目的主要信息：
给定一棵二叉树以及这棵树上的两个节点对应的val值 o1 和 o2，请找到 o1 和 o2 的最近公共祖先节点
二叉树非空，且每个节点值均不同
方法一：路径比较法(推荐使用)
具体做法：

既然要找到二叉树中两个节点的最近公共祖先，那我们可以考虑先找到两个节点全部祖先，然后依次比较的出谁是最近的祖先。

step 1：利用dfs求得根节点到两个目标节点的路径：每次选择二叉树的一棵子树往下找，同时路径数组增加这个遍历的节点值，一旦遍历到了叶子节点也没有，则回溯到父节点，寻找其他路径，回溯时要去掉数组中刚刚加入的元素。
step 2：然后遍历两条路径数组，依次比较元素值。
step 3：找到两条路径第一个不相同的节点即是最近公共祖先。

```
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param root TreeNode类 
# @param o1 int整型 
# @param o2 int整型 
# @return int整型
#
class Solution:
    # 记录是否找到到o的路径
    flag = False 
    # 求得根节点到目标节点的路径
    def dfs(self, root: TreeNode, path: List[int], o: int): 
        if self.flag or not root:
            return
        path.append(root.val)
        # 节点值都不同，可以直接用值比较
        if root.val == o: 
            self.flag = True
            return
        # dfs遍历查找
        self.dfs(root.left, path, o) 
        self.dfs(root.right, path, o)
        #找到
        if self.flag:
            return
        # 该子树没有，回溯
        path.pop() 
        
    def lowestCommonAncestor(self , root: TreeNode, o1: int, o2: int) -> int:
        path1, path2 = [], []
        # 求根节点到两个节点的路径
        self.dfs(root, path1, o1) 
        # 重置flag，查找下一个
        self.flag = False 
        self.dfs(root, path2, o2)
        i = 0
        res = None
        # 比较两个路径，找到第一个不同的点
        while i < len(path1) and i < len(path2): 
            if path1[i] == path2[i]: 
                # 最后一个相同的节点就是最近公共祖先
                res = path1[i] 
                i += 1
            else:
                break
        return res
```

复杂度分析：

时间复杂度：O(n)，其中n为二叉树节点数，递归遍历二叉树每一个节点求路径，后续又遍历路径
空间复杂度：O(n)，最坏情况二叉树化为链表，深度为n，递归栈深度和路径数组为n

方法二：递归（扩展思路）
具体做法：

我们可以从根节点开始思想几种情况：

step 1：如果o1和o2中的任一个和root匹配，那么root就是最近公共祖先。 
step 2：如果都不匹配，则分别递归左、右子树。
step 3：如果有一个节点出现在左子树，并且另一个节点出现在右子树，则root就是最近公共祖先.
step 4：如果两个节点都出现在左子树，则说明最低公共祖先在左子树中，否则在右子树。
因此可以使用递归直接解决。

```
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param root TreeNode类 
# @param o1 int整型 
# @param o2 int整型 
# @return int整型
#
class Solution:
    # 记录是否找到到o的路径
    flag = False 
    # 求得根节点到目标节点的路径
    def dfs(self, root: TreeNode, path: List[int], o: int): 
        if self.flag or not root:
            return
        path.append(root.val)
        # 节点值都不同，可以直接用值比较
        if root.val == o: 
            self.flag = True
            return
        # dfs遍历查找
        self.dfs(root.left, path, o) 
        self.dfs(root.right, path, o)
        #找到
        if self.flag:
            return
        # 该子树没有，回溯
        path.pop() 
        
    def lowestCommonAncestor(self , root: TreeNode, o1: int, o2: int) -> int:
        path1, path2 = [], []
        # 求根节点到两个节点的路径
        self.dfs(root, path1, o1) 
        # 重置flag，查找下一个
        self.flag = False 
        self.dfs(root, path2, o2)
        i = 0
        res = None
        # 比较两个路径，找到第一个不同的点
        while i < len(path1) and i < len(path2): 
            if path1[i] == path2[i]: 
                # 最后一个相同的节点就是最近公共祖先
                res = path1[i] 
                i += 1
            else:
                break
        return res
```

复杂度分析：

时间复杂度：O(n)，其中n为节点数，递归遍历二叉树每一个节点
空间复杂度：O(n)，最坏情况二叉树化为链表，递归栈深度为n

### BM39. 序列化二叉树

题目主要信息：
序列化二叉树即找一种顺序存储二叉树的节点，并以相同的方式能够读取序列重新构建。
换种说法，就是遍历二叉树，记录每个结点，再以同样的方式遍历就可以还原二叉树。
遍历的方法有四种：前序遍历、中序遍历、后序遍历、层次遍历，理论上只要以相同的方式序列化或者反序列化，都可以解题。
方法：前序遍历（推荐使用）
具体做法：

反序列化即按照前序遍历的思路，遍历二叉树每个节点，并将节点值存储在字符串中，我们用‘#’表示空节点，用‘!'表示节点与节点之间的分割。
序列化即根据给定的字符串，将二叉树重建，因为字符串中的顺序是前序遍历，因此我们重建的时候也是前序遍历。

step 1：优先处理序列化，SerializeFunction函数负责先序递归，遇到空节点在字符串中添加‘#’，遇到非空节点，添加相应节点数字和‘!’，然后依次进入左子树，右子树。
step 2：创建全局变量index表示序列中的下标（C++中直接指针完成）。
step 3：DeserializeFunction函数负责先序递归构建树，遇到‘#’则是空节点，遇到数字则根据感叹号分割，将字符串转换为数字后加入创建的节点中。然后依次创建左子树、右子树。

```
# -*- coding:utf-8 -*-
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
import sys
#设置递归深度
sys.setrecursionlimit(100000) 
class Solution:
    def __init__(self):
        self.index = 0 
        self.s = ""

    #处理序列化（递归）
    def SerializeFunction(self, root):
        #空节点
        if not root:
            self.s += '#'
            return
        #根节点
        self.s += (str)(root.val) + '!'
        #左子树
        self.SerializeFunction(root.left) 
        #右子树
        self.SerializeFunction(root.right) 
    
    def Serialize(self, root): 
        if not root:
            return '#'
        self.s = ""
        self.SerializeFunction(root)
        return self.s
    
    #处理反序列化的功能函数（递归）
    def DeserializeFunction(self, s: str):
        # 到达叶节点时，构建完毕，返回继续构建父节点
        #空节点
        if self.index >= len(s) or s[self.index] == "#": 
            self.index += 1
            return None
        # 数字转换
        val = 0
        #遇到分隔符或者结尾
        while s[self.index] != '!' and self.index != len(s):
            val = val * 10 + (int)(s[self.index])
            self.index += 1
        root = TreeNode(val)
        #序列到底了，构建完成
        if self.index == len(s): 
            return root
        else:
            self.index += 1
        #反序列化与序列化一致，都是前序
        root.left = self.DeserializeFunction(s)  
        root.right = self.DeserializeFunction(s)
        return root

    def Deserialize(self, s):
        if s == "#":
            return None
        return self.DeserializeFunction(s)
```

复杂度分析：

时间复杂度：O(n)，其中nnn为二叉树节点数，前序遍历，每个节点遍历一遍
空间复杂度：O(n)，最坏情况下，二叉树退化为链表，递归栈最大深度为n

### BM40. 重建二叉树

题目的主要信息：
根据二叉树的前序遍历序列和中序遍历序列，重建该二叉树，并返回根节点
两个遍历都没有重复的元素
方法一：递归（推荐使用）
具体做法：

对于二叉树的前序遍历，我们知道序列的第一个元素必定是根节点的值，因为序列没有重复的元素，因此中序遍历中可以找到相同的这个元素，而我们又知道中序遍历中根节点将二叉树分成了左右子树两个部分，如下图所示：


![图片说明](https://uploadfiles.nowcoder.com/images/20220308/588579017_1646737384726/2939E21521C22C46A95A8B8DFA62CE0D) 

我们可以发现，数字1是根节点，并将二叉树分成了(247)和(3568)两棵子树，而子树的的根也是相应前序序列的首位，比如左子树的根是数字2，右子树的根是数字3，这样我们就可以利用前序遍历序列找子树的根节点，利用中序遍历序列区分每个子树的节点数。

step 1：先根据前序遍历第一个点建立根节点。
step 2：然后遍历中序遍历找到根节点在数组中的位置。‘
step 2：再按照子树的节点数将两个遍历的序列分割成子数组，将子数组送入函数建立子树。
step 4：知道子树的序列长度为0，结束递归。

```
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param pre int整型一维数组 
# @param vin int整型一维数组 
# @return TreeNode类
#
class Solution:
    def reConstructBinaryTree(self , pre: List[int], vin: List[int]) -> TreeNode:
        n = len(pre)
        m = len(vin)
        # 每个遍历都不能为0
        if n == 0 or m == 0: 
            return None
        # 构建根节点
        root = TreeNode(pre[0]) 
        for i in range(len(vin)):
            # 找到中序遍历中的前序第一个元素
            if pre[0] == vin[i]: 
                # 左子树的前序遍历
                leftpre = pre[1:i+1] 
                # 左子树的中序遍历
                leftvin = vin[:i] 
                # 构建左子树
                root.left = self.reConstructBinaryTree(leftpre, leftvin) 
                # 右子树的前序遍历
                rightpre = pre[i+1:] 
                # 右子树的中序遍历
                rightvin = vin[i+1:] 
                # 构建右子树
                root.right = self.reConstructBinaryTree(rightpre, rightvin) 
                break
        return root
```

复杂度分析：

时间复杂度：O(n)，其中n为数组长度，即二叉树的节点数，构建每个节点进一次递归，递归中所有的循环加起来一共n次
空间复杂度：O(n)，递归栈最大深度不超过n，辅助数组长度也不超过n，重建的二叉树空间属于必要空间，不属于辅助空间

方法二：栈（思路扩展）
具体做法：

除了递归，我们也可以用类似非递归前序遍历的方式建立二叉树。

step 1：首先前序遍历第一个数字依然是根节点，并建立栈辅助遍历。
step 2：然后我们就开始判断，在前序遍历中相邻的两个数字必定是只有两种情况：要么前序后一个是前一个的左节点；要么前序后一个是前一个的右节点或者其祖先的右节点。
step 3：我们可以同时顺序遍历pre和vin两个序列，判断是否是左节点，如果是左节点则不断向左深入，用栈记录祖先，如果不是需要弹出栈回到相应的祖先，然后进入右子树，整个过程类似非递归前序遍历。

```
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param pre int整型一维数组 
# @param vin int整型一维数组 
# @return TreeNode类
#
class Solution:
    def reConstructBinaryTree(self , pre: List[int], vin: List[int]) -> TreeNode:
        n = len(pre)
        m = len(vin)
        # 每个遍历都不能为0
        if n == 0 or m == 0: 
            return None
        s = []
        # 首先建立前序第一个即根节点
        root = TreeNode(pre[0]) 
        cur = root
        j = 0
        for i in range(1, n):
            # 要么旁边这个是它的左节点
            if cur.val != vin[j]: 
                cur.left = TreeNode(pre[i])
                s.append(cur)
                # 要么旁边这个是它的右节点，或者祖先的右节点
                cur = cur.left 
            else:
                j += 1
                # 弹出到符合的祖先
                while s and s[-1].val == vin[j]: 
                    cur = s[-1]
                    s.pop()
                    j += 1
                # 添加右节点
                cur.right = TreeNode(pre[i]) 
                cur = cur.right
        return root
```

复杂度分析：

时间复杂度：O(n)，其中nnn为数组长度，即二叉树的节点数，遍历一次数组，弹出栈的循环最多进行n次
空间复杂度：O(n)，栈空间最大深度为n，重建的二叉树空间属于必要空间，不属于辅助空间

### BM41. 输出二叉树的右视图

题目的主要信息：
利用二叉树中序遍历结果及前序遍历结果构建一棵二叉树
打印二叉树的右视图，即二叉树每层最右边的结点元素
节点值互不相同
方法一：递归建树+深度优先搜索（推荐使用）
具体做法：

可以发现解这道题，我们有两个步骤：

建树
打印右视图
首先建树方面，前序遍历是根左右的顺序，中序遍历是左根右的顺序，因为节点值互不相同，我们可以根据在前序遍历中找到根节点（每个子树部分第一个就是），再在中序遍历中找到对应的值，从其左右分割开，左边就是该树的左子树，右边就是该树的右子树，于是将问题划分为了子问题。

而打印右视图即找到二叉树每层最右边的节点元素，我们可以采取dfs（深度优先搜索）遍历树，根据记录的深度找到最右值。

step 1：首先检查两个遍历序列的大小，若是为0，则空树不用打印。
step 2：建树函数根据上述说，每次利用前序遍历第一个元素就是根节点，在中序遍历中找到它将二叉树划分为左右子树，利用l1 r1 l2 r2分别记录子树部分在数组中分别对应的下标，并将子树的数组部分送入函数进行递归。
step 3：dfs打印右视图时，使用哈希表存储每个深度对应的最右边节点，初始化两个栈辅助遍历，第一个栈记录dfs时的节点，第二个栈记录遍历到的深度，根节点先入栈。
step 4：对于每个访问的节点，每次左子节点先进栈，右子节点再进栈，这样访问完一层后，因为栈的先进后出原理，每次都是右边被优先访问，因此我们在哈希表该层没有元素时，添加第一个该层遇到的元素就是最右边的节点。
step 5：使用一个变量逐层维护深度最大值，最后遍历每个深度，从哈希表中读出每个深度的最右边节点加入数组中。

```
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 求二叉树的右视图
# @param xianxu int整型一维数组 先序遍历
# @param zhongxu int整型一维数组 中序遍历
# @return int整型一维数组
#
from collections import defaultdict

class Solution:
    # 建树函数
    # 四个int参数分别是前序最左节点下标，前序最右节点下标
    # 中序最左节点下标，中序最右节点坐标
    def buildTree(self, xianxu: List[int], l1: int, r1: int, zhongxu: List[int], l2: int, r2: int) -> TreeNode:
        if l1 > r1 or l2 > r2:
            return None
        # 构建节点
        root = TreeNode(xianxu[l1])    
        # 用来保存根节点在中序遍历列表的下标
        rootIndex = 0    
        # 寻找根节点
        for i in range(l2, r2+1):
            if zhongxu[i] == xianxu[l1]:
                rootIndex = i
                break
        # 左子树大小
        leftsize = rootIndex - l2    
        # 右子树大小
        rightsize = r2 - rootIndex    
        # 递归构建左子树和右子树
        root.left = self.buildTree(xianxu, l1 + 1, l1 + leftsize, zhongxu, l2 , l2 + leftsize - 1)
        root.right = self.buildTree(xianxu, r1 - rightsize + 1, r1, zhongxu, rootIndex + 1, r2)
        return root
    def rightSideView(self, root: TreeNode):
        # 右边最深处的值
        mp = defaultdict(int) 
        # 记录最大深度
        max_depth = -1 
        # 维护深度访问节点和维护dfs时的深度
        nodes, depths= [], [] 
        nodes.append(root)
        depths.append(0)
        while nodes:
            node = nodes[-1]
            nodes.pop()
            depth = depths[-1]
            depths.pop()
            if node:
            	# 维护二叉树的最大深度
                max_depth = max([max_depth, depth])
                # 如果不存在对应深度的节点我们才插入
                if mp[depth] == 0:
                    mp[depth] =  node.val
                nodes.append(node.left)
                nodes.append(node.right)
                depths.append(depth + 1)
                depths.append(depth + 1)
        res = []
        for i in range(max_depth + 1):
            res.append(mp[i])
        return res
    def solve(self , xianxu: List[int], zhongxu: List[int]) -> List[int]:
        res = []
        # 空节点
        if(len(xianxu) == 0): 
            return res
        # 建树
        root = self.buildTree(xianxu, 0, len(xianxu) - 1, zhongxu, 0, len(zhongxu) - 1)
        # 找每一层最右边的节点
        return self.rightSideView(root)
```

复杂度分析：

时间复杂度：O(n^2^)，建树部分递归为O(n)，中序遍历中寻找根节点最坏O(n)，dfs每个节点访问一遍O(n)，故为O(n^2^)
空间复杂度：O(n)，递归栈、哈希表、栈的空间都为O(n)

方法二：哈希表优化的递归建树+层次遍历(扩展思路)
具体做法：

对于方法一中每次要寻找中序遍历中的根节点很浪费时间，我们可以利用一个哈希表直接将中序遍历的元素与前序遍历中的下标做一个映射，后续查找中序根结点便可以直接访问了。
同时除了深度优先搜索可以找最右节点，我们也可以利用层次遍历，借助队列，找到每一层的最右。值得注意的是：每进入一层，队列中的元素个数就是该层的节点数。因为在上一层他们的父节点将它们加入队列中的，父节点访问完之后，刚好就是这一层的所有节点。

step 1：首先检查两个遍历序列的大小，若是为0，则空树不用打印。
step 2：遍历前序遍历序列，用哈希表将中序遍历中的数值与前序遍历的下标建立映射。
step 3：按照方法一递归划分子树，只是可以利用哈希表直接在中序遍历中定位根节点的位置。
step 4：建立队列辅助层次遍历，根节点先进队。
step 5：用一个size变量，每次进入一层的时候记录当前队列大小，等到size为0时，便到了最右边，记录下该节点元素。

```
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 求二叉树的右视图
# @param xianxu int整型一维数组 先序遍历
# @param zhongxu int整型一维数组 中序遍历
# @return int整型一维数组
#
from collections import defaultdict
import queue

class Solution:
    index = defaultdict(int)
    # 建树函数
    # 四个int参数分别是前序最左节点下标，前序最右节点下标
    # 中序最左节点下标，中序最右节点坐标
    def buildTree(self, xianxu: List[int], l1: int, r1: int, zhongxu: List[int], l2: int, r2:int) -> TreeNode:
        if l1 > r1 or l2 > r2:
            return None
        # 前序遍历中的第一个节点就是根节点
        xianxu_root = l1 
        # 在中序遍历中定位根节点
        zhongxu_root = self.index[xianxu[xianxu_root]] 
        root = TreeNode(xianxu[xianxu_root])
        # 得到左子树中的节点数目
        leftsize = zhongxu_root - l2 
        root.left = self.buildTree(xianxu, l1 + 1, l1 + leftsize, zhongxu, l2, zhongxu_root - 1)
        root.right = self.buildTree(xianxu, l1 + leftsize + 1, r1, zhongxu, zhongxu_root + 1, r2)
        return root
    
    #层次遍历
    def rightSideView(self, root: TreeNode) -> List[int]:
        res = []
        q = queue.Queue()
        q.put(root)
        while not q.empty():
            #队列中的大小即是这一层的节点树
            size = q.qsize()
            while size:
                size -= 1
                temp = q.get()
                if temp.left:
                    q.put(temp.left)
                if temp.right:
                    q.put(temp.right)
                #最右元素
                if size == 0:
                    res.append(temp.val)
        return res
    
    def solve(self , xianxu: List[int], zhongxu: List[int]) -> List[int]:
        res = []
        # 空节点
        if len(xianxu) == 0: 
            return res
        for i in range(len(xianxu)):
            self.index[zhongxu[i]] = i
        # 建树
        root = self.buildTree(xianxu, 0, len(xianxu) - 1, zhongxu, 0, len(zhongxu) - 1)
        # 找每一层最右边的节点
        return self.rightSideView(root)
```

复杂度分析：

时间复杂度：O(n)，其中nnn为二叉树节点个数，每个节点访问一次，哈希表直接访问数组中的元素
空间复杂度：O(n)，递归栈深度、哈希表、队列的空间都为O(n)

## 04堆/栈/队列

### BM42. 用两个栈实现队列

题目主要信息:
队列：元素不可直接下标访问，先进先出
栈：元素不可直接访问，先进后出
使用两个栈模拟在队列中插入n个元素和弹出n个元素，顺序不定，但是保证操作都是合法的
方法：双栈法（推荐使用）
具体做法：

元素进栈以后，只能优先弹出末尾元素，但是队列每次弹出的却是最先进去的元素，如果能够将栈中元素全部取出来，才能访问到最前面的元素，此时，另一个栈就起作用了。

step 1：push操作就正常push到第一个栈末尾。
step 2：pop操作时，优先将第一个栈的元素弹出，并依次进入第二个栈中。
step 3：第一个栈中最后取出的元素也就是最后进入第二个栈的元素就是队列首部元素，要弹出，此时在第二个栈中可以直接弹出。
step 4：再将第二个中保存的内容，依次弹出，依次进入第一个栈中，这样第一个栈中虽然取出了最里面的元素，但是顺序并没有变。

```
# -*- coding:utf-8 -*-
class Solution:
    def __init__(self):
        self.stack1 = []
        self.stack2 = []
    def push(self, node):
        self.stack1.append(node)
    def pop(self):
        #将第一个栈中内容弹出放入第二个栈中
        while self.stack1: 
            self.stack2.append(self.stack1.pop()) 
        #第二个栈栈顶就是最先进来的元素，即队首
        res = self.stack2.pop() 
        #再将第二个栈的元素放回第一个栈
        while self.stack2: 
            self.stack1.append(self.stack2.pop())
        return res
```

复杂度分析：

时间复杂度：push的时间复杂度为O(1)，pop的时间复杂度为O(n)，push是直接加到栈尾，相当于遍历了两次栈
空间复杂度：O(n)，借助了另一个辅助栈空间

### BM43. 包含min函数的栈

题目主要信息：
实现栈的push、pop、top、min函数
访问每个函数的时间复杂度为


方法：双栈法（推荐使用）
具体做法：

我们都知道栈结构的push、pop、top操作都是O(1)，但是min函数做不到，于是想到在push的时候就将最小值记录下来，由于栈先进后出的特殊性，只能同样用栈来记录最小值。

step 1：使用一个栈记录进入栈的元素，正常进行push、pop、top操作。
step 2：使用另一个栈记录每次push进入的最小值。
step 3：每次push元素的时候与第二个栈的栈顶元素比较，若是较小，则进入第二个栈，若是较大，则第二个栈的栈顶元素再次入栈，因为即便加了一个元素，它依然是最小值。于是，每次访问最小值即访问第二个栈的栈顶。

```
# -*- coding:utf-8 -*-
class Solution:
    def __init__(self):
        self.s1 = []
        self.s2 = []
    def push(self, node):
        self.s1.append(node)  
        #空或者新元素较小，则入栈
        if len(self.s2) == 0 or self.s2[-1] > node:  
            self.s2.append(node)
        else:
            #重复加入栈顶
            self.s2.append(self.s2[-1])  
    def pop(self):
        self.s1.pop()
        self.s2.pop()
    def top(self):
        return self.s1[-1]
    def min(self):
        return self.s2[-1]
```

复杂度分析：

时间复杂度：O(1)，每个函数访问都是直接访问，无循环
空间复杂度：O(n)，s1为必要空间，s2为辅助空间

### BM44. 有效括号序列

题目主要信息:
给定一个只包含大中小左右括号的字符串，判断其中括号是否合法
大中小括号的数学顺序与合法无关，只需要每种左括号在右边有相应匹配的右括号即可，不可交叉匹配，应该是括号嵌套
方法：栈（推荐使用）
具体做法：

括号的匹配规则应该符合先进后出原理：最外层的括号即最早出现的左括号，也对应最晚出现的右括号，即先进后出，因此使用同样先进后出的栈。

step 1：创建辅助栈，遍历字符串。
step 2：每次遇到小括号的左括号、中括号的左括号、大括号的左括号，就将其对应的呦括号加入栈中，期待在后续遇到。
step 3：如果没有遇到左括号但是栈为空，说明直接遇到了右括号，不合法。
step 4：其他情况下，如果遇到右括号，刚好会与栈顶元素相同，弹出栈顶元素继续遍历。
step 5：理论上，只要括号是匹配的，栈中元素最后是为空的，因此检查栈是否为空即可最后判断是否合法。

```
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param s string字符串 
# @return bool布尔型
#
class Solution:
    def isValid(self , s: str) -> bool:
        #辅助栈
        st = [] 
        #遍历字符串
        for i, char in enumerate(s): 
            #遇到左小括号
            if char == '(': 
                #期待遇到右小括号
                st.append(')') 
            #遇到左中括号
            elif char == '[': 
                #期待遇到右中括号
                st.append(']') 
            #遇到左打括号
            elif char == '{': 
                #期待遇到右打括号
                st.append('}') 
            #必须有左括号的情况下才能遇到右括号
            elif(len(st) == 0): 
                return False
            #右括号匹配则弹出
            elif(st[-1] == char): 
                st.pop()
        #栈中是否还有元素
        return len(st) == 0 
```

复杂度分析：

时间复杂度：O(n)，其中nnn为字符串长度，遍历整个字符串
空间复杂度：O(n)，最坏情况下栈空间中记录整个字符串长度的右括号

### BM45. 滑动窗口的最大值

题目主要信息：
要寻找每个滑动窗口的最大值，每次只滑一位
size等于0或者大于数组长度，都返回空值
方法一：双向队列（推荐使用）
具体做法：

我们都知道，若是一个数字A进入窗口后，若是比窗口内其他数字都大，那么这个数字之前的数字都没用了，因为它们必定会比A早离开窗口，在A离开之前都争不过A，所以A在进入时要依次从后排除掉前面的小值。而因为窗口符合先进先出的原理，因此可以考虑双向队列。

step 1：维护一个双向队列，用来存储数列的下标。
step 2：首先检查窗口大小与数组大小。
step 3：先遍历第一个窗口，如果即将进入队列的下标的值大于队列后方的值，依次将小于的值拿出来去掉，再加入，保证队列是递增序。
step 4：遍历后续窗口，每次取出队首就是最大值，如果某个下标已经过了窗口，则从队列前方将其弹出。
step 5：对于之后的窗口，重复step 3，直到数组结束。

```
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param num int整型一维数组 
# @param size int整型 
# @return int整型一维数组
#
class Solution:
    def maxInWindows(self , num: List[int], size: int) -> List[int]:
        res = []
         #窗口大于数组长度的时候，返回空
        if size <= len(num) and size != 0:
            from collections import deque
            #双向队列
            dq = deque() 
            #先遍历一个窗口 
            for i in range(size):
                #去掉比自己先进队列的小于自己的值
                while len(dq) != 0 and num[dq[-1]] < num[i]: 
                     dq.pop()
                dq.append(i)
            #遍历后续数组元素
            for i in range(size, len(num)):
                res.append(num[dq[0]])
                while len(dq) != 0 and dq[0] < (i - size + 1):
                    #弹出窗口移走后的值
                    dq.popleft()
                #加入新的值前，去掉比自己先进队列的小于自己的值  
                while len(dq) != 0 and num[dq[-1]] < num[i]:
                    dq.pop()
                dq.append(i)
            res.append(num[dq[0]])
        return res
```

复杂度分析：

时间复杂度：O(n)，数组长度为n，只遍历一遍数组
空间复杂度：O(m)，窗口长度m，双向队列最长时，将窗口填满

方法二：暴力法（扩展思路）
更简单直观的方式，莫过于遍历两次：

step 1：第一次遍历数组每个位置作为窗口的起点。
step 2：从每个起点开始遍历窗口长度，查找其中的最大值。

```
class Solution:
    def maxInWindows(self , num: List[int], size: int) -> List[int]:
        res = []
        #窗口大于数组长度的时候，返回空
        if size <= len(num) and size != 0:  
            #数组后面要空出窗口大小，避免越界
            for i in range (len(num) - size + 1):
                #寻找每个窗口最大值
                max = 0; 
                for j in range(i, i + size):
                    if num[j] > max:
                        max = num[j]
                res.append(max)
        return res
```

复杂度分析

时间复杂度：O(nm)，其中n为数组长度，m为窗口长度，双层for循环
空间复杂度：O(1)，没有使用额外的辅助空间，暂存的结果res不算入空间开销

### BM46. 最小的K个数

题目主要信息：
对于一个给定无序数组，返回最小的k个元素，顺序任意
k和数组有特殊情况需要单独讨论
方法一：堆排序（推荐使用）
具体做法：

我们只需要用一个数据结构一直维持k个最小的元素就可以了，而优先队列（大根堆）正好可以满足这个条件。

step 1：利用input数组中前k个元素，构建一个大小为k的大顶堆，堆顶为这k个元素的最大值。
step 2：对于后续的元素，依次比较其与堆顶的大小，若是比堆顶小，则堆顶弹出，再将新数加入堆中，直至数组结束，保证堆顶中的k个最小。
step 3：最后将堆顶依次弹出即是最小的k个数。

```
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param input int整型一维数组 
# @param k int整型 
# @return int整型一维数组
#
class Solution:
    def GetLeastNumbers_Solution(self , input: List[int], k: int) -> List[int]:
        res = []
        if len(input) >= k and k != 0:
            import heapq
            #小根堆，每次输入要乘-1 
            pq = []  
            for i in range(k):
                #构建一个k个大小的堆
                heapq.heappush(pq, (-1 * input[i])) 
            for i in range(k, len(input)):
                #较小元素入堆
                if (-1 * pq[0]) > input[i]:   
                     heapq.heapreplace(pq, (-1 * input[i]))
            #堆中元素取出入数组
            for i in range(k): 
                res.append(-1 * pq[0])
                heapq.heappop(pq)
        return res
```

复杂度分析：

时间复杂度：O(nlog~2~k)，构建和维护大小为k的堆，需要log~2~k，加上遍历整个数组
空间复杂度：O(k)，堆空间为k个元素

方法二：sort排序法（扩展思路）
具体做法：

其实还有一种更简单的思路，只要对整个数组进行了一次排序，那最小的k个元素不就手到擒来了嘛。

step 1：优先判断k为0或者输入数组长度为0的特殊情况。
step 2：使用sort函数对整个数组排序。
step 3：遍历排序后的数组前k个元素即可获取最小的k个。

```
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param input int整型一维数组 
# @param k int整型 
# @return int整型一维数组
#
class Solution:
    def GetLeastNumbers_Solution(self , input: List[int], k: int) -> List[int]:
        list=[]
        #排除特殊情况
        if k == 0 or len(input) == 0:
            return list
        else:
            #排序
            input.sort()
            #输出前k小
            return input[:k]
```

复杂度分析：

时间复杂度：O(nlog~2~n)，sort函数属于优化后的快速排序，复杂度为O(nlog~2~n)
空间复杂度：O(1)，无额外辅助空间使用

### BM47. 寻找第K大

题目主要信息：
利用快速排序的思想寻找数组中的第k大元素
有重复数字，不用去重，也不用管稳定性与否
方法：快排+二分法（推荐使用）
具体做法：

快速排序：每次移动，可以找到一个标杆元素，然后将大于它的移到左边，小于它的移到右边。然后分别对左边和右边进行排序，不断划分左右子段，直到整个数组有序。放到这道题中，如果标杆元素左边刚好有K-1个比它大的，那么该元素就是第K大，如果它左边的元素比K - 1多，说明第K大在其左边，直接二分，不用管标杆元素右边，同理如果它左边的元素比K-1少，那第K大在其右边，左边不用管。

step 1：进行一次快排，大元素在左，小元素在右，得到的中轴p点。
step 2：如果 p - low + 1 = k ，那么p点就是第K大。
step 3：如果 p - low + 1 > k，则第k大的元素在左半段，更新high = p - 1，执行step 1。
step 4：如果 p - low + 1 < k，则第k大的元素在右半段，更新low = p + 1, 且 k = k - (p - low + 1)，排除掉前面部分更大的元素，再执行step 1.

```
class Solution:
    #常规的快排划分，但这次是大数在左
    def partition(self, a: List[int], low: int, high: int) -> int:
        temp = a[low]
        while low < high:
            #小于标杆的在右
            while low < high and a[high] <= temp:
                high = high - 1
            if low == high:
                break
            else:
                a[low] = a[high]
            #大于标杆的在左
            while low < high and a[low] >= temp:
                low = low + 1
            if low == high:
                break
            else:
                a[high] = a[low]
        a[low] = temp
        return low

    def quicksort(self, a: List[int], low: int, high: int, K: int) -> int:
        #先进行一轮划分，p下标左边的都比它大，下标右边都比它小
        p = self.partition(a, low, high)
        #若p刚好是第K个点，则找到 
        if K == p - low + 1:  
            return a[p]
        #从头到p超过k个数组，则目标在左边
        elif p - low + 1 > K:  
            #递归左边
            return self.quicksort(a, low, p - 1, K)  
        else:  
            #否则，在右边,递归右边,但是需要减去左边更大的数字的数量
            return self.quicksort(a, p + 1, high, K - (p - low + 1))  

    def findKth(self , a: List[int], n: int, K: int) -> int:
        return self.quicksort(a, 0, n - 1, K)
```

### BM48. 数据流中的中位数

题目主要信息：
寻找数据的中位数
数据量在不断输入增长
方法一：插入排序法（推荐使用）
具体做法：

传统的寻找中位数的方法便是排序之后，取中间值或者中间两位的平均即可，但是因为数组在不断增长， 每增长一位便排一次，很浪费时间，于是可以考虑在增加数据的同时将其有序化，这个过程就让我们想到了插入排序：遍历后续数组每个元素时将它插入前面排好序的部分的相应位置。

step 1：用一数组存储输入的数据流。
step 2：Insert函数在插入的同时，遍历之前存储在数组中的数据，按照递增顺序依次插入，如此一来，加入的数据流便是有序的。
step 3：GetMedian函数可以根据下标直接访问中位数，分为数组为奇数个元素和偶数个元素两种情况。记得需要类型转换为double。

```
# -*- coding:utf-8 -*-
class Solution:
    def __init__(self):
        self.val = []
    def Insert(self, num):
        if len(self.val) == 0:
            #val中没有数据，直接加入
            self.val.append(num) 
        #val中有数据，需要插入排序
        else: 
            i = 0
            #遍历找到插入点
            while i < len(self.val):  
                if num <= self.val[i]:
                    break
                i = i + 1
            #插入相应位置
            self.val.insert(i, num) 
    def GetMedian(self):
        n = len(self.val)
        #奇数个数字
        if n % 2 == 1: 
            #类型转换
            return self.val[n // 2] 
        #偶数个数字
        else: 
            return (self.val[n // 2] + self.val[n // 2 - 1]) / 2.0
```

复杂度分析：

时间复杂度：Insert函数O(n)，不管遍历还是插入都是O(n)，GetMedian函数O(1)，直接访问
空间复杂度：O(n)，记录输入流的数组

方法二：堆排序（扩展思路）
具体做法：

除了插入排序，我们换种思路，因为插入排序每次要遍历整个已经有的数组，很浪费时间，有没有什么可以找到插入位置时能够更方便。这是我们想到了堆排序，因此可以使用优先队列。

step 1：中位数为一个数列的中间两个或一个，也即中位数将数列分成了较小的部分和较大的部分。
step 2：因此我们可以维护两个堆，分别是大顶堆min，用于存储较小的值，其中顶部最大；小顶堆max，用于存储较小的值，其中顶部最小，则中位数只会在两个堆的堆顶出现。
step 3：我们可以约定奇数个元素时取大顶堆的顶部值，偶数个元素时取两堆顶的平均值，则可以发现两个堆的数据长度要么是相等的，要么奇数时大顶堆会多一个。
step 4：每次输入的数据流先进入大顶堆排序，然后将小顶堆的最大值弹入大顶堆中，完成整个的排序。
step 5：但是因为大顶堆的数据不可能会比小顶堆少一个，因此需要再比较二者的长度，若是小顶堆长度小于大顶堆，需要从大顶堆中弹出最小值到大顶堆中进行平衡。

```
# -*- coding:utf-8 -*-
import heapq
class Solution:
    def __init__(self):
        #小顶堆，元素数值都比大顶堆大
        self.max = [] 
        #大顶堆，元素数值较小，加入元素要乘-1才能实现大顶堆，取出时也要乘-1还原
        self.min = [] 
    def Insert(self, num):
        #先加入较小部分
        heapq.heappush(self.min, (-1 * num)) 
        #将较小部分的最大值取出，送入到较大部分
        heapq.heappush(self.max, -1 * self.min[0]) 
        heapq.heappop(self.min)
        #平衡两个堆的数量
        if len(self.min) < len(self.max):  
            heapq.heappush(self.min, -1 * self.max[0])
            heapq.heappop(self.max)
    def GetMedian(self):
        #奇数个
        if len(self.min) > len(self.max): 
            return self.min[0] * -1.0
        else:
            #偶数个
            return (-1 * self.min[0]  + self.max[0]) / 2 
```

复杂度分析

时间复杂度：Insert函数O(log~2~n)，维护堆的复杂度，GetMedian函数O(1)，直接访问
空间复杂度：O(n)，两个堆的空间，虽是两个，但是一个堆最多n/2

### BM49. 表达式求值

题目的主要信息：
写一个支持+ - *三种符号的运算器，其中优先级+ - 是一级，*更高一级
支持括号运算
方法：栈 + 递归（推荐使用）
具体做法：

对于上述两个要求，我们要考虑的是两点，一是处理运算优先级的问题，二是处理括号的问题。

优先级处理我们可以借助栈，当遇到符号的时候如果是+，正常入栈，如果是-，则将其相反数入栈，如果是*，则将栈中内容弹出与后一个元素相乘再入栈，最后将栈中所有元素相加即可。
括号的处理我们可以借助递归，将括号内的运算视为一个子问题，由此来简化。

```
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 返回表达式的值
# @param s string字符串 待计算的表达式
# @return int整型
#
class Solution:
    def solve(self , s ):
        s = s.strip()
        stack = []
        res = 0
        num = 0
        sign = '+' 
        index = 0
        while index < len(s):
            if s[index] == ' ':
                index += 1
                continue
            # 遇到左括号
            if s[index] == '(': 
                end = index + 1
                lens = 1
                while lens > 0: 
                    if s[end] == '(':
                        lens += 1
                    if s[end] == ')':
                        lens -= 1
                    end += 1
                #将括号视为子问题进入递归
                num = self.solve(s[index + 1: end - 1]) 
                index = end - 1
                continue
            #字符数字转换成int数字
            if '0' <= s[index] <= '9':
                num = num * 10 + int(s[index])
            #根据符号运算
            if not '0' <= s[index] <= '9' or index == len(s) - 1:
                #加
                if sign == '+': 
                    stack.append(num)
                #减，加相反数
                elif sign == '-': 
                    stack.append(-1 * num)
                #乘优先计算
                elif sign == '*': 
                    stack.append(stack.pop() * num) 
                num = 0
                sign = s[index]
            index += 1
        #栈中元素相加
        while stack: 
            res += stack.pop()
        return res
```

复杂度分析：

时间复杂度：O(n)，n为字符串长度，相当于遍历一遍字符串全部元素
空间复杂度：O(n)，辅助栈和递归栈的空间

## 05哈希

### BM50. 两数之和

题目主要信息:
题目给出的是一个数组和一个目标值，需要我们在数组中找到两个加起来等于目标值的数组元素的下标
下标按升序排列，从1开始
方法：哈希表（推荐使用）
具体做法：

我们能想到最直观的解法，可能就是两层遍历，将数组所有的二元组合枚举一遍，看看是否是和为目标值，但是这样太费时间了，既然加法这么复杂，我们是不是可以尝试一下减法：对于数组中出现的一个数a，如果目标值减去a的值已经出现过了，那这不就是我们要找的一对元组吗？这种时候，快速找到已经出现过的某个值，可以考虑使用哈希表，即STL提供的unordered_map。

step 1：使用unordered_map构建一个哈希表，其中key值为遍历数组过程中出现过的值，value值为其相应的下标，因为我们最终要返回的是下标。
step 2：遍历数组每个元素，如果目标值减去该元素的结果在哈希表中存在，说明我们先前遍历的时候它出现过，根据记录的下标，就可以得到结果。
step 3：如果相减后的结果没有在哈希表中，说明先前遍历的元素中没有它对应的另一个值，那我们将它加入哈希表，等待后续它匹配的那个值出现即可。
step 4：需要注意最后的结果是下标值加1.

```
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param numbers int整型一维数组 
# @param target int整型 
# @return int整型一维数组
#
class Solution:
    def twoSum(self , numbers: List[int], target: int) -> List[int]:
        res = []
        #创建哈希表,两元组分别表示值、下标
        hash = dict() 
        #在哈希表中查找target-numbers[i]
        for i in range(len(numbers)) :
            temp = target - numbers[i]
            #若是没找到，将此信息计入哈希表
            if temp not in hash: 
                hash[numbers[i]] = i
            else:
                #哈希表中记录的是之前的数字，所以该索引比当前小
                res.append(hash[temp] + 1) 
                res.append(i + 1)
                break
        return res
```

复杂度分析：

时间复杂度：O(n)，仅仅遍历数组一次，每次查询哈希表都是O(1)
空间复杂度：O(n)，最坏情况下找到数组结尾才找到，其他都加入哈希表，因此哈希表最长为n−1的长度

### BM51. 数组中出现次数超过一半的数字

题目主要信息:
题目给出一个长度为n的数组，其中有一个数字出现次数超过了数组长度的一半，需要我们找出这个数字
输入数组非空，保证有解，这样就不用考虑特殊情况
方法：哈希表（推荐使用）
具体做法：

首先我们分析一下，数组某个元素出现次数超过了数组长度的一半，那它肯定出现最多，而且只要超过了一半，其他数字不可能超过一半了，必定是它。

如果给定的数组是有序的，那我们在连续的相同数字中找到出现次数最多即可，但是题目没有要求有序，一种方法是对数组排序后解决，但是时间复杂度就上去了。那我们可以考虑遍历一次数组统计各个元素出现的次数，找到出现次数大于数组长度一半的那个数字。

step 1：用unordered_map构建一个哈希表，统计数组元素各自出现了多少次，即key值为数组元素，value值为其出现次数。
step 2：遍历数组，每遇到一个元素就把哈希表中相应key值的value值加1，用来统计出现次数。
step 3：本来可以统计完了之后统一遍历哈希表找到频次大于数组长度一半的key值，但是根据我们上面加粗的点，只要它出现超过了一半，不管后面还有没有，必定就是这个元素了，因此每次统计后，我们都可以检查value值是否大于数组长度的一半，如果大于则找到了。

```
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param numbers int整型一维数组 
# @return int整型
#
class Solution:
    def MoreThanHalfNum_Solution(self , numbers: List[int]) -> int:
        #无序哈希表统计每个数字出现的次数
        mp = dict() 
        #遍历数组
        for i in range(len(numbers)): 
            if numbers[i] in mp:
                #哈希表中相应数字个数加1
                mp[numbers[i]] += 1  
            else:
                mp[numbers[i]] = 1
            #一旦有个数大于长度一半的情况即可返回
            if mp[numbers[i]] > (int)(len(numbers) / 2): 
                return numbers[i]
        return 0
```

复杂度分析：

时间复杂度：O(n)，遍历一次数组，哈希表每次操作的复杂度都是O(1)
空间复杂度：O(n)，最坏情况下n/2+1个相同的数字，其他都不同，则共有n/2个不同的数字，哈希表长度需要达n/2

### BM52. 数组中只出现一次的两个数字

题目主要信息：
一个长度为的数字，除了两个数字只出现1次，其余数字都出现2次
要找到这两次只出现一次的数字，还要以非降序输出
方法一：哈希表(推荐使用)
具体做法：

既然有两个数字只出现了一次，我们就统计每个数字的出现次数。

step 1：遍历数组，用哈希表统计每个数字出现的频率。
step 2：然后再遍历一次数组，对比哈希表，找到出现频率为1的两个数字。
step 3：最后整理次序输出。

```
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param array int整型一维数组 
# @return int整型一维数组
#
class Solution:
    def FindNumsAppearOnce(self , array: List[int]) -> List[int]:
        mp = dict()
        res = list()
        #遍历数组
        for i in range(len(array)): 
            #统计每个数出现的频率
            if array[i] in mp:
                mp[array[i]] += 1 
            else:
                mp[array[i]] = 1
        #再次遍历数组
        for i in range(len(array)): 
            #找到频率为1的两个数
            if mp[array[i]] == 1: 
                res.append(array[i])
        #整理次序
        res.sort(reverse=False)
        return res
```

复杂度分析：

时间复杂度：O(n)，其中nnn为数组长度，两次单独的遍历数组每个元素
空间复杂度：O(n)，哈希表的长度应该为(n−2)/2

方法二：异或运算（扩展思路）
具体做法：

异或运算满足交换率，且相同的数字作异或会被抵消掉，比如：a⊕b⊕c⊕b⊕c=a，且任何数字与0异或还是原数字，放到这个题目里面所有数字异或运算就会得到a⊕b，也即得到了两个只出现一次的数字的异或和。

但是我们是要将其分开得到结果的，可以考虑将数组分成两部分，一部分为a⊕d⊕c⊕d⊕c=a，另一部分为b⊕x⊕y⊕x⊕y=a的样式，怎么划分才能让a与b完全分开，而另外的也能刚好成对在一个组呢？这是我们需要考虑的问题。

step 1：遍历整个数组，将每个元素逐个异或运算，得到。
step 2：我们可以考虑位运算：的结果中如果二进制第一位是1，则说明a与b的第一位二进制不相同，否则则是相同的，从结果二进制的最高位开始遍历，总能找到二进制位为1的情况，因为两个数字不相同，我们就以这一位是否为1来划分上述的两个数组，相同的数字自然会被划分到另一边，而a与b也会刚好被分开。
step 3：遍历数组对分开的数组单独作异或连算。
step 4：最后整理次序输出。

```
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param array int整型一维数组 
# @return int整型一维数组
#
class Solution:
    def FindNumsAppearOnce(self , array: List[int]) -> List[int]:
        res = [0, 0]
        temp = 0
        #遍历数组得到a^b
        for i in range(len(array)): 
            temp ^= array[i]
        k = 1
        #找到两个数不相同的第一位
        while k & temp == 0: 
            k <<= 1
        for i in range(len(array)):
            #遍历数组，对每个数分类
            if k & array[i] == 0 :
                res[0] ^= array[i]
            else:
                res[1] ^= array[i]
        #整理次序
        res.sort(reverse=False)
        return res
```

复杂度分析：

时间复杂度：O(n)，遍历两次数组，找到两个数不相同的第一位循环为常数次
空间复杂度：O(1)，常数级变量使用，无额外辅助空间

### BM53. 缺失的第一个正整数

题目主要信息:
题目给定一个无序整型数组，没有重复元素，可能有负数或零，需要找出其中没有出现的最小正整数
方法一：哈希表（推荐使用）
具体做法：

n个长度的数组，没有重复，则如果数组填满了1～n，那么缺失n+1，如果数组填不满1～n，那么缺失的就是1～n中的数字。对于这种快速查询某个元素是否出现过的问题，还是可以使用哈希表。

step 1：使用unordered_map构建一个哈希表，用于记录数组中出现的数字。
step 2：从1开始，遍历到n，查询哈希表中是否有这个数字，如果没有，说明它就是数组缺失的第一个正整数，即找到。
step 3：如果遍历到最后都在哈希表中出现过了，那缺失的就是n+1.

```
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param nums int整型一维数组 
# @return int整型
#
class Solution:
    def minNumberDisappeared(self , nums: List[int]) -> int:
        n = len(nums)
        mp = dict()
        #哈希表记录数组中出现的每个数字
        for i in range(n): 
            if nums[i] in mp:
                mp[nums[i]] += 1
            else:
                mp[nums[i]] = 1
        res = 1
        #从1开始找到哈希表中第一个没有出现的正整数
        while res in mp: 
            res += 1
        return res
```

复杂度分析：

时间复杂度：O(n)，第一次遍历数组，为O(n)，第二次最坏从1遍历到n，为O(n)
空间复杂度：O(n)，哈希表记录n个不重复的元素，长度为n

方法二：原地哈希（扩展思路）
前面提到了数组要么缺失1～n中的某个数字，要么缺失n+1。

step 1：我们可以先遍历数组将所有的负数都修改成n+1。
step 2：然后再遍历数组，每当遇到一个元素绝对值不超过n时，则表示这个元素是1～n中出现的元素，我们可以将这个数值对应的下标里的元素改成负数，相当于每个出现过的正整数的下标都指向一个负数，这就是类似哈希表的实现原理的操作。
step 3：最后遍历数组的时候碰到的第一个非负数的下标就是没有出现的第一个正整数，因为它在之前的过程中没有被修改，说明它这个下标的正整数没有出现过。

```
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param nums int整型一维数组 
# @return int整型
#
class Solution:
    def minNumberDisappeared(self , nums: List[int]) -> int:
        n = len(nums)
        #遍历数组
        for i in range(n): 
            #数全部记为n+1
            if nums[i] <= 0: 
                nums[i] = n + 1
        for i in range(n):
            #对于1-n中的数字
            if abs(nums[i]) <= n: 
                #这个数字的下标标记为负数
                nums[abs(nums[i]) - 1] = -1 * abs(nums[abs(nums[i]) - 1]) 
        for i in range(n):
            #找到第一个元素不为负数的下标
            if nums[i] > 0: 
                return i + 1
        return n + 1
```

复杂度分析：

时间复杂度：O(n)，多次遍历数组，都是单层循环
空间复杂度：O(1)，原地哈希，以索引为指向，没有额外空间

### BM54. 三数之和

题目主要信息:
给定一个长度为n的数组，要找出其中所有满足相加等于0的三元组，即数组中所有三个相加为0的数集
三元组内部必须非降序排列，且三元组不能有重复
哈希表（推荐使用）
具体做法：

step 1：排除边界特殊情况。
step 2：既然三元组内部要求非降序排列，那我们先得把这个无序的数组搞有序了，使用sort函数优先对其排序。
step 3：得到有序数组后，遍历该数组，对于每个遍历到的元素假设它是三元组中最小的一个，那么另外两个一定在后面。
step 4：需要三个数相加为0，则另外两个数相加应该为上述第一个数的相反数，我们可以利用双指针在剩余的子数组中找有没有这样的数对。双指针指向剩余子数组的首尾，如果二者相加为目标值，那么可以记录，而且二者中间的数字相加可能还会有；如果二者相加大于目标值，说明右指针太大了，那就将其左移缩小，相反如果二者相加小于目标值，说明左指针太小了，将其右移扩大，直到两指针相遇，剩余子数组找完了。
注：对于三个数字都要判断是否相邻有重复的情况，要去重。

```
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param num int整型一维数组 
# @return int整型二维数组
#
class Solution:
    def threeSum(self , num: List[int]) -> List[List[int]]:
        res = list(list())
        n = len(num)
        #不够三元组
        if n < 3: 
            return res
        #排序
        num.sort() 
        for i in range(n - 2):
            if i != 0 and num[i] == num[i - 1]:
                continue
            #后续的收尾双指针
            left = i + 1 
            right = n - 1
            #设置当前数的负值为目标
            target = -num[i] 
            while left < right:
                #双指针指向的二值相加为目标，则可以与num[i]组成0
                if num[left] + num[right] == target: 
                    res.append([num[i], num[left], num[right]])
                    while left + 1 < right and num[left] == num[left + 1]:
                        #去重
                        left += 1 
                    while right - 1 > left and num[right] == num[right - 1]:
                        #去重
                        right -= 1 
                    #双指针向中间收缩
                    left += 1 
                    right -= 1
                #双指针指向的二值相加大于目标，右指针向左
                elif num[left] + num[right] > target: 
                    right -= 1
                #双指针指向的二值相加小于目标，左指针向右
                else: 
                    left += 1 
        return res
```

复杂度分析：

时间复杂度：O(n^2^)，排序的复杂度为(nlog~2~n)，查找三元组的复杂度为O(n^2)
空间复杂度：O(1)，res属于必要空间，不属于额外空间，无其他辅助空间

## 06递归/回溯

### BM55. 没有重复项数字的全排列

题目主要信息:
给定一个数组，求这组数字的全排列
数组无重复元素
以数字在数组中的位置靠前为优先级，按字典序排列输出
递归+回溯（推荐使用）
具体做法：

全排列就是对数组元素交换位置，使每一种排列都可能出现。因为题目要求按照字典序排列输出，那毫无疑问第一个排列就是数组的升序排列，它的字典序最小，后续每个元素与它后面的元素交换一次位置就是一种排列情况，但是如果要保持原来的位置不变，那就不应该从它后面的元素开始交换而是从自己开始交换才能保证原来的位置不变，不会漏情况。

step 1：如何保证每个元素能和从自己开始后的每个元素都交换位置，这种时候我们可以考虑递归。为什么可以使用递归？我们可以看数组[1,2,3,4],如果遍历经过一个元素2以后，那就相当于我们确定了数组到该元素为止的前半部分，前半部分1和2的位置都不用变了，只需要对3，4进行排列，这对于后半部分而言同样是一个全排列，同样要对从每个元素开始往后交换位置，因此后面部分就是一个子问题。那我们考虑递归的几个条件：

终止条件： 要交换位置的下标到了数组末尾，没有可交换的了，那这就构成了一个排列情况，可以加入输出数组。
返回值： 每一级的子问题应该把什么东西传递给父问题呢，这个题中我们是交换数组元素位置，前面已经确定好位置的元素就是我们返还给父问题的结果，后续递归下去会逐渐把整个数组位置都确定，形成一种排列情况。
本级任务： 每一级需要做的就是遍历从它开始的后续元素，每一级就与它交换一次位置。
step 2：如果只是使用递归，我们会发现，上例中的1与3交换位置以后，如果2再与4交换位置的时候，我们只能得到3412这种排列，无法得到1432这种情况。这是因为遍历的时候1与3交换位置在2与4交换位置前面，递归过程中就默认将后者看成了前者的子问题，但是其实我们1与3没有交换位置的情况都没有结束，相当于上述图示中只进行了第一个分支。因此我们用到了回溯。处理完1与3交换位置的子问题以后，我们再将其交换回原来的情况，相当于上述图示回到了父节点，那后续完整的情况交换我们也能得到。

```
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param num int整型一维数组 
# @return int整型二维数组
#
class Solution:
    def recursion(self, res:List[List[int]], num:List[int], index:int):
        #分枝进入结尾，找到一种排列
        if index == len(num) - 1:  
            res.append(num)
        else:
            #遍历后续的元素
            for i in range(index, len(num)): 
                #交换二者
                temp = num[i]
                num[i] = num[index]
                num[index] = temp
                #继续往后找
                self.recursion(res, num, index + 1) 
                #回溯
                temp = num[i]
                num[i] = num[index]
                num[index] = temp

    def permute(self , num: List[int]) -> List[List[int]]:
        #先按字典序排序
        num.sort() 
        res = list(list())
        #递归获取
        self.recursion(res, num, 0) 
        return res
```

复杂度分析：

时间复杂度：O(n∗n!)，n个元素的数组进行全排列的递归，每次递归都要遍历数组
空间复杂度：O(n)，递归栈的最大深度为数组长度n，res属于返回必要空间

### BM56. 有重复项数字的全排列

题目主要信息:
给定一组可能有重复数字的数组，输出该数组的全部排列
输出结果按照字典序升序排列
递归+回溯（推荐使用）
具体做法：

这道题类似没有重复项数字的全排列，但是因为交换位置可能会出现重复交换的情况，出现的结果需要去重，因此不便于使用交换位置的方法。

step 1：我们就使用临时变量去组装一个排列的情况：每当我们选取一个数组元素以后，就确定了其位置，相当于对数组中剩下的元素进行全排列添加在该元素后面，给剩余部分进行全排列就是一个子问题，因此可以使用递归。

终止条件： 临时数组中选取了n个元素，已经形成了一种排列情况了，可以将其加入输出数组中。
返回值： 每一层给上一层返回的就是本层级在临时数组中添加的元素，递归到末尾的时候就能添加全部元素。
本级任务： 每一级都需要选择一个元素加入到临时数组末尾（遍历数组选择）。首先已经加入的元素不能再次加入了，因此我们需要使用额外的vis数组用于记录哪些位置的数字被加入了。同时为了去除重复元素的影响，如果当前的元素num[i]与同一层的前一个元素num[i-1]相同且num[i-1]已经用过了，也不需要将其纳入。
step 2：回溯的思想也与没有重复项数字的全排列类似，对于数组[1,2,2,3]，如果事先在临时数组中加入了1，后续子问题只能是[2,2,3]的全排列接在1后面，对于2开头的分支达不到，因此也需要回溯：将临时数组刚刚加入的数字pop掉，同时vis修改为没有加入，这样才能正常进入别的分支。

```
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param num int整型一维数组 
# @return int整型二维数组
#
class Solution:
    def recursion(self, res:List[List[int]], num:List[int], temp:List[int], vis:List[int]):
        #临时数组满了加入输出
        if len(temp) == len(num):
            res.append(temp.copy())
            return
        #遍历所有元素选取一个加入
        for i in range(len(num)):  
            #如果该元素已经被加入了则不需要再加入了
            if vis[i]==1: 
                continue
            if i > 0 and num[i - 1] == num[i] and not vis[i - 1]:
                #当前的元素num[i]与同一层的前一个元素num[i-1]相同且num[i-1]已经用过了
                continue  
            #标记为使用过
            vis[i] = 1  
            #加入数组
            temp.append(num[i]) 
            self.recursion(res, num, temp, vis)
            #回溯
            vis[i] = 0 
            temp.pop()
            
    def permuteUnique(self , num: List[int]) -> List[List[int]]:
        #先按字典序排序
        num.sort() 
        #标记每个位置的元素是否被使用过
        vis = [0]*len(num) 
        res = list(list())
        temp = list() 
        # 递归获取
        self.recursion(res, num, temp, vis) 
        return res
```

复杂度分析：

时间复杂度：O(n∗n!)，全排列的全部情况为n!，每次递归过程都是遍历数组查找元素，这里是O(n)
空间复杂度：O(n)，递归栈的最大深度为数组长度n，临时数组temp的空间也为O(n)，res属于返回必要空间

### BM57. 岛屿数量

题目主要信息：
给一个01矩阵，1代表是陆地，0代表海洋，如果两个1相邻，则这两个1属于同一个岛
只考虑上下左右为相邻
判断岛屿的个数
方法一：dfs（推荐使用）
具体做法：

矩阵中多处聚集着1，要想统计1聚集的堆数而不重复统计，那我们可以考虑每次找到一堆相邻的1，就将其全部改成0，而将所有相邻的1改成0的步骤又可以使用深度优先搜索（dfs），因此具体做法如下：

step 1：优先判断空矩阵等情况。
step 2：从上到下从左到右遍历矩阵每一个位置的元素，如果该元素值为1，统计岛屿数量。
step 3：使用dfs将遍历矩阵遇到的1以及相邻的1全部置为0。
至于dfs具体怎么操作，我们接着看。当我们遇到矩阵的某个元素为1时，首先将其置为了0，然后查看与它相邻的上下左右四个方向，如果这四个方向相邻元素为1，则进入该元素，进入该元素之后我们发现又回到了刚刚的子问题，又是把这一片相邻区域的1全部置为0，因此可以用递归实现。

终止条件： 进入某个元素修改其值为0后，遍历四个方向发现周围都没有1，那就不用继续递归，返回即可，或者递归到矩阵边界也同样可以结束。
返回值： 每一级的子问题就是把修改后的矩阵返回，因为其是函数引用，也不用管。
本级任务： 对于每一级任务就是将该位置的元素置为0，然后查询与之相邻的四个方向，看看能不能进入子问题。

```
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 判断岛屿数量
# @param grid char字符型二维数组 
# @return int整型
#
class Solution:
    #深度优先遍历与i，j相邻的所有1
    def dfs(self, grid:List[List[chr]], i:int, j:int) : 
        n = len(grid)
        m = len(grid[0])
        #置为0
        grid[i][j] = '0' 
        #后续四个方向遍历
        if i - 1 >= 0 and grid[i - 1][j] == '1':
            self.dfs(grid, i - 1, j)
        if i + 1 < n and grid[i + 1][j] == '1':
            self.dfs(grid, i + 1, j)
        if j - 1 >= 0 and grid[i][j - 1] == '1':
            self.dfs(grid, i, j - 1)
        if j + 1 < m and grid[i][j + 1] == '1':
            self.dfs(grid, i, j + 1)
            
    def solve(self , grid: List[List[str]]) -> int:
        n = len(grid)
        #空矩阵的情况
        if  n == 0: 
            return 0
        m = len(grid[0])
        #记录岛屿数
        count = 0 
        #遍历矩阵
        for i in range(n): 
            for j in range(m):
                #遍历到1的情况
                if grid[i][j] == '1': 
                    #计数
                    count += 1 
                    #将与这个1相邻的所有1置为0
                    self.dfs(grid, i, j) 
        return count
```

复杂度分析：

时间复杂度：O(nm)，其中m、n为矩阵的长和宽，需要遍历整个矩阵，每次dfs搜索需要经过每个值为1的元素，但是最坏情况下也只是将整个矩阵变成0，因此相当于最坏遍历矩阵2次
空间复杂度：O(nm)，最坏情况下整个矩阵都是1，递归栈深度为mn

方法二：bfs（扩展思路）
具体做法：

统计岛屿的方法可以和方法一同样，但是将相邻的1全部置为0的方法还可以使用bfs。

step 1：优先判断空矩阵等情况。
step 2：从上到下从左到右遍历矩阵每一个位置的元素，如果该元素值为1，统计岛屿数量。
step 3：使用bfs将遍历矩阵遇到的1以及相邻的1全部置为0：利用两个队列辅助（C++可以使用pair），每次队列进入第一个进入的1，然后遍历队列，依次探讨队首的四个方向，是否符合，如果符合则置为0，且位置坐标加入队列，继续遍历，直到队列为空。 

```
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 判断岛屿数量
# @param grid char字符型二维数组 
# @return int整型
#
from queue import Queue,LifoQueue,PriorityQueue

class Solution:
    def solve(self , grid: List[List[str]]) -> int:
        n = len(grid)
        #空矩阵的情况
        if n == 0:  
            return 0
        m = len(grid[0])
        #记录岛屿数
        count = 0 
        #遍历矩阵
        for i in range(n): 
            for j in range(m):
                #遇到1要将这个1及与其相邻的1都置为0
                if grid[i][j] == '1':  
                    #岛屿数增加
                    count += 1 
                    grid[i][j] = '0'
                    #记录后续bfs的坐标
                    q = Queue() 
                    q.put([i, j])
                    #bfs
                    while not q.empty(): 
                        temp = q.get()
                        row = temp[0]
                        col = temp[1]
                        #四个方向依次检查：不越界且为1
                        if row - 1 >= 0 and grid[row - 1][col] == '1':
                            q.put([row - 1, col])
                            grid[row - 1][col] = '0'
                        if row + 1 < n and grid[row + 1][col] == '1':
                            q.put([row + 1, col])
                            grid[row + 1][col] = '0'
                        if col - 1 >= 0 and grid[row][col - 1] == '1':
                            q.put([row, col - 1])
                            grid[row][col - 1] = '0'
                        if col + 1 < m and grid[row][col + 1] == '1':
                            q.put([row, col + 1])
                            grid[row][col + 1] = '0'
        return count
```

复杂度分析：

时间复杂度：O(nm)，其中m、n为矩阵的长和宽，需要遍历整个矩阵，每次bfs搜索需要经过每个值为1的元素，但是最坏情况下也只是将整个矩阵变成0，因此相当于最坏遍历矩阵2次
空间复杂度：(min(n,m))，bfs最坏情况队列大小为长和宽的较小值

### BM58. 字符串的排列

题目主要信息:
给定一个长度为n的字符串，求其中所有字符的全排列
字符串中可能有重复字符，打印顺序任意
字符串中只包含大小写字母
方法：递归+回溯（推荐使用）
具体做法：

都是求元素的全排列，字符串与数组没有区别，一个是数字全排列，一个是字符全排列，因此大致思路与有重复数字的全排列类似，只是这道题输出顺序没有要求。但是为了便于去掉重复情况，我们还是应该参照这道数组全排列，优先按照字典序排序，因此排序后重复的字符就会相邻，后续递归找起来也很方便。

step 1：依据数组的全排列，使用临时变量去组装一个排列的情况：每当我们选取一个字符以后，就确定了其位置，相当于对字符串中剩下的元素进行全排列添加在该元素后面，给剩余部分进行全排列就是一个子问题，因此可以使用递归。

终止条件： 临时字符串中选取了n个元素，已经形成了一种排列情况了，可以将其加入输出数组中。
返回值： 每一层给上一层返回的就是本层级在临时字符串中添加的元素，递归到末尾的时候就能添加全部元素。
本级任务： 每一级都需要选择一个元素加入到临时字符串末尾（遍历原字符串选择）。首先已经加入的元素不能再次加入了，因此我们需要使用额外的vis数组用于记录哪些位置的字符被加入了。同时为了去除重复元素的影响，如果当前的元素str[i]与同一层的前一个元素str[i-1]相同且str[i-1]已经用过了，也不需要将其纳入。
step 2：递归过程也需要回溯，比如说对于字符串“abbc”，如果事先在临时字符串中加入了a，后续子问题只能是"bbc"的全排列接在a后面，对于b开头的分支达不到，因此也需要回溯：将临时字符串刚刚加入的字符去掉，同时vis修改为没有加入，这样才能正常进入别的分支。

```
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param str string字符串 
# @return string字符串一维数组
#
class Solution:
    def recursion(self, res:List[str], string:str, temp:str, vis:List[int]):
        #临时字符串满了加入输出
        if len(temp) == len(string): 
            res.append(temp)
            return
        #遍历所有元素选取一个加入
        for i in range(len(string)): 
            #如果该元素已经被加入了则不需要再加入了
            if vis[i]==1: 
                continue
            if i > 0 and string[i - 1] == string[i] and not vis[i - 1]:
                #当前的元素str[i]与同一层的前一个元素str[i-1]相同且str[i-1]已经用过了
                continue 
            #标记为使用过
            vis[i] = 1  
            #加入临时字符串
            temp += string[i] 
            self.recursion(res, string, temp, vis)
            #回溯
            vis[i] = 0 
            temp = temp[:-1]
            
    def Permutation(self , str: str) -> List[str]:
        #先按字典序排序，使重复字符串相邻
        str ="".join((lambda x:(x.sort(),x)[1])(list(str)))
        #标记每个位置的字符是否被使用过
        vis = [0]*len(str) 
        res = []
        temp = ""
        #递归获取
        self.recursion(res, str, temp, vis) 
        return res
```

复杂度分析：

时间复杂度：O(n∗n!)，全排列的全部情况为n!，每次递归过程都是遍历字符串查找元素，这里是O(n)
空间复杂度：O(n)，递归栈的最大深度为字符串长度n，临时字符串temp的空间也为O(n)，res属于返回必要空间

### BM59. N皇后问题

题目主要信息:
在一个的棋盘上要摆放个皇后，求摆的方案数，不同位置就是不同方案数
摆放要求：任何两个皇后不同行，不同列也不在同一条斜线上
方法：递归（推荐使用）
具体做法：

n个皇后，不同行不同列，那么肯定棋盘每行都会有一个皇后，每列都会有一个皇后。

step 1：对于第一行，皇后可能出现在该行的任意一列，我们用一个数组pos记录皇后出现的位置，下标为行号，元素值为列号。

step 2：如果皇后出现在第一列，那么第一行的皇后位置就确定了，相当于在剩余的n-1行中找n-1个皇后的位置，这就是一个子问题，因此使用递归。

终止条件： 当最后一行都被选择了位置，说明n个皇后位置齐了，增加一种方案数返回。
返回值： 每一级要将选中的位置及方案数返回。
本级任务： 每一级其实就是在该行选择一列作为该行皇后的位置，遍历所有的列选择一个符合条件的位置加入数组，然后进入下一级。
step 3：每个子问题检查是否符合条件，我们可以对比所有已经记录的行，对其记录的列号查看与当前行列号的关系：即是否同行、同列或是同一对角线。

```
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param n int整型 the n
# @return int整型
#
class Solution:
    #判断皇后是否符合条件
    def isValid(self, pos: List[int], row:int, col:int): 
        #遍历所有已经记录的行
        for i in range(row): 
            #不能同行同列同一斜线
            if row == i or col == pos[i] or abs(row - i) == abs(col - pos[i]): 
                return False
        return True
    
    #递归查找皇后种类
    def recursion(self, n:int, row:int, pos:List[int], res:int): 
        #完成全部行都选择了位置
        if row == n: 
            res += 1
            return int(res)
        #遍历所有列
        for i in range(n): 
            #检查该位置是否符合条件
            if self.isValid(pos, row, i):  
                #加入位置
                pos[row] = i 
                #递归继续查找
                res = self.recursion(n, row + 1, pos, res) 
        return res

    def Nqueen(self , n: int) -> int:
        res = 0
        #下标为行号，元素为列号，记录皇后位置
        pos = [0] * n 
        #递归
        result = self.recursion(n, 0, pos, res) 
        return result
```

复杂度分析：

时间复杂度：O(n∗n!)，isValid函数每次检查复杂度为O(n)，递归过程相当于对长度为n的数组求全排列，复杂度为O(n!)
空间复杂度：O(n)，辅助数组和栈空间最大为O(n)

### BM60. 括号生成

题目主要信息：
求n对括号的全部合法组合，左右括号之间任意组合，只要合法就行
需要输出所有的结果
方法：递归（推荐使用）
具体做法：

相当于一共n个左括号和n个右括号，可以给我们使用，我们需要依次组装这些括号。

step 1：如果使用了一个左括号以后，那么还剩下n-1个左括号和n个右括号，也是将这些括号连接成一个字符串，就相当于是原问题的子问题，因此我们使用递归。

step 2：但是这样递归不能保证括号一定合法，我们需要保证左括号出现的次数比右括号多时我们再使用右括号就一定能保证括号合法了，因此每次需要检查左括号和右括号的使用次数。

终止条件： 左右括号都使用了n个，将结果加入数组。
返回值： 每一级向上一级返回后续组装后的字符串，即子问题中搭配出来的括号序列。
本级任务： 每一级就是保证左括号还有剩余的情况下，使用一次左括号进入子问题，或者右括号还有剩余且右括号使用次数少于左括号的情况下使用一次右括号进入子问题。

```
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param n int整型 
# @return string字符串一维数组
#
class Solution:
    def recursion(self, left:int, right:int, temp:str, res:List[str], n:int):
        #左右括号都用完了，就加入结果
        if left == n and right == n: 
            res.append(temp)
            return
        #使用一次左括号
        if left < n: 
            self.recursion(left + 1, right, temp + "(", res, n)
        #使用右括号个数必须少于左括号
        if right < n and left > right: 
            self.recursion(left, right + 1, temp + ")", res, n)
            
    def generateParenthesis(self , n: int) -> List[str]:
        #记录结果
        res = list()
        #记录每次组装的字符串 
        temp = str() 
        #递归
        self.recursion(0, 0, temp, res, n) 
        return res
```

复杂度分析：

时间复杂度：O(4^n^/sqrt(n))，复杂度取决于有多少个合法括号组合，这是第n个卡特兰数，由O(4^n^/sqrt(n))渐近界定的
空间复杂度：O(n)，递归栈最大空间，其中res数组是返回时必须要的，不算额外空间

### BM61. 矩阵最长递增路径

题目主要信息：
矩阵内是非负数，求最长的递增路径的长度
移动方向可以是上下左右，不能超出边界，这将是递归的判定条件
同一条路径不能有重复的单元格，需要有记忆
方法一：深度优先搜索(推荐使用)
具体做法：

step 1：既然是查找最长的递增路径长度，那我们首先要找到这个路径的起点，起点不好直接找到，就从上到下从左到右遍历矩阵的每个元素。

step 2：然后以每个元素都可以作为起点查找它能到达的最长递增路径，然后维护一个最大值。

step 3：如何查找以某个点为起点的最长递增路径呢？我们可以考虑递归，因此我们查找递增路径的时候，每次选中路径一个点，然后找到与该点相邻的递增位置，相当于进入这个相邻的点，继续查找递增路径，这就是递归的子问题。因此递归过程如下：

终止条件： 进入路径最后一个点后，四个方向要么是矩阵边界，要么没有递增的位置，路径不能再增长，返回上一级。
返回值： 每次返回的就是本级之后的子问题中查找到的路径长度加上本级的长度。
本级任务： 每次进入一级子问题，先初始化后续路径长度为0，然后遍历四个方向（可以用数组表示，下标对数组元素的加减表示去往四个方向），进入符合不是边界且在递增的邻近位置作为子问题，查找子问题中的递增路径长度。因为有四个方向，所以最多有四种递增路径情况，因此要维护当级子问题的最大值。
step 4：使用一个dp数组记录i，j处的单元格拥有的最长递增路径，这样在递归过程中如果访问到就不需要重复访问。

```
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 递增路径的最大长度
# @param matrix int整型二维数组 描述矩阵的每个数
# @return int整型
#
class Solution:
    global dirs
    #记录四个方向
    dirs = [[-1, 0], [1, 0], [0, -1], [0, 1]] 
    global n, m
    #深度优先搜索，返回最大单元格数
    def dfs(self, matrix:List[List[int]], dp: List[List[int]], i:int, j:int) :
        if dp[i][j] != 0:
            return dp[i][j]
        dp[i][j] += 1
        for k in range(4):
            nexti = i + dirs[k][0]
            nextj = j + dirs[k][1]
            #判断条件
            if  nexti >= 0 and nexti < n and nextj >= 0 and nextj < m and matrix[nexti][nextj] > matrix[i][j]:
                dp[i][j] = max(dp[i][j], self.dfs(matrix, dp, nexti, nextj) + 1)
        return dp[i][j]
    
    def solve(self , matrix: List[List[int]]) -> int:
        global n,m
        #矩阵不为空
        if len(matrix) == 0 or len(matrix[0]) == 0:
            return 0
        res = 0
        n = len(matrix)
        m = len(matrix[0])
        #i，j处的单元格拥有的最长递增路径
        dp = [[0 for col in range(m)] for row in range(n)]  
        for i in range(n):
            for j in range(m):
                #更新最大值
                res = max(res, self.dfs(matrix, dp, i, j)) 
        return res
```

复杂度分析：

时间复杂度：O(mn)，m、n分别为矩阵的两边，遍历整个矩阵以每个点作为起点，然后递归相当于遍历填充dp矩阵
空间复杂度：O(mn)，辅助矩阵的空间是一个二维数组

方法二：广度优先搜索（扩展思路）
具体做法：

step 1：我们可以将矩阵看成是一个有向图，计算每个结点（单元格）所对应的出度（符合边界条件且递增）。对于作为边界条件的单元格，它的值比所有的相邻单元格的值都要大，因此作为边界条件的单元格的出度都为0。利用一个二维矩阵记录每个单元格的出度
step 2：利用拓扑排序的思想，从所有出度为0的单元格开始进行广度优先搜索，借助队列来广度优先搜索，队列中每次加入出度为0的点，即路径最远点，每次从A点到B点，便将A点出度减一。
step 3：每次搜索都会遍历当前层的所有单元格，更新其余单元格的出度，并将出度变为0的单元格加入下一层搜索。
step 4：当搜索结束时，搜索的总层数即为矩阵中的最长递增路径的长度。

```
from queue import Queue

class Solution:
    global dirs
    #记录四个方向
    dirs = [[-1, 0], [1, 0], [0, -1], [0, 1]] 
    global n, m
    def solve(self , matrix: List[List[int]]) -> int:
        global n,m,dirs
        #空矩阵
        if len(matrix)==0 or len(matrix[0])==0:  
            return 0
        n = len(matrix)
        m = len(matrix[0])
        #记录每个单元的出度
        outdegrees = [[0 for i in range(m)] for j in range(n)] 
        for i in range(n):
            for j in range(m):
                for k in range(4):
                    nexti = i + dirs[k][0]
                    nextj = j + dirs[k][1]
                    if nexti >= 0 and nexti < n and nextj >= 0 and nextj < m and matrix[nexti][nextj] > matrix[i][j]:
                        #符合条件，记录出度
                        outdegrees[i][j] += 1  
        q = Queue()
        for i in range(n):
            for j in range(m):
                if outdegrees[i][j] == 0:
                    #找到出度为0的入队列
                    q.put([i, j])  
        res = 0
        while not q.empty():
            res += 1
            size = q.qsize()
            for x in range(size):
                temp = q.get() 
                i = temp[0]
                j = temp[1]
                #四个方向
                for k in range(4) : 
                    nexti = i + dirs[k][0]
                    nextj = j + dirs[k][1]
                    #逆向搜索，所以下一步是小于
                    if nexti >= 0 and nexti < n and nextj >= 0 and nextj < m and matrix[nexti][nextj] < matrix[i][j]:
                        #符合条件，出度递减
                        outdegrees[nexti][nextj]-= 1 
                        if  outdegrees[nexti][nextj] == 0:
                            q.put([nexti, nextj])
        return res
```

复杂度分析：

时间复杂度：O(mn)，m、n分别为矩阵的两边，相当于遍历整个矩阵两次
空间复杂度：O(mn)，辅助矩阵的空间是一个二维数组

## 07动态规划

### BM62. 斐波那契数列

题目主要信息
斐波那契数列公式为:
初始化第1项和第2项为1
求该数列第n项
方法一：迭代相加（推荐使用）
具体做法：

斐波那契数列初始化第1项与第2项都是1，则根据公式第0项为0.

step 1：低于2项的数列，直接返回n。
step 2：初始化第0项，与第1项分别为0，1.
step 3：从第2项开始，逐渐按照公式累加，并更新相加数始终为下一项的前两项。

```
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param n int整型 
# @return int整型
#
class Solution:
    def Fibonacci(self , n: int) -> int:
        #从0开始，第0项是0，第一项是1
        if n <= 1:    
            return n
        res = 0
        a = 0
        b = 1
        #因n=2时也为1，初始化的时候把a=0，b=1
        for i in range(2, n + 1): 
        #第三项开始是前两项的和,然后保留最新的两项，更新数据相加
            res = (a + b)
            a = b
            b = res
        return res
```

复杂度分析：

时间复杂度：O(n)，其中n为输入的数，n次迭代
空间复杂度：O(1)，常数级变量，没有其他额外辅助空间

方法二：递归法（扩展思路）
具体做法：

我们也可以根据公式倒推F(n)=F(n−1)+F(n−2)，因为，而F(n−1)与F(n−2)又可以作为子问题继续计算，因此可以使用递归。

step 1：低于2项的数列，直接返回n。
step 2：对于当前n，递归调用函数计算两个子问题相加。

```
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param n int整型 
# @return int整型
#
class Solution:
    def __init__(self):
        self.num = [0 for i in range(41)]
    def Fibonacci(self , n: int) -> int:
        #从0开始，第0项是0，第一项是1
        if n <= 1:    
            self.num[n] = n
            return n
        if self.num[n - 1] == 0:
            self.num[n - 1] = self.Fibonacci(n - 1)
        if self.num[n - 2] == 0:
            self.num[n - 2] = self.Fibonacci(n - 2)
        #根据公式递归调用函数
        return self.num[n - 1] + self.num[n - 2] 
```

复杂度分析：

时间复杂度：O(2^n)，每个递归会调用两个递归，因此呈现2的指数增长（Python版本优化为O(n)）
空间复杂度：O(n), 递归栈的最大深度

方法三：动态规划(扩展思路)
具体做法：

既然是数列，我们就把它放入数组中来解决。

step 1：创建一个长度为n+1的数组，因为只有n+1才能有下标第n项，我们用它记录前n项斐波那契数列。
step 2：根据公式，初始化第0项和第1项（题目中是第1项和第2项，本质上一样的）。
step 3：遍历数组，依照公式某一项等于前两项之和，将数组后续元素补齐，即可得到fib[n]。

```
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param n int整型 
# @return int整型
#
class Solution:
    def Fibonacci(self , n: int) -> int:
        #从0开始，第0项是0，第一项是1
        if n <= 1:    
            return n
        fib = [0 for i in range(n + 1)]
        fib[0] = 0
        fib[1] = 1
        #依次相加
        for i in range(2, n + 1): 
            fib[i] = fib[i - 1] + fib[i - 2]
        return fib[n]
```

复杂度分析：

时间复杂度：O(n)，一个for循环遍历
空间复杂度：O(n)，创建了一个大小为n+1的动态数组

### BM63. 跳台阶

题目主要信息：
一只青蛙一次可以跳1阶或2阶
求跳到第n阶的种类数
一只青蛙一次可以跳1阶或2阶，直到跳到第n阶，也可以看成这只青蛙从n阶往下跳，到0阶，按照原路返回的话，两种方法事实上可以的跳法是一样的——即怎么来的，怎么回去！
当青蛙在第n阶往下跳，它可以选择跳1阶到n-1，也可以选择跳2阶到n-2，即它后续的跳法变成了f(n-1)+f(n-2)，这就变成了斐波那契数列。因此可以按照斐波那契数列的做法来做：即输入n，输出第n个斐波那契数列的值，初始化0阶有1种，1阶有1种。

方法一：迭代相加（推荐使用）
具体做法：

step 1：低于2项的数列，直接返回n。
step 2：初始化第0项，与第1项分别为0，1.
step 3：从第2项开始，逐渐按照公式累加，并更新相加数始终为下一项的前两项。

```
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param number int整型 
# @return int整型
#
class Solution:
    def jumpFloor(self , n: int) -> int:
        #从0开始，第0项是1，第一项是1
        if n <= 1:    
            return 1
        res = 0
        a = 1
        b = 1
        #初始化的时候把a=1，b=1
        for i in range(2, n + 1): 
        #第三项开始是前两项的和,然后保留最新的两项，更新数据相加
            res = (a + b)
            a = b
            b = res
        return res
```

复杂度分析：

时间复杂度：O(n)，其中n为输入的数
空间复杂度：O(1)，常数级变量，没有其他额外辅助空间

方法二：递归法（扩展思路）
我们也可以根据公式倒推，因为F(n)=F(n−1)+F(n−2)，而F(n−1)与F(n−2)又可以作为子问题继续计算，因此可以使用递归。

step 1：低于2项的数列，直接返回1。
step 2：对于当前n，递归调用函数计算两个子问题相加。

```
class Solution:
    def jumpFloor(self , number: int) -> int:
        #从0开始，第0项是1，第一项是1
        if number <= 1:    
            return 1 
        #根据公式递归调用函数
        return self.jumpFloor(number - 1) + self.jumpFloor(number - 2) 
```

复杂度分析：

时间复杂度：O(2^n)，每个递归会调用两个递归，因此呈现2的指数增长
空间复杂度：O(n), 栈空间最大深度为n

方法三：递归改进（扩展思路）
alt

递归虽然简单，但是重复计算了很大一部分，可以利用数组记录每个F(n)，需要的时候直接调用数组里面的值即可。

step 1：使用dp数组记录前面的数列值。
step 2：函数中低于2项的数列，直接返回1。
step 3：对于当前n，如果dp数组中存在则直接使用，否则递归调用函数计算两个子问题相加。

```
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param number int整型 
# @return int整型
#
class Solution:
    def __init__(self):
        self.num = [0 for i in range(41)]
    def jumpFloor(self , number: int) -> int:
        #从0开始，第0项是1，第一项是1
        if number <= 1:    
            self.num[number] = 1
            return 1
        #若是dp中有值则不需要重新递归加一次
        if self.num[number - 1] == 0:
            self.num[number - 1] = self.jumpFloor(number - 1)
        if self.num[number - 2] == 0:
            self.num[number - 2] = self.jumpFloor(number - 2)
        #根据公式相加
        return self.num[number - 1] + self.num[number - 2] 
```

复杂度分析：

时间复杂度：每个数字只算了一次，故为O(n)
空间复杂度：O(n)，栈空间最大深度

方法四：动态规划（扩展思路）
具体做法：

既然与斐波那契数列相同，我们就把它放入数组中来解决。

step 1：创建一个长度为n+1的数组，因为只有n+1才能有下标第n项，我们用它记录前n项斐波那契数列。
step 2：根据公式，初始化第0项和第1项。
step 3：遍历数组，依照公式某一项等于前两项之和，将数组后续元素补齐，即可得到fib[n]。

```
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param number int整型 
# @return int整型
#
class Solution:
    def jumpFloor(self , number: int) -> int:
        #从0开始，第0项是1，第一项是1
        if number <= 1:    
            return 1
        temp = [0 for i in range(number + 1)]
        #初始化
        temp[0] = 1
        temp[1] = 1
        #依次相加
        for i in range(2, number + 1): 
            temp[i] = temp[i - 1] + temp[i - 2]
        return temp[number]
```

复杂度分析：

时间复杂度：O(n)，遍历了一次长度为n的数组
空间复杂度：O(n)，建立了一个数组辅助

### BM64. 最小花费爬楼梯

题目主要信息:
给定一个数组，其中每个元素代表该级楼梯向上爬需要支付的费用，下标从0开始
一旦支付费用，可以任意选择爬一级或是二级
需要求爬到顶楼，即越过数组末尾元素所需要的最小花费
可以从下标为0或是1的台阶开始
方法：动态规划（推荐使用）
具体做法：

step 1：可以用一个数组记录每次爬到第i阶楼梯的最小花费，然后每增加一级台阶就转移一次状态，最终得到结果。
step 2：（初始状态） 因为可以直接从第0级或是第1级台阶开始，因此这两级的花费都直接为0.
step 3：（状态转移） 每次到一个台阶，只有两种情况，要么是它前一级台阶向上一步，要么是它前两级的台阶向上两步，因为在前面的台阶花费我们都得到了，因此每次更新最小值即可，转移方程为：dp[i]=min(dp[i−1]+cost[i−1],dp[i−2]+cost[i−2])。

```
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param cost int整型一维数组 
# @return int整型
#
class Solution:
    def minCostClimbingStairs(self , cost: List[int]) -> int:
        #dp[i]表示爬到第i阶楼梯需要的最小花费
        dp = [0 for i in range(len(cost) + 1)] 
        for i in range(2, len(cost) + 1):
            #每次选取最小的方案
            dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]) 
        return dp[len(cost)]
```

复杂度分析：

时间复杂度：O(n)，其中n为给定的数组长度，遍历一次数组
空间复杂度：O(n)，辅助数组dp的空间

### BM65. 最长公共子序列(二)

题目主要信息：
仅存在一个最长公共子序列，不需要去重
最长公共子序列为空需要返回"-1"，而不是空序列，最后要变换
方法一：动态规划（推荐使用）
具体做法：

step 1：优先检查特殊情况。
step 2：我们以 dp[i] [j] 表示在s1中以i结尾，s2中以j结尾的字符串的最长公共子序列长度。
step 3：若是i与j相等，则该问题可以变成 1+dp[i] [j] ，即最长公共子序列长度加1，若是不相等，则换成两个子问题： dp[i] [j-1] 或者 dp[i-1] [j] ，由此用递归即可以解决。
step 4：但是递归的复杂度过高，重复计算了太多部分，因此可以用动态规划，从前往后加，由此形成一个表，表从1开始往后相加。因最后要返回该序列，所以在构造表的同时要以另一个二维矩阵记录打印方向。
step 5：计算答案时使用递归。

```
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# longest common subsequence
# @param s1 string字符串 the string
# @param s2 string字符串 the string
# @return string字符串
#
import sys
#设置递归深度
sys.setrecursionlimit(100000) 
class Solution:
    def __init__(self):
        self.x = ""
        self.y = ""
    #获取最长公共子序列
    def ans(self, i: int, j: int, b: List[List[int]]): 
        res = ""
        #递归终止条件
        if i == 0 or j == 0: 
            return res
        #根据方向，往前递归，然后添加本级字符
        if b[i][j] == 1:
            res = res + self.ans(i - 1, j - 1, b)
            res = res + self.x[i - 1]
        elif b[i][j] == 2:
            res = res + self.ans(i - 1, j, b)
        elif b[i][j] == 3:
            res = res + self.ans(i, j - 1, b)
        return res
    def LCS(self , s1: str, s2: str) -> str:
        #特殊情况
        if s1 is None or s2 is None: 
            return "-1"
        len1 = len(s1)
        len2 = len(s2)
        self.x = s1
        self.y = s2
        #dp[i][j]表示第一个字符串到第i位，第二个字符串到第j位为止的最长公共子序列长度
        dp = [[0] * (len2 + 1) for i in range(len1 + 1)]
        #动态规划数组相加的方向
        b = [[0] * (len2 + 1) for i in range(len1 + 1)]
        #遍历两个字符串每个位置求的最长长度
        for i in range(1, len1 + 1): 
            for j in range(1, len2 + 1):
                #遇到两个字符相等
                if s1[i - 1] == s2[j - 1]:
                    #考虑由二者都向前一位
                    dp[i][j] = dp[i - 1][j - 1] + 1
                    #来自于左上方
                    b[i][j] = 1 
                #遇到的两个字符不同
                #左边的选择更大，即第一个字符串后退一位
                elif dp[i - 1][j] > dp[i][j - 1]:
                    dp[i][j] = dp[i - 1][j]
                    #来自于左方
                    b[i][j] = 2 
                #右边的选择更大，即第二个字符串后退一位
                else:
                    dp[i][j] = dp[i][j - 1]
                    #来自于上方
                    b[i][j] = 3 
        #获取答案字符串
        res = self.ans(len1, len2, b)
        #检查答案是否位空
        if res is None or res == "":
            return "-1"
        else:
            return res
```

复杂度分析：

时间复杂度：O(n^2) ，构造辅助数组dp与b，两层循环，递归是有方向的递归，因此只是相当于遍历了二维数组
空间复杂度：O(n^2) ，辅助二维数组dp与递归栈的空间最大为O(n^2)

方法二：栈（扩展思路）
具体做法：

能够递归解决的也可以用栈解决的。

step 1：优先检查特殊情况。
step 2：我们以dp[i] [j]表示在s1中以i结尾，s2中以j结尾的字符串的最长公共子序列长度。
step 3：若是i与j相等，则该问题可以变成1+dp[i] [j]，即最长公共子序列长度加1，若是不相等，则换成两个子问题：dp[i] [j-1]或者dp[i-1] [j]，由此用递归即可以解决。
step 4：不需要第二个辅助数组b，直接每次比较dp与其左、上、左上的关系，然后将符合要求的字符加入栈中即可实现逆序输出。

```
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# longest common subsequence
# @param s1 string字符串 the string
# @param s2 string字符串 the string
# @return string字符串
#
class Solution:
    def LCS(self , s1: str, s2: str) -> str:
        #特殊情况
        if s1 is None or s2 is None: 
            return "-1"
        len1 = len(s1)
        len2 = len(s2)
        #dp[i][j]表示第一个字符串到第i位，第二个字符串到第j位为止的最长公共子序列长度
        dp = [[0] * (len2 + 1) for i in range(len1 + 1)] 
        #遍历两个字符串每个位置求的最长长度
        for i in range(1, len1 + 1):
            for j in range(1, len2 + 1):
                #遇到两个字符相等
                if s1[i - 1] == s2[j -1]:
                    #来自于左上方
                    dp[i][j] = dp[i - 1][j - 1] + 1
                #遇到的两个字符不同
                else:
                    #来自左边或者上方的最大值
                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
        #从动态规划数组末尾开始
        i = len1
        j = len2
        s = []
        while dp[i][j] != 0:
            #来自于左方向
            if dp[i][j] == dp[i - 1][j]: 
                i = i - 1
            #来自于上方向
            elif dp[i][j] == dp[i][j - 1]: 
                j = j - 1
            #来自于左上方向
            elif dp[i][j] > dp[i - 1][j - 1]: 
                i = i - 1
                j = j - 1
                #只有左上方向才是字符相等的情况，入栈，逆序使用
                s.append(s1[i]) 
        res = ""
        #拼接子序列
        while len(s) != 0:
            res += s[-1]
            s.pop()
        #如果两个完全不同，返回字符串为空，则要改成-1
        if res is None or res == "": 
            return "-1"
        else:
            return res
```

复杂度分析：

时间复杂度： O(n^2) ，最坏复杂度为构造辅助数组dp两层循环
空间复杂度： O(n^2) ，辅助二维数组dp与栈空间最大为 O(n^2) 

### BM66. 最长公共子串

题目主要信息：
查找两个字符串str1，str2中的最长的公共子串
保证str1和str2的最长公共子串存在且唯一
方法一：枚举（前置方法，不能完全通过）
具体做法：

最简单直观的方式大概就是枚举了，枚举所有的子串进行比较，但是太复杂了。其实找子串不用一样完全枚举，还可以尝试改良一下：

step 1：我们完全可以遍历两个字符串的所有字符串作为起始
step 2：然后同时开始检查字符是否相等，相等则不断后移，增加子串长度，如果不等说明以这两个为起点的子串截止了，不会再有了。
step 3：后续比较长度维护最大值即可。

```
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# longest common substring
# @param str1 string字符串 the string
# @param str2 string字符串 the string
# @return string字符串
#
class Solution:
    def LCS(self , str1: str, str2: str) -> str:
        #让str1为较长的字符串
        if len(str1) < len(str2): 
            str1, str2 = str2, str1
        res = ''
        max_len = 0
        #遍历str1的长度
        for i in range(len(str1)): 
            #查找是否存在
            if str1[i - max_len : i + 1] in str2: 
                res = str1[i - max_len : i + 1]
                max_len += 1
        return res
```

复杂度分析：

时间复杂度： O(m^2n) ，其中m是str1的长度，n是str2的长度，分别枚举两个字符串每个字符作为起点，后续检查子串长度最坏需要花费 O(m) 
空间复杂度： O(n) ，res属于返回必要空间，temps属于临时辅助空间，最坏情况下长度为n

方法二：动态规划（推荐使用）
具体做法：

动态规划继承自方法一，在枚举的基础上用动态规划来改进。

step 1：我们可以用dp[i] [j]表示在str1中以第个字符结尾在str2中以第个字符结尾时的公共子串长度，
step 2：遍历两个字符串填充dp数组，转移方程为：如果遍历到的该位两个字符相等，则此时长度等于两个前一位长度+1，dp[i] [j]=dp[i-1] [j-1]+1，如果遍历到该位时两个字符不相等，则置为0，因为这是子串，必须连续相等，断开要重新开始。
step 3：每次更新后，我们维护最大值，并更新该子串结束位置。
step 4：最后根据最大值结束位置即可截取出子串。

```
class Solution:
    def LCS(self , str1: str, str2: str) -> str:
        #dp[i][j]表示到str1第i个个到str2第j个为止的公共子串长度
        dp = [[0] * (len(str2) + 1) for i in range(len(str1) + 1)]
        max = 0
        pos = 0
        for i in range(1, len(str1) + 1):
            for j in range(1, len(str2) + 1):
                #如果该两位相同
                if str1[i - 1] == str2[j - 1]: 
                    #则增加长度
                    dp[i][j] = dp[i - 1][j - 1] + 1 
                else: 
                    #该位置为0
                    dp[i][j] = 0 
                #更新最大长度
                if dp[i][j] > max: 
                    max = dp[i][j]
                    pos = i - 1
        return str1[pos - max + 1: pos + 1]
```

复杂度分析：

时间复杂度： O(mn) ，其中 m 是str1的长度， n 是str2的长度，遍历两个字符串所有字符
空间复杂度： O(mn) ，dp数组大小为 m*n 

### BM67. 求路径

题目主要信息：
给定一个 m*n 的矩阵，要求从矩阵的左上角走到右下角的不同路径数量
每次只能往下或者往右走
这道题非常典型，我们可以考虑多种方式。

方法一：递归(推荐使用)
具体做法：

首先我们在左上角第一个格子的时候，有两种行走方式：如果向右走，相当于后面在一个 (n-1)*m 的矩阵中查找从左上角到右下角的不同路径数；而如果向下走，相当于后面在一个 n*(m-1) 的矩阵中查找从左上角到右下角不同的路径数。而 (n-1)*m 的矩阵与 n*(m-1) 的矩阵都是矩阵 n*m 的子问题，因此可以使用递归。

step 1：（终止条件） 当矩阵变长n减少到1的时候，很明显只能往下走，没有别的选择了，只有1条路径；同理m减少到1时也是如此。因此此时返回数量为1.
step 2：（返回值） 对于每一级都将其两个子问题返回的结果相加返回给上一级。
step 3：（本级任务） 每一级都有向下或者向右两种路径选择，分别进入相应分支的子问题。

Python代码实现：(Python版本超时，不能完全通过)

```
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param m int整型 
# @param n int整型 
# @return int整型
#
import sys
#设置递归深度
sys.setrecursionlimit(100000) 
class Solution:
    def uniquePaths(self , m: int, n: int) -> int:
        #矩阵只要有一条边为1，路径数就只有一种了
        if m == 1 or n == 1: 
            return 1
        else: 
            #两个分支
            return self.uniquePaths(m - 1, n) + self.uniquePaths(m, n - 1)
```

复杂度分析：

时间复杂度： O(mn) ，其中 m 、 n 分别为矩阵的两边长，递归过程对于每个 m 最多都要经过每一种 n 
空间复杂度： O(m+n) ，递归栈的最大深度为矩阵两边从 m 、 n 都到了1

方法二：动态规划（扩展思路）
具体做法：

如果我们此时就在右下角的格子，那么能够到达该格子的路径只能是它的上方和它的左方两个格子，因此从左上角到右下角的路径数应该是从左上角到它的左边格子和上边格子的路径数之和，因此可以动态规划。

step 1：用dp[i] [j]表示大小为 i*j 的矩阵的路径数量，下标从1开始。
step 2：（初始条件） 当i或者j为1的时候，代表矩阵只有一行或者一列，因此只有一种路径。
step 3：（转移方程） 每个格子的路径数只会来自它左边的格子数和上边的格子数，因此状态转移为dp[i] [j]=dp[i−1] [j]+dp[i] [j−1]。

```
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param m int整型 
# @param n int整型 
# @return int整型
#
class Solution:
    def uniquePaths(self , m: int, n: int) -> int:
        #dp[i][j]表示大小为i*j的矩阵的路径数量
        dp = [[0] * (n + 1) for i in range(m + 1)] 
        for i in range(1, m + 1):
            for j in range(1, n + 1):
                #只有1行的时候，只有一种路径
                if i == 1: 
                    dp[i][j] = 1
                    continue
                #只有1列的时候，只有一种路径
                if j == 1: 
                    dp[i][j] = 1
                    continue
                #路径数等于左方格子的路径数加上上方格子的路径数
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1] 
        return dp[m][n]
```

复杂度分析：

时间复杂度： O(mn) ，其中 m 、 n 分别为矩阵的两边长，两层遍历填充整个dp数组
空间复杂度： O(mn) ，辅助空间dp数组为二维数组

方法三：组合数学（扩展思路）
具体做法：

从矩阵左上角走到矩阵右下角，总共需要往下走 m-1 步，往右走 n-1 步，不同的走法路径在于往下和往右的组合情况，即在一堆往下和往右的序列中，每种排列的情况，序列一共有 m+n-2 个位置，选择其中 n-1 个位置作为往下，即不同的走法有C^n−1^~m+n−2~=(*m*+*n*−2)!/(*n*−1)!(*m*−1)!种情况。

step 1：分子分母从1开始；
step 2：按照公式累乘相除。

```
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param m int整型 
# @param n int整型 
# @return int整型
#
class Solution:
    #计算阶乘
    def fun(self, n: int) -> int: 
        sum = 1
        #连乘
        for i in range(1, n + 1):
            sum *= i
        return sum
    def uniquePaths(self , m: int, n: int) -> int:
        #公式计算
        return self.fun(m + n - 2) // (self.fun(m - 1) * self.fun(n - 1))
```

### BM68. 矩阵的最小路径和

题目主要信息:
给定一个矩阵，从矩阵左上角到右下角，每次只能向下或者向右
从左上角到右下角路径上经过的所有数字之和为路径和，求该路径和的最小值
矩阵不为空，每个元素值都为非负数
方法：动态规划（推荐使用）
具体做法：

最朴素的解法莫过于枚举所有的路径，然后求和，找出其中最大值。但是像这种有状态值可以转移的问题，我们可以尝试用动态规划。

step 1：我们可以构造一个与矩阵同样大小的二维辅助数组，其中表示dp[i] [j]以(i,j)位置为终点的最短路径和，则dp[0] [0] = matrix[0] [0]。
step 2：很容易知道第一行与第一列，只能分别向右或向下，没有第二种选择，因此第一行只能由其左边的累加，第一列只能由其上面的累加。
step 3：边缘状态构造好以后，遍历矩阵，补全矩阵中每个位置的dp数组值：如果当前的位置是(i,j)，上一步要么是(i-1,j)往下，要么就是(i,j-1)往右，那么取其中较小值与当前位置的值相加就是到当前位置的最小路径和，因此状态转移公式为 dp[i] [j] = min(dp[i-1] [j], dp[i] [j-1]) + matrix[i] [j] 。
step 4：最后移动到(n-1,m-1)的位置就是到右下角的最短路径和。

```
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param matrix int整型二维数组 the matrix
# @return int整型
#
class Solution:
    def minPathSum(self , matrix: List[List[int]]) -> int:
        n = len(matrix)
        #因为n,m均大于等于1
        m = len(matrix[0])  
        #dp[i][j]表示以当前i，j位置为终点的最短路径长度
        dp = [[0] * (m + 1) for i in range(n + 1)]
        dp[0][0] = matrix[0][0] 
        #处理第一列
        for i in range(1, n): 
            dp[i][0] = matrix[i][0] + dp[i - 1][0]
        #处理第一行
        for j in range(1, m): 
            dp[0][j] = matrix[0][j] + dp[0][j - 1]
        #其他按照公式来
        for i in range(1, n):  
            for j in range(1, m):
                if dp[i - 1][j] > dp[i][j - 1]:
                    dp[i][j] = matrix[i][j] + dp[i][j - 1]
                else:
                    dp[i][j] = matrix[i][j] + dp[i - 1][j]
        return dp[n - 1][m - 1]
```

复杂度分析：

时间复杂度： O(mn) ，单独遍历矩阵的一行一列，然后遍历整个矩阵
空间复杂度： O(mn) ，辅助矩阵dp为二维数组

### BM69. 把数字翻译成字符串

题目主要信息：
字母到数字分别为1-26映射，没有0
输入的数字是字符串，故非常大，超过了long long的表示范围
但凡出现11-19，21-26的就可能出现两种译码结果
求总后的译码结果种类
方法：动态规划（推荐使用）
具体做法：

step 1：用辅助数组dp表示前i个数的译码方法有多少种。
step 2：对于一个数，我们可以直接译码它，也可以将其与前面的1或者2组合起来译码：如果直接译码，则dp[i]=dp[i-1]；如果组合译码，则dp[i]=dp[i-2]。
step 3：对于只有一种译码方式的，选上种dp[i-1]即可，对于满足两种译码方式（10，20不能）则是dp[i-1]+dp[i-2]
step 4：依次相加，最后的dp[length]即为所求答案。

```
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 解码
# @param nums string字符串 数字串
# @return int整型
#
class Solution:
    def solve(self , nums: str) -> int:
        #排除0
        if nums == "0":  
            return 0
        #排除只有一种可能的10 和 20
        if nums == "10" or nums == "20":   
            return 1
        #当0的前面不是1或2时，无法译码，0种
        for i in range(1, len(nums)): 
            if nums[i] == '0':
                if nums[i - 1] != '1' and nums[i - 1] != '2':
                    return 0
        #辅助数组初始化为1
        dp = [1 for i in range(len(nums) + 1)]  
        for i in range(2, len(nums) + 1):
            #在11-19，21-26之间的情况
            if (nums[i - 2] == '1' and nums[i - 1] != '0') or (nums[i - 2] == '2' and nums[i - 1] > '0' and nums[i - 1] < '7'):
                dp[i] = dp[i - 1] + dp[i - 2]
            else:
                dp[i] = dp[i - 1]
        return dp[len(nums)]
```

复杂度分析：

时间复杂度： O(n) ，两次遍历都是单层
空间复杂度： O(n) ，辅助数组dp

### BM70. 兑换零钱(一)

题目主要信息：
给定数组arr，arr中所有的值都为正整数且不重复
arr中每个值代表一种面值的货币，每种面值的货币可以使用任意
组成aim的最少货币数
如果无解，请返回-1
方法一：动态规划（推荐使用）
具体做法：

这类涉及状态转移的题目，可以考虑动态规划。

step 1：可以用dp[i]表示要凑出i元钱需要最小的货币数。
step 2：一开始都设置为最大值aim+1，因此货币最小1元，即货币数不会超过aim.
step 3：初始化dp[0]。
step 4：后续遍历1元到aim元，枚举每种面值的货币都可能组成的情况，取每次的最小值即可，转移方程为dp[i]=min(dp[i],dp[i−arr[j]]+1).
step 5：最后比较dp[aim]的值是否超过aim，如果超过说明无解，否则返回即可。

```
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 最少货币数
# @param arr int整型一维数组 the array
# @param aim int整型 the target
# @return int整型
#
class Solution:
    def minMoney(self , arr: List[int], aim: int) -> int:
        #小于1的都返回0
        if aim < 1: 
            return 0
        #dp[i]表示凑齐i元最少需要多少货币数
        dp = [(aim + 1) for i in range(aim + 1)] 
        dp[0] = 0
        #遍历1-aim元
        for i in range(1, aim + 1): 
            #每种面值的货币都要枚举
            for j in range(len(arr)): 
                #如果面值不超过要凑的钱才能用
                if arr[j] <= i: 
                    #维护最小值
                    dp[i] = min(dp[i], dp[i - arr[j]] + 1) 
        #如果最终答案大于aim代表无解
        if dp[aim] > aim: 
            return -1
        else:
            return dp[aim] 
```

复杂度分析：

时间复杂度： O(n⋅aim) ，第一层遍历枚举1元到aim元，第二层遍历枚举n种货币面值
空间复杂度： O(aim) ，辅助数组dp的大小

方法二：空间记忆递归（扩展思路）
具体做法：

对于需要凑成aim的钱，第一次我们可以选择使用arr[0]，则后续需要凑出aim-arr[0]的钱，那后续就是上一个的子问题，可以用递归进行。因为每种面值使用不受限，因此第一次我们可以使用arr数组中每一个，同理后续每次也可以使用arr数组中每一次，因此每次递归都要遍历arr数组，相当于分枝为arr.size()的树型递归。

step 1：递归的时候，一旦剩余需要凑出的钱为0，则找到一种情况，记录下整个的使用货币的数量，维护最小值即可。
step 2：一旦剩余需要凑出的钱为负，则意味着这一分枝无解，返回-1.
step 3：后续每次也可以使用arr数组中一次，进入子问题。
step 4：但是树型递归的复杂度需要O(aim^n)，重复计算过于多了，如图所示，因此我们可以用一个dp数组记录每次递归上来的结果，避免小分支重复计算，如果dp数组有值直接获取即可，不用再重复计算了。

```
class Solution:
    def recursion(self, arr: List[int], aim: int, dp: List[int]) -> int:
        #组合超过了，返回-1
        if aim < 0: 
            return -1
        #组合刚好等于需要的零钱
        if aim == 0: 
            return 0
        #剩余零钱是否已经被运算过了
        if dp[aim - 1] != 0: 
            return dp[aim - 1]
        Min = 10001
        #遍历所有面值
        for i in range(len(arr)): 
            #递归运算选择当前的面值
            res = self.recursion(arr, aim - arr[i], dp) 
            #获取最小值
            if res >= 0 and res < Min: 
                Min = res + 1
        if Min == 10001:
            dp[aim - 1] = -1
        else:
            #更新最小值
            dp[aim - 1] = Min  
        return dp[aim - 1]
    def minMoney(self , arr: List[int], aim: int) -> int:
        #小于1的都返回0
        if aim < 1: 
            return 0
        #记录递归中间的值
        dp = [0 for i in range(aim)] 
        return self.recursion(arr, aim, dp)
```

复杂度分析：

时间复杂度： O(n⋅aim) ，一共需要计算aim个状态的答案，每个状态需要枚举n个面值
空间复杂度： O(aim) ，递归栈深度及辅助数组的空间

### BM71. 最长上升子序列(一)

题目主要信息:
给定一个数组，求其中最长的严格上升子序列的长度
子序列是指数组去掉或不去掉元素后的数组，不要求在原本数组中全部相邻，但是在原数组中的相对位置不能改变
严格上升指子序列严格单调递增
方法一：动态规划（推荐使用）
具体做法：

要找到最长的递增子序列长度，常用方法是动态规划。

step 1：用dp[i]表示到元素i结尾时，最长的子序列的长度，第一层遍历得到n个长度的子串，第二层遍历该子串求相应到元素i结尾时的最长递增序列长度，期间维护最大值。
step 2：（初始条件） 不管如何只要数组不为空，最长递增子序列至少有1个，因此可以初始化dp数组全部为1.
step 3：（转移方程） 对于每一个到i结尾的子串，如果遍历过程中遇到元素j小于结尾，说明以该元素结尾的子序列加上子串末尾元素也是严格递增的，因此转移方程为dp[i]=dp[j]+1。

```
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 给定数组的最长严格上升子序列的长度。
# @param arr int整型一维数组 给定的数组
# @return int整型
#
class Solution:
    def LIS(self , arr: List[int]) -> int:
        #设置数组长度大小的动态规划辅助数组
        dp = [1 for i in range(len(arr))] 
        res = 0
        for i in range(1, len(arr)):
            for j in range(i):
                #可能j不是所需要的最大的，因此需要dp[i] < dp[j] + 1
                if arr[i] > arr[j] and dp[i] < dp[j] + 1: 
                    #i点比j点大，理论上dp要加1
                    dp[i] = dp[j] + 1 
                    #找到最大长度
                    res = max(res, dp[i]) 
        return res
```

复杂度分析：

时间复杂度： O(n^2) ，其中 n 为数组长度，两层遍历循环
空间复杂度： O(n) ，辅助数组dp的空间

### BM72. 连续子数组的最大和

题目主要信息：
输入一个长度为n的整型数组array，数组中的一个或连续多个整数组成一个子数组，找到一个具有最大和的连续子数组的和
不存在空数组，−100<=a[i]<=100
方法一：动态规划(推荐使用)
具体做法：

step 1：可以用dp数组表示以下标i为终点的最大连续子数组和。
step 2：每次遇到一个新的数组元素，连续的子数组要么加上变得更大，要么它本身就更大，因此状态转移为dp[i]=max(dp[i−1]+array[i],array[i])。
step 3：遍历数组，每次只要比较取最大值即可。

```
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param array int整型一维数组 
# @return int整型
#
class Solution:
    def FindGreatestSumOfSubArray(self , array: List[int]) -> int:
        #记录到下标i为止的最大连续子数组和
        dp = [0 for i in range(len(array))] 
        dp[0] = array[0]
        maxsum = dp[0]
        for i in range(1, len(array)):
            #状态转移：连续子数组和最大值
            dp[i] = max(dp[i - 1] + array[i], array[i]) 
            #维护最大值
            maxsum = max(maxsum, dp[i]) 
        return maxsum
```

复杂度分析：

时间复杂度： O(n) ，其中 n 为数组长度，遍历一次数组
空间复杂度： O(n) ，动态规划辅助数组长度为 n 

方法二：动态规划空间优化（扩展思路）
具体做法：

我们注意到方法一的动态规划在状态转移的时候只用到了i-1的信息，没有使用整个数组的信息。

step 1：我们可以使用两个变量迭代来代替数组。
step 2：状态转移的时候更新变量y，该轮循环结束的再更新x为y即可做到每次迭代都是上一轮的dp。
step 3：遍历数组，每次只要比较取最大值即可。

```
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param array int整型一维数组 
# @return int整型
#
class Solution:
    def FindGreatestSumOfSubArray(self , array: List[int]) -> int:
        x = array[0]
        y = 0
        maxsum = x
        for i in range(1, len(array)):
            #状态转移：连续子数组和最大值
            y = max(x + array[i], array[i]) 
            #维护最大值
            maxsum = max(maxsum, y) 
            #更新x的状态
            x = y 
        return maxsum
```

复杂度分析：

时间复杂度： O(n) ，其中 n 为数组长度，遍历一次数组
空间复杂度： O(1) ，常数级变量，无额外辅助空间

### BM73. 最长回文子串

题目主要信息：
给定一个仅包含小写字母的字符串，求它的最长回文子串的长度
回文串，指左右对称的字符串
方法一：中心扩展法（推荐使用）
具体做法：

也可以遍历每个字符，以该字符为中心（分奇数长度和偶数长度两种情况），不断向两边扩展，如果两边都是相同的就是回文，不断扩大到最大长度即是以这个字符为中心的最长回文子串，我们比较完每个字符为中心的最长回文子串，取最大值即可。

```
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param A string字符串 
# @return int整型
#
class Solution:
    def fun(self, s: str, begin: int, end: int) -> int:
        #每个中心点开始扩展
        while begin >= 0 and end < len(s) and s[begin] == s[end]: 
            begin -= 1
            end += 1
        #返回长度
        return end - begin - 1 
    def getLongestPalindrome(self , A: str) -> int:
        maxlen = 1
        #以每个点为中心
        for i in range(len(A) - 1): 
            #分奇数长度和偶数长度向两边扩展
            maxlen = max(maxlen, max(self.fun(A, i, i), self.fun(A, i, i + 1)))
        return maxlen
```

复杂度分析：

时间复杂度： O(n^2) ，其中 n 为字符串长度，遍历字符串每个字符，每个字符的扩展都要 O(n) 
空间复杂度： O(1) ，常数级变量，无额外辅助空间

方法二：manacher算法（扩展思路）
具体做法：

方法一讨论了两种情况，子串长度为奇数和偶数的情况，但其实我们可以对字符串添加不属于里面的特殊字符，来让所有的回文串都变成奇数形式。同时上述中心扩展法有很多重复计算，manacher就可以优化：

step 1：我们用maxpos表示目前已知的最长回文子串的最右一位的后一位，用index表示当前的最长回文子串的中心点。
step 2：对于给定的 i 我们找一个和它关于index对称的 j ，也就是 index-j= =i-index ，换言之就是 j= =2*index-i 。
step 3：i 和 j 的最长回文子串在index的回文串范围内的部分应该是一模一样的，但是在外面的部分就无法保证了，当然，最好的情况是i和j的回文子串范围都很小，这样就保证了它们的回文子串一定一模一样，对于超出的部分我们也没有办法, 只能手动使用中心扩展。
step 4：最后答案计算的时候需要考虑使用预处理，长度被加了一倍，于是结果是 max(mp[i]-1)。

```
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param A string字符串 
# @return int整型
#
class Solution:
    #manacher算法
    def manacher(self, s: str, n: int, mp: List[int]): 
        ms = ""
        ms += "$#"
        #预处理
        for i in range(n): 
            #使之都变成奇数回文子串
            ms += s[i] 
            ms += '#'
        #目前已知的最长回文子串的最右一位的后一位
        maxpos = 0 
        #当前的最长回文子串的中心点
        index = 0 
        for i in range(len(ms)):
            if maxpos > i:
                mp[i] = min(mp[2 * index - i], maxpos - i)
            else:
                mp[i] = 1
            #两边扫
            while i - mp[i] > 0 and i + mp[i] < len(ms) and ms[i + mp[i]] == ms[i - mp[i]]: 
                mp[i] += 1
            #更新位置
            if i + mp[i] > maxpos: 
                maxpos = i + mp[i]
                index = i      
    def getLongestPalindrome(self , A: str) -> int:
        n = len(A)
        #记录回文子串长度
        mp = [0 for i in range(2 * n + 2)] 
        self.manacher(A, n, mp)
        maxlen = 0
        #遍历数组
        for i in range(2 * n + 2): 
            #找到最大的长度
            maxlen = max(maxlen, mp[i] - 1)  
        return maxlen
```

复杂度分析：

时间复杂度： O(n) ，都是单层遍历，函数中的while循环累计也不会超过 2n 次
空间复杂度： O(n) ，长度为 2∗n 的预处理后的字符串和长度为 2∗n+2 的数组

### BM74. 数字字符串转化成IP地址

题目主要信息：
有一个只包含数字的字符串，将该字符串转化成IP地址的形式
需要返回所有情况，顺序没有问题
方法一：枚举（推荐使用）
具体做法：

对于IP字符串，如果只有数字，则相当于需要我们将IP地址的三个点插入字符串中，而第一个点的位置只能在第一个字符、第二个字符、第三个字符之后，而第二个点只能在第一个点后1-3个位置之内，第三个点只能在第二个点后1-3个位置之内，且要要求第三个点后的数字数量不能超过3，因为IP地址每位最多3位数字。

step 1：依次枚举这三个点的位置。
step 2：然后截取出四段数字。
step 3：比较截取出来的数字，不能大于255，且除了0以外不能有前导0，然后才能组装成IP地址加入答案中。

```
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param s string字符串 
# @return string字符串一维数组
#
class Solution:
    def restoreIpAddresses(self , s: str) -> List[str]:
        res = []
        n = len(s)
        i = 1
        #遍历IP的点可能的位置（第一个点）
        while i < 4 and i < n - 2: 
            j = i + 1
            #第二个点的位置
            while j < i + 4 and j < n - 1: 
                k = j + 1
                #第三个点的位置
                while k < j + 4 and k < n: 
                    #最后一段剩余数字不能超过3
                    if n - k >= 4: 
                        k += 1
                        continue 
                    #从点的位置分段截取
                    a = s[0: i]
                    b = s[i: j]
                    c = s[j: k]
                    d = s[k:]
                    #IP每个数字不大于255
                    if int(a) > 255 or int(b) > 255 or int(c) > 255 or int(d) > 255: 
                        k += 1
                        continue
                    #排除前导0的情况
                    if (len(a) != 1 and a[0] == '0') or (len(b) != 1 and b[0] == '0') or  (len(c) != 1 and c[0] == '0') or (len(d) != 1 and d[0] == '0'):
                        k += 1
                        continue
                    #组装IP地址
                    temp = a + "." + b + "." + c + "." + d 
                    res.append(temp)
                    k += 1
                j += 1
            i += 1
        return res
```

复杂度分析：

时间复杂度：如果将3看成常数，则复杂度为 O(1) ，如果将3看成字符串长度的1/4，则复杂度为 O(n^3) ，三次嵌套循环
空间复杂度：如果将3看成常数，则复杂度为 O(1) ，如果将3看成字符串长度的1/4，则复杂度为 O(n) ，4个记录截取字符串的临时变量。res属于返回必要空间。

方法二：递归+回溯（扩展思路）
具体做法：

我们也可以使用递归和回溯将点插入数字中。

step 1：使用step记录分割出的数字个数，index记录递归的下标，结束递归是指step已经为4，且下标到达字符串末尾。
step 2：在主体递归中，每次加入一个字符当数字，最多可以加入三个数字，剩余字符串进入递归构造下一个数字。
step 3：然后要检查每次的数字是否合法（不超过255且没有前导0）.
step 4：合法IP需要将其连接，同时递归完这一轮后需要回溯。

```
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param s string字符串 
# @return string字符串一维数组
#
class Solution:
    def __init__(self):
        self.res = []
        self.s = ""
        self.nums = ""
    #step表示第几个数字，index表示字符串下标
    def dfs(self, step: int, index: int): 
        #当前分割出的字符串
        cur = "" 
        #分割出了四个数字
        if step == 4: 
            #下标必须走到末尾
            if index != len(self.s): 
                return
            self.res.append(self.nums)
        else:
            i = index
            #最长遍历3位
            while i < index + 3 and i < len(self.s): 
                cur += self.s[i]
                #转数字比较
                num = int(cur) 
                temp = self.nums
                #不能超过255且不能有前导0
                if num <= 255 and (len(cur) == 1 or cur[0] != '0'): 
                    #添加点
                    if step - 3 != 0: 
                        self.nums += cur + "."
                    else:
                        self.nums += cur
                    #递归查找下一个数字
                    self.dfs(step + 1, i + 1) 
                    #回溯
                    self.nums = temp 
                i += 1
    def restoreIpAddresses(self , s: str) -> List[str]:
        self.s = s
        self.dfs(0, 0)
        return self.res
```

复杂度分析：

时间复杂度： O(3^n) ，3个分枝的树型递归
空间复杂度： O(n) ，递归栈深度为 n 

### BM75. 编辑距离(一)

题目主要信息:
给定两个长度可能不同的字符串，可以对第一个字符串增删改字符
求增删改的最少次数，让第一个字符串变成第二个字符串
字符串中只出现大小写字母
方法：动态规划（推荐使用）
具体做法：

把第一个字符串变成第二个字符串，我们需要逐个将第一个字符串的子串最少操作下变成第二个字符串，这就涉及了第一个字符串增加长度，状态转移，那可以考虑动态规划。用dp[i] [j]表示从两个字符串首部各自到str1[i]和str2[j]为止的子串需要的编辑距离，那很明显dp[str1.length] [str2.length]就是我们要求的编辑距离。（下标从1开始）

step 1：初始条件： 假设第二个字符串为空，那很明显第一个字符串子串每增加一个字符，编辑距离就加1，这步操作是删除；同理，假设第一个字符串为空，那第二个字符串每增加一个字符，编剧距离就加1，这步操作是添加。
step 2：状态转移： 状态转移肯定是将dp矩阵填满，那就遍历第一个字符串的每个长度，对应第二个字符串的每个长度。如果遍历到str1[i]和	str2[j]的位置，这两个字符相同，这多出来的字符就不用操作，操作次数与两个子串的前一个相同，因此有dp[i] [j] = dp[i-1] [j-1]；如果这两个字符不相同，那么这两个字符需要编辑，但是此时的最短的距离不一定是修改这最后一位，也有可能是删除某个字符或者增加某个字符，因此我们选取这三种情况的最小值增加一个编辑距离，即dp[i] [j]=min(dp[i−1] [j−1],min(dp[i−1] [j],dp[i] [j−1]))+1。

```
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param str1 string字符串 
# @param str2 string字符串 
# @return int整型
#
class Solution:
    def editDistance(self , str1: str, str2: str) -> int:
        n1 = len(str1)
        n2 = len(str2)
        #dp[i][j]表示到str1[i]和str2[j]为止的子串需要的编辑距离
        dp = [[0] * (n2 + 1) for i in range(n1 + 1)] 
        #初始化边界
        for i in range(1, n1 + 1): 
            dp[i][0] = dp[i - 1][0] + 1
        for i in range(1, n2 + 1):
            dp[0][i] = dp[0][i - 1] + 1
        #遍历第一个字符串的每个位置
        for i in range(1, n1 + 1): 
            #对应第二个字符串每个位置
            for j in range(1, n2 + 1): 
                #若是字符相同，此处不用编辑
                if str1[i - 1] == str2[j - 1]: 
                    #直接等于二者前一个的距离
                    dp[i][j] = dp[i - 1][j - 1] 
                else:
                    #选取最小的距离加上此处编辑距离1
                    dp[i][j] = min(dp[i - 1][j - 1], min(dp[i - 1][j], dp[i][j - 1])) + 1 
        return dp[n1][n2]
```

复杂度分析：

时间复杂度： O(mn) ，其中 m 、 n 分别为两个字符串的长度，初始化dp数组单独遍历两个字符串，后续动态规划过程两层遍历
空间复杂度： o(mn) ，辅助数组dp的空间

### BM76. 正则表达式匹配

题目主要信息:
一个正常字符串str，可能为空，只包含小写字母
一个模式串pattern，可能为空，只包含小写字母和‘ * ’与‘ . ’
模式中的字符'.'表示任意一个字符，而'*'表示它前面的字符可以出现任意次（包含0次）
求str与pattern是否能完全匹配
方法：动态规划（推荐使用）
具体做法：

如果是只有小写字母，那么直接比较字符是否相同即可匹配，如果再多一个'.'，可以用它匹配任意字符，只要对应str中的元素不为空就行了。但是多了'*'字符，它的情况有多种，涉及状态转移，因此我们用动态规划。

step 1：设dp[i] [j]表示str前i个字符和pattern前j个字符是否匹配。（需要注意这里的i，j是长度，比对应的字符串下标要多1）

step 2： （初始条件） 首先，毋庸置疑，两个空串是直接匹配，因此dp[0] [0]=true。然后我们假设str字符串为空，那么pattern要怎么才能匹配空串呢？答案是利用' * '字符出现0次的特性。遍历pattern字符串，如果遇到'*'意味着它前面的字符可以出现0次，要想匹配空串也只能出现0，那就相当于考虑再前一个字符是否能匹配，因此 dp[0] [i] = dp[0] [i-2] 。

step 3： （状态转移） 然后分别遍历str与pattern的每个长度，开始寻找状态转移。首先考虑字符不为' * '的简单情况，只要遍历到的两个字符相等，或是pattern串中为'.'即可匹配，因此最后一位匹配，即查看二者各自前一位是否能完成匹配，即 dp[i] [j] = dp[i-1] [j-1] 。然后考虑'*'出现的情况：

pattern[j - 2] == '.' || pattern[j - 2] == str[i - 1]：即pattern前一位能够多匹配一位，可以用'*'让它多出现一次或是不出现，因此有转移方程dp[i] [j]=dp[i−1] [j]∣∣dp[i] [j−2]
不满足上述条件，只能不匹配，让前一个字符出现0次，dp[i] [j]=dp[i] [j−2].

```
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param str string字符串 
# @param pattern string字符串 
# @return bool布尔型
#
class Solution:
    def match(self , str: str, pattern: str) -> bool:
        n1 = len(str)
        n2 = len(pattern)
        #dp[i][j]表示str前i个字符和pattern前j个字符是否匹配
        dp = [[False] * (n2 + 1) for i in range(n1 + 1)]
        #两个都为空串自然匹配
        dp[0][0] = True 
        #初始化str为空的情况，字符串下标从1开始
        for i in range(2, n2 + 1): 
            #可以让自己前面个字符重复0次
            if pattern[i - 1] == '*': 
                #与再前一个能够匹配空串有关
                dp[0][i] = dp[0][i - 2] 
        #遍历str每个长度
        for i in range(1, n1 + 1): 
            #遍历pattern每个长度
            for j in range(n2 + 1): 
                #当前字符不为*，用.去匹配或者字符直接相同
                if pattern[j - 1] != '*' and (pattern[j - 1] == '.' or pattern[j - 1] == str[i - 1]): 
                      dp[i][j] = dp[i - 1][j - 1]
                #当前的字符为*
                elif j >= 2 and pattern[j - 1] == '*': 
                    #若是前一位为.或者前一位可以与这个数字匹配
                    if pattern[j - 2] == '.' or pattern[j - 2] == str[i - 1]: 
                        #转移情况
                        dp[i][j] = dp[i - 1][j] or dp[i][j - 2] 
                    else:
                        #不匹配
                        dp[i][j] = dp[i][j - 2] 
        return dp[n1][n2]
```

复杂度分析：

时间复杂度： O(mn) ，其中 m 和 n 分别为字符串和模版串的长度，初始化遍历矩阵一边，状态转移遍历整个dp矩阵
空间复杂度： O(mn) ，动态规划辅助数组dp的空间

### BM77. 最长的括号子串

题目主要信息：
一个长度为n的仅包含左右括号的字符串
计算最长的格式正确的括号子串的长度
方法一：栈（推荐使用）
具体做法：

因为括号需要一一匹配，而且先来的左括号，只能匹配后面的右括号，因此可以考虑使用栈的先进后出功能，使括号匹配。

step 1：可以使用栈来记录左括号下标。
step 2：遍历字符串，左括号入栈，每次遇到右括号则弹出左括号的下标。
step 3：然后长度则更新为当前下标与栈顶下标的距离。
step 4：遇到不符合的括号，可能会使栈为空，因此需要使用start记录上一次结束的位置，这样用当前下标减去start即可获取长度，即得到子串。
step 5：循环中最后维护子串长度最大值。

```
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param s string字符串 
# @return int整型
#
class Solution:
    def longestValidParentheses(self , s: str) -> int:
        res = 0
        #记录上一次连续括号结束的位置
        start = -1 
        st = []
        for i in range(len(s)):
            #左括号入栈
            if s[i] == '(': 
                st.append(i)
            #右括号
            else: 
                #如果右括号时栈为空，不合法，设置为结束位置
                if len(st) == 0: 
                    start = i
                else:
                    #弹出左括号
                    st.pop()
                    #栈中还有左括号，说明右括号不够，减去栈顶位置就是长度
                    if len(st) != 0: 
                        res = max(res, i - st[-1])
                    #栈中没有括号，说明左右括号行号，减去上一次结束的位置就是长度
                    else: 
                        res = max(res, i - start)
        return res
```

复杂度分析：

时间复杂度： O(n) ，其中 n 为字符串长度，遍历整个字符串
空间复杂度： O(n) ，最坏全是左括号，栈的大小为 n 

方法二：动态规划（扩展思路）
具体做法：

像这种子串长度的题，一般都涉及状态转移，可以用动态规划的方式。

step 1：用表示以下标为i的字符为结束点的最长合法括号长度。

step 2：很明显知道左括号不能做结尾，因此但是左括号都是。

step 3：我们遍历字符串，因为第一位不管是左括号还是右括号dp数组都是0，因此跳过，后续只查看右括号的情况，右括号有两种情况：

情况一：左括号隔壁是右括号，那么合法括号需要增加2，可能是这一对括号之前的基础上加，也可能这一对就是起点，因此转移公式为：

情况二：与该右括号匹配的左括号不在自己旁边，而是它前一个合法序列之前，因此通过下标减去它前一个的合法序列长度即可得到最前面匹配的左括号，因此转移公式为：$dp[i] = (i - dp[i - 1] > 1 ? dp[i - dp[i - 1] - 2] : 0) + dp[i - 1] + 2$
step 4：每次检查完维护最大值即可。

```
class Solution:
    def longestValidParentheses(self , s: str) -> int:
        res = 0
        #长度为0的串，返回0
        if len(s) == 0: 
            return res
        #dp[i]表示以下标为i的字符为结束点的最长合法括号长度
        dp = [0 for i in range(len(s))] 
        #第一位不管是左括号还是右括号都是0，因此不用管
        for i in range(1, len(s)): 
            #取到左括号记为0，有右括号才合法
            if s[i] == ')': 
                #如果该右括号前一位就是左括号
                if s[i - 1] == '(': 
                    #计数+2
                    if i >= 2: 
                        dp[i] = dp[i - 2] + 2
                    else:
                        dp[i] = 2 
                #找到这一段连续合法括号序列前第一个左括号做匹配
                elif i - dp[i - 1] > 0 and s[i - dp[i - 1] - 1] == '(':
                    if i - dp[i - 1] > 1:
                        dp[i] = dp[i - dp[i - 1] - 2] + dp[i - 1] + 2
                    else:
                        dp[i] = dp[i - 1] + 2
            #维护最大值
            res = max(res, dp[i]) 
        return res
```

复杂度分析：

时间复杂度： O(n) ，其中 n 为字符串长度，遍历一次字符串
空间复杂度： O(n) ，动态规划辅助数组的长度为 n 

```
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param s string字符串 
# @return int整型
#
class Solution:
    def longestValidParentheses(self , s: str) -> int:
        res = 0
        #长度为0的串，返回0
        if len(s) == 0: 
            return res
        #dp[i]表示以下标为i的字符为结束点的最长合法括号长度
        dp = [0 for i in range(len(s))] 
        #第一位不管是左括号还是右括号都是0，因此不用管
        for i in range(1, len(s)): 
            #取到左括号记为0，有右括号才合法
            if s[i] == ')': 
                #如果该右括号前一位就是左括号
                if s[i - 1] == '(': 
                    #计数+2
                    if i >= 2: 
                        dp[i] = dp[i - 2] + 2
                    else:
                        dp[i] = 2 
                #找到这一段连续合法括号序列前第一个左括号做匹配
                elif i - dp[i - 1] > 0 and s[i - dp[i - 1] - 1] == '(':
                    if i - dp[i - 1] > 1:
                        dp[i] = dp[i - dp[i - 1] - 2] + dp[i - 1] + 2
                    else:
                        dp[i] = dp[i - 1] + 2
            #维护最大值
            res = max(res, dp[i]) 
        return res
```

复杂度分析：

时间复杂度： O(n) ，其中 n 为字符串长度，遍历一次字符串
空间复杂度： O(n) ，动态规划辅助数组的长度为 n 

### BM78. 打家劫舍(一)

题目主要信息:
给定一个数组，其中代表每家拥有的钱数
小偷每次不能偷取数组中相邻位置的钱，只要不相邻的钱都可以偷
求最多能偷到钱数
方法：动态规划（推荐使用）
具体做法：

或许有人认为利用贪心思想，偷取最多人家的钱就可以了，要么偶数家要么奇数家全部的钱，但是有时候会为了偷取更多的钱，或许可能会连续放弃两家不偷，因此这种方案行不通，我们依旧考虑动态规划。

step 1：用dp[i]表示长度为i的数组，最多能偷取到多少钱，只要每次转移状态逐渐累加就可以得到整个数组能偷取的钱。
step 2：（初始状态） 如果数组长度为1，只有一家人，肯定是把这家人偷了，收益最大，因此dp[1]=nums[0]。
step 3：（状态转移） 每次对于一个人家，我们选择偷他或者不偷他，如果我们选择偷那么前一家必定不能偷，因此累加的上上级的最多收益，同理如果选择不偷他，那我们最多可以累加上一级的收益。因此转移方程为dp[i]=max(dp[i−1],nums[i−1]+dp[i−2])。这里的i在dp中为数组长度，在nums中为下标。

```
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param nums int整型一维数组 
# @return int整型
#
class Solution:
    def rob(self , nums: List[int]) -> int:
        #dp[i]表示长度为i的数组，最多能偷取多少钱
        dp = [0 for i in range(len(nums) + 1)] 
        #长度为1只能偷第一家
        dp[1] = nums[0] 
        for i in range(2, len(nums) + 1):
            #对于每家可以选择偷或者不偷
            dp[i] = max(dp[i - 1], nums[i - 1] + dp[i - 2]) 
        return dp[len(nums)]
```

复杂度分析：

时间复杂度： O(n) ，其中 n 为数组长度，遍历一次数组
空间复杂度： O(n) ，动态规划辅助数组的空间

### BM79. 打家劫舍(二)

题目主要信息:
给定一个数组，其中代表每家拥有的钱数
小偷每次不能偷取数组中相邻位置的钱，只要不相邻的钱都可以偷
数组形成环形，第一家与最后一家相邻
求最多能偷到钱数
方法：动态规划（推荐使用）
具体做法：

这道题与打家劫舍（一）比较类似，区别在于这道题是环形，第一家和最后一家是相邻的，既然如此，在原先的方案中第一家和最后一家不能同时取到。

step 1：使用原先的方案是：用dp[i]表示长度为i的数组，最多能偷取到多少钱，只要每次转移状态逐渐累加就可以得到整个数组能偷取的钱。

step 2：（初始状态） 如果数组长度为1，只有一家人，肯定是把这家人偷了，收益最大，因此dp[1]=nums[0]dp[1] = nums[0]dp[1]=nums[0]。

step 3：（状态转移） 每次对于一个人家，我们选择偷他或者不偷他，如果我们选择偷那么前一家必定不能偷，因此累加的上上级的最多收益，同理如果选择不偷他，那我们最多可以累加上一级的收益。因此转移方程为dp[i]=max(dp[i−1],nums[i−1]+dp[i−2])。这里的i在dp中为数组长度，在nums中为下标。

step 4：此时第一家与最后一家不能同时取到，那么我们可以分成两种情况讨论：

情况1：偷第一家的钱，不偷最后一家的钱。初始状态与状态转移不变，只是遍历的时候数组最后一位不去遍历。
情况2：偷最后一家的请，不偷第一家的钱。初始状态就设定了dp[1]=0，第一家就不要了，然后遍历的时候也会遍历到数组最后一位。
step 5：最后取两种情况的较大值即可。

```
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param nums int整型一维数组 
# @return int整型
#
class Solution:
    def rob(self , nums: List[int]) -> int:
        #dp[i]表示长度为i的数组，最多能偷取多少钱
        dp1 = [0 for i in range(len(nums) + 1)] 
        #选择偷了第一家
        dp1[1] = nums[0] 
        #最后一家不能偷
        for i in range(2, len(nums)): 
            #对于每家可以选择偷或者不偷
            dp1[i] = max(dp1[i - 1], nums[i - 1] + dp1[i - 2]) 
        res = dp1[len(nums) - 1]; 
        #第二次循环
        dp2 = [0 for i in range(len(nums) + 1)] 
        #不偷第一家
        dp2[1] = 0 
        #可以偷最后一家
        for i in range(2, len(nums) + 1): 
            #对于每家可以选择偷或者不偷
            dp2[i] = max(dp2[i - 1], nums[i - 1] + dp2[i - 2]) 
            #选择最大值
        return max(res, dp2[len(nums)]) 
```

复杂度分析：

时间复杂度： O(n) ，其中 n 为数组长度，单独遍历两次数组
空间复杂度： O(n) ，动态规划辅助数组的空间

### BM80. 买卖股票的最好时机(一)

题目主要信息：
给出一个数组表示连续多日的股票价格
你可以选择在某一天买入股票，在另一天卖出股票，买卖都只有一次机会，不能在同一天
假设买卖没有手续费，问最高收益是多少，即卖出的价格减去买入的价格，如果没有利润需要返回0
可以看成查找数组中b-a的最大值，其中b必须在a的后面
方法一：动态规划（推荐使用）
具体做法：

对于每天有到此为止的最大收益和是否持股两个状态，因此我们可以用动态规划。

step 1：用dp[i] [0]表示第i天不持股到该天为止的最大收益，dp[i] [1]表示第i天持股，到该天为止的最大收益。
step 2：（初始状态） 第一天不持股，则总收益为0，dp[0] [0]=0；第一天持股，则总收益为买股票的花费，此时为负数，dp[0] [1]=−prices[0]。
step 3：（状态转移） 对于之后的每一天，如果当天不持股，有可能是前面的若干天中卖掉了或是还没买，因此到此为止的总收益和前一天相同，也有可能是当天才卖掉，我们选择较大的状态dp[i] [0]=max(dp[i−1] [0],dp[i−1] [1]+prices[i]) ；
step 4：如果当天持股，有可能是前面若干天中买了股票，当天还没卖，因此收益与前一天相同，也有可能是当天买入，此时收益为负的股价，同样是选取最大值：dp[i] [1]=max(dp[i−1] [1],−prices[i])。

```
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param prices int整型一维数组 
# @return int整型
#
class Solution:
    def maxProfit(self , prices: List[int]) -> int:
        n = len(prices)
        #dp[i][0]表示某一天不持股到该天为止的最大收益，dp[i][1]表示某天持股，到该天为止的最大收益
        dp = [[0] * 2 for i in range(n)] 
        #第一天不持股，总收益为0
        dp[0][0] = 0 
        #第一天持股，总收益为减去该天的股价
        dp[0][1] = -prices[0] 
        #遍历后续每天，状态转移
        for i in range(1, n): 
            dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i])
            dp[i][1] = max(dp[i - 1][1], -prices[i])
        #最后一天不持股，到该天为止的最大收益
        return dp[n - 1][0] 
```

复杂度分析：

时间复杂度： O(n) ，其中 n 为数组长度，遍历一次数组
空间复杂度： O(n) ，动态规划辅助数组的空间

方法二：贪心（扩展思路）
具体做法：

如果我们在某一天卖出了股票，那么要想收益最高，一定是它前面价格最低的那天买入的股票才可以。因此我们可以利用贪心思想解决，每次都将每日收入与最低价格相减维护最大值。

step 1：首先排除数组为空的特殊情况。
step 2：将第一天看成价格最低，后续遍历的时候遇到价格更低则更新价格最低，每次都比较最大收益与当日价格减去价格最低的值，选取最大值作为最大收益。

```
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param prices int整型一维数组 
# @return int整型
#
class Solution:
    def maxProfit(self , prices: List[int]) -> int:
        #维护最大收益
        res = 0 
        #排除特殊情况
        if len(prices) == 0: 
            return res
        #维护最低股票价格
        Min = prices[0] 
        #遍历后续股票价格
        for i in range(1, len(prices)): 
            #如果当日价格更低则更新最低价格
            Min = min(Min, prices[i]) 
            #维护最大值
            res = max(res, prices[i] - Min) 
        return res
```

复杂度分析：

时间复杂度： O(n) ，其中 n 为数组长度，一次遍历数组
空间复杂度： O(1) ，常数级变量，无额外辅助空间

### BM81. 买卖股票的最好时机(二)

题目主要信息：
给出一个数组表示连续多日的股票价格
你可以选择在某一天买入股票，在另一天卖出股票，买卖可以有多次机会，但是同一天只能买或者只能卖
假设买卖没有手续费，问最高收益是多少，即卖出的价格减去买入的价格，如果没有利润需要返回0
方法一：动态规划(推荐使用)
具体做法：

这道题与买卖股票的最好时机（一）的区别在于可以多次买入卖出。
但是对于每天还是有到此为止的最大收益和是否持股两个状态，因此我们照样可以用动态规划。

step 1：用dp[i] [0]表示第i天不持股到该天为止的最大收益， dp[i] [1] 表示第i天持股，到该天为止的最大收益。
step 2：（初始状态） 第一天不持股，则总收益为0，dp[0] [0]=0；第一天持股，则总收益为买股票的花费，此时为负数，dp[0] [1]=−prices[0]。
step 3：（状态转移） 对于之后的每一天，如果当天不持股，有可能是前面的若干天中卖掉了或是还没买，因此到此为止的总收益和前一天相同，也有可能是当天卖掉股票，我们选择较大的状态dp[i] [0]=max(dp[i−1] [0],dp[i−1] [1]+prices[i])；
step4：如果当天持股，可能是前几天买入的还没卖，因此收益与前一天相同，也有可能是当天买入，减去买入的花费，同样是选取最大值：dp[i] [1]=max(dp[i−1] [1],dp[i−1] [0]−prices[i])。

```
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 计算最大收益
# @param prices int整型一维数组 股票每一天的价格
# @return int整型
#
class Solution:
    def maxProfit(self , prices: List[int]) -> int:
        n = len(prices)
        #dp[i][0]表示某一天不持股到该天为止的最大收益，dp[i][1]表示某天持股，到该天为止的最大收益
        dp = [[0] * 2 for i in range(n)] 
        #第一天不持股，总收益为0
        dp[0][0] = 0 
        #第一天持股，总收益为减去该天的股价
        dp[0][1] = -prices[0] 
        #遍历后续每天，状态转移
        for i in range(1, n): 
            dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i])
            dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i])
        #最后一天不持股，到该天为止的最大收益
        return dp[n - 1][0] 
```

复杂度分析：

时间复杂度： O(n) ，其中 n 为数组长度，遍历一次数组
空间复杂度： O(n) ，动态规划辅助数组相当于两个一维数组

方法二：贪心（扩展思路）
具体做法：

其实我们要想获取最大收益，只需要在低价买入高价卖出就可以了，因为可以买卖多次。利用贪心思想：只要一段区间内价格是递增的，那么这段区间的差值就是我们可以有的收益。

step 1：遍历数组，只要数组后一个比前一个更大，就可以有收益。
step 2：将收益累加。

```
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 计算最大收益
# @param prices int整型一维数组 股票每一天的价格
# @return int整型
#
class Solution:
    def maxProfit(self , prices: List[int]) -> int:
        res = 0
        for i in range(1, len(prices)):
            #只要某段在递增就有收益
            if prices[i - 1] < prices[i]: 
                #收益累加
                res += prices[i] - prices[i - 1] 
        return res
```

复杂度分析：

时间复杂度： O(n) ，其中 n 为数组长度，遍历一次数组
空间复杂度： O(1) ，常数级变量，没有使用额外辅助空间

### BM82. 买卖股票的最好时机(三)

题目主要信息:
给出一个数组表示连续多日的股票价格
你可以选择在某一天买入股票，在另一天卖出股票，可以最多买入两次卖出两次，但是第二次买入必须在第一次卖出后，且每天只能进行一次操作
假设买卖没有手续费，问最高收益是多少，即卖出的价格减去买入的价格，如果没有利润需要返回0
方法：动态规划(推荐使用)
具体做法：

这道题与买卖股票的最好时机（一）的区别在于最多可以买入卖出2次，那实际上相当于它的状态多了几个，对于每天有到此为止的最大收益和持股情况两个状态，持股情况有了5种变化，我们用：

dp[i] [0]表示到第i天为止没有买过股票的最大收益
dp[i] [1]表示到第i天为止买过一次股票还没有卖出的最大收益
dp[i] [2]表示到第i天为止买过一次也卖出过一次股票的最大收益
dp[i] [3]表示到第i天为止买过两次只卖出过一次股票的最大收益
dp[i] [4]表示到第i天为止买过两次同时也买出过两次股票的最大收益
于是使用动态规划，有了如下的状态转移：

step 1：（初始状态） 与上述提到的题类似，第0天有买入了和没有买两种状态：dp[0] [0]=0、dp[0] [1]=−prices[0] 。
step 2：状态转移： 对于后续的每一天，如果当天还是状态0，则与前一天相同，没有区别；
step 3：如果当天状态为1，可能是之前买过了或者当天才第一次买入，选取较大值：dp[i] [1]=max(dp[i−1] [1],dp[i−1] [0]−prices[i])；
step 4：如果当天状态是2，那必须是在1的状态下（已经买入了一次）当天卖出第一次，或者早在之前就卖出只是还没买入第二次，选取较大值：dp[i] [2]=max(dp[i−1] [2],dp[i−1] [1]+prices[i])；
step 5：如果当天状态是3，那必须是在2的状态下（已经卖出了第一次）当天买入了第二次，或者早在之前就买入了第二次，只是还没卖出，选取较大值：dp[i] [3]=max(dp[i−1] [3],dp[i−1] [2]−prices[i]);
step 6：如果当天是状态4，那必须是在3的状态下（已经买入了第二次）当天再卖出第二次，或者早在之前就卖出了第二次，选取较大值：dp[i] [4]=max(dp[i−1] [4],dp[i−1] [3]+prices[i])。
step 7：最后我们还要从0、第一次卖出、第二次卖出中选取最大值，因为有可能没有收益，也有可能只交易一次收益最大。

```
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 两次交易所能获得的最大收益
# @param prices int整型一维数组 股票每一天的价格
# @return int整型
#
class Solution:
    def maxProfit(self , prices: List[int]) -> int:
        n = len(prices)
        #初始化dp为最小
        dp = [[-10000] * 5 for i in range(n)] 
        #第0天不持有状态
        dp[0][0] = 0 
        #第0天持有股票
        dp[0][1] = -prices[0] 
        #状态转移
        for i in range(1, n): 
            dp[i][0] = dp[i - 1][0]
            dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i])
            dp[i][2] = max(dp[i - 1][2], dp[i - 1][1] + prices[i])
            dp[i][3] = max(dp[i - 1][3], dp[i - 1][2] - prices[i])
            dp[i][4] = max(dp[i - 1][4], dp[i - 1][3] + prices[i])
        #选取最大值，可以只操作一次
        return max(dp[n - 1][2], max(0, dp[n - 1][4])) 
```

复杂度分析：

时间复杂度： O(n) ，其中 n 为数组长度，只遍历一次数组
空间复杂度： O(n) ，动态规划二维辅助相当于5个一维数组

## 08字符串

### BM83. 字符串变形

题目主要信息：
将字符串大小写反转，这个遍历字符串即可，也在O(n)以内
反转单词的位置
方法一：双逆转（推荐使用)
具体做法：

step 1：第一次反转整个字符串，这样基本的单词逆序就有了，但是每个单词的字符也是逆的。
step 2：第二次遍历字符串的同时反转每个单词。

```
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param s string字符串 
# @param n int整型 
# @return string字符串
#
class Solution:
    def trans(self , s: str, n: int) -> str:
        if n==0:
            return s
        res = ""
        for i in range(n):
            #大小写转换
            if s[i] <= 'Z' and s[i] >= 'A':  
                res += chr(ord(s[i]) - ord('A') + ord('a'))
            elif s[i] >= 'a' and s[i] <= 'z':
                res += chr(ord(s[i]) - ord('a') + ord('A'))
            else :
                #空格直接复制
                res+=s[i]  
        #单词反序
        res = list(res.split(' '))[::-1]
        print(res)
        return ' '.join(res)
```

复杂度分析：

时间复杂度： O(n) ，虽有多个循环，但是每个循环都只有一层 O(n) 
空间复杂度： O(n) ，res是存储变换的临时字符串，也可以直接用s直接变换，这样就为 O(1) 

方法二：分割字符串+栈（扩展思路）
具体做法：

题目要求将单词逆序，逆序就可以相当先进后出的栈。

step 1：按照空格把字符串分割成一个个单词
step 2：将单词存入栈中，再从栈中弹出可以做到单词逆序。

```
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param s string字符串 
# @param n int整型 
# @return string字符串
#
class Solution:
    def trans(self , s: str, n: int) -> str:
        if n==0: 
            return s
        res = str()
        for i in range(n):
            #大小写转换
            if s[i] <= 'Z' and s[i] >= 'A':   
                res += chr(ord(s[i]) - ord('A') + ord('a'))
            elif s[i] >= 'a' and s[i] <= 'z' :
                res += chr(ord(s[i]) - ord('a') + ord('A'))
            else :
                #空格直接复制
                res+=s[i] 
        temp = list()
        i = 0
        while i < n:
            j = i
            #以空格为界，分割单词
            while j < n and res[j] != ' ': 
                j += 1
            #单词进栈
            temp.append(res[i:j])  
            i = j
            i += 1
        #排除结尾空格的特殊情况  
        if s[n - 1] == ' ':  
            res = " "
        else:
            res = ""
        #栈遵循先进后厨，单词顺序是反的
        while len(temp) != 0:   
            res += temp[-1]
            temp.pop()
            if len(temp) != 0:
                res += " "
        return res
```

复杂度分析：

时间复杂度： O(n) ，所有循环最多遍历一次
空间复杂度： O(n) ，栈空间的大小最坏为 O(n) 

### BM84. 最长公共前缀

题目主要信息:
给定一个字符串数组，其中有n个字符串，求所有字符串的最长公共前缀
公共前缀是指所有字符串都共有的前面部分的子串，从第一个字符开始
方法：遍历查找(推荐使用)
具体做法：

既然是公共前缀，那我们可以从第一个字符开始，逐位比较，找到最长公共子串。

step 1：处理数组为空的特殊情况。
step 2：因为最长公共前缀的长度不会超过任何一个字符串的长度，因此我们逐位就以第一个字符串为标杆，遍历第一个字符串的所有位置，取出字符。
step 3：遍历数组中后续字符串，依次比较其他字符串中相应位置是否为刚刚取出的字符，如果是，循环继续，继续查找，如果不是或者长度不足，说明从第i位开始不同，前面的都是公共前缀。
step 4：如果遍历结束都相同，最长公共前缀最多为第一个字符串。

```
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param strs string字符串一维数组 
# @return string字符串
#
class Solution:
    def longestCommonPrefix(self , strs: List[str]) -> str:
        n = len(strs)
        #空字符串数组
        if n == 0: 
            return ""
        #遍历第一个字符串的长度
        for i in range(len(strs[0])): 
            temp = strs[0][i]
            #遍历后续的字符串
            for j in range(1,n): 
                #比较每个字符串该位置是否和第一个相同
                if i == len(strs[j]) or strs[j][i] != temp: 
                    #不相同则结束
                    return strs[0][0:i] 
        #后续字符串有整个字一个字符串的前缀
        return strs[0] 
```

复杂度分析：

时间复杂度： O(mn) ，其中 m 为数组中最短的字符串的长度， n 为字符串数组的长度，两层遍历循环
空间复杂度： O(1) ，常数级变量，没有使用额外的辅助空间

### BM85. 验证IP地址

题目主要信息：
IPv4只有十进制数和分割点，其中数字在0-255之间，共4组，且不能有零开头的非零数，不能缺省
IPv6由8组16进制数组成，会出现a-fA-F，通过冒号分割，不可缺省，可以零开头，或者为一个单独零，每组最多4位。
方法一：分割字符串比较法（推荐使用）
我们可以先对IP字符串进行分割，然后依次判断每个分割是否符合要求。

具体做法：

step 1：写一个split函数（或者java内置）。
step 2：遍历IP字符串，遇到.或者:将其分开储存在一个数组中。
step 3：遍历数组，判断其中每个字符串是否符合上述要求。

```
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 验证IP地址
# @param IP string字符串 一个IP地址字符串
# @return string字符串
#
class Solution:
    def isIPv4 (self, IP:str):
        s = IP.split('.')  
        #IPv4必定为4组
        if len(s)!= 4:  
            return False
        for i in range(len(s)):
            #不可缺省，有一个分割为零，说明两个点相连
            if len(s[i])==0:  
                return False
            #比较数字位数及不为零时不能有前缀零
            if len(s[i]) < 0 or len(s[i]) > 3 or (s[i][0]=='0' and len(s[i]) != 1):
                return False
            #遍历每个分割字符串，必须为数字
            for j in range(len(s[i])): 
                if s[i][j]<'0' or s[i][j]>'9':
                    return False
            #转化为数字比较，0-255之间
            num = int(s[i]) 
            if  num < 0 or num > 255:
                return False
        return True
    
    def isIPv6 (self, IP:str):
        s = IP.split(':') 
        #IPv6必定为8组
        if len(s) != 8: 
            return False
        for i in range(len(s)):
            #每个分割不能缺省，不能超过4位
            if len(s[i]) == 0 or len(s[i]) > 4:  
                return False
            for j in range(len(s[i])):
                #不能出现a-fA-F以外的大小写字符
                if not (s[i][j].isdigit() or s[i][j] >= 'a' and s[i][j] <= 'f' or s[i][j] >='A' and s[i][j] <= 'F'):
                    return False
        return True
    
    def solve(self , IP: str) -> str:
        if len(IP) == 0:
            return "Neither"
        if Solution.isIPv4(self, IP):
            return "IPv4"
        elif Solution.isIPv6(self, IP):
            return "IPv6"
        return "Neither"
```

复杂度分析：

时间复杂度： O(n) ，n为字符串IP的长度，判断部分只遍历4组或者8组，但是分割字符串需要遍历全部
空间复杂度： O(1) ，储存分割字符串的临时空间为常数4或者8

方法二：正则表达式（扩展思路）
具体做法：

stpe 1：IP地址是有规律可言的，我们可以直接用正则表达式来匹配。

```
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 验证IP地址
# @param IP string字符串 一个IP地址字符串
# @return string字符串
#
import re
class Solution:
    def solve(self , IP: str) -> str:
         #正则表达式限制0-255 且没有前缀0 四组齐全
        ipv4 = "(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])"
        #正则表达式限制出现8组，0-9a-fA-F的数，个数必须是1-4个
        ipv6 = "([0-9a-fA-F]{1,4}\:){7}([0-9a-fA-F]{1,4})$"
        ipv4 = re.compile(ipv4)
        ipv6 = re.compile(ipv6)
        #调用正则匹配函数
        if ipv4.match(IP): 
            return "IPv4"
        elif ipv6.match(IP):
            return "IPv6"
        else:
            return "Neither"
```

复杂度分析：

时间复杂度： O(n) ，regex_match函数默认 O(n) 
空间复杂度： O(1) ，没有使用额外空间

### BM86. 大数加法

题目主要信息:
以字符串形式读入两个正整数，返回其相加结果
结果也是字符串形式
字符串只有数字0-9
方法：模拟法（建议使用）
具体思路:

大整数相加，就可以按照整数相加的方式，从个位开始，逐渐往上累加，换到字符串中就是从两个字符串的末尾开始相加。

step 1：若是其中一个字符串为空，直接返回另一个，不用加了。
step 2：交换两个字符串的位置，我们是s为较长的字符串，t为较短的字符串，结果也记录在较长的字符串中。
step 3：从后往前遍历字符串s，每次取出字符转数字，加上进位制，将下标转换为字符串t中从后往前相应的下标，如果下标为非负数则还需要加上字符串t中相应字符转化的数字。
step 4：整型除法取进位，取模算法去掉十位，将计算后的结果放入较长数组对应位置。
step 5：如果遍历结束，进位值还有，则需要直接在字符串s前增加一个字符‘1’。

```
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 计算两个数之和
# @param s string字符串 表示第一个整数
# @param t string字符串 表示第二个整数
# @return string字符串
#
class Solution:
    def solve(self , s: str, t: str) -> str:
        #若是其中一个为空，返回另一个
        if len(s) == 0:
            return t
        if len(t) == 0:
            return s
        #让s为较长的，t为较短的
        if len(s) < len(t): 
            temp = t
            t = s
            s = temp
        #进位标志
        carry = 0 
        i = len(s) - 1
        #从后往前遍历较长的字符串
        while i>=0 :
            #转数字加上进位
            temp = ord(s[i]) - ord('0') + carry
            #转较短的字符串相应的从后往前的下标
            j = i - len(s) + len(t) 
            #如果较短字符串还有
            if j >= 0: 
                #转数组相加
                temp += ord(t[j]) - ord('0') 
            #取进位
            carry = int(temp / 10) 
            #去十位
            temp = temp % 10 
            s = s[:i] + chr(temp + ord('0')) + s[i+1:]
            i -= 1
        #最后的进位
        if carry == 1: 
            s = '1' + s
        return s
```

复杂度分析：

时间复杂度： O(n) ，其中 n 为较长字符的长度，遍历字符串
空间复杂度： O(1) ，常数级空间，没有使用额外辅助空间

## 09双指针

### BM87. 合并两个有序的数组

题目主要信息:
A与B是两个升序的整型数组，长度分别为 n 和 m 
需要将数组B的元素合并到数组A中，保证依旧是升序
数组A已经开辟了 m + n 的空间，只是前半部分存储的数组A的内容
方法：合并排序(推荐使用)
具体思路:

既然是两个已经排好序的数组，如果可以用新的辅助数组，那很容易我们可以借助归并排序的思想，将排好序的两个子数组合并到一起。但是这道题要求我们在数组A上面添加，那因为数组A后半部分相当于为空，则我们可以考虑逆向使用归并排序思想，从较大的开始排。

step 1：使用三个指针，i指向数组A的最大元素，j指向数组B的最大元素，k指向数组A空间的结尾处。
step 2：从两个数组最大的元素开始遍历，直到某一个结束，每次取出较大的一个值放入数组A空间的最后，然后指针一次往前。
step 3：如果数组B先遍历结束，数组A前半部分已经存在了，不用管；但是如果数组A先遍历结束，则需要把数组B剩余的前半部分依次逆序加入数组A前半部分，类似归并排序最后的步骤。

```
#
# 
# @param A int整型一维数组 
# @param B int整型一维数组 
# @return void
#
class Solution:
    def merge(self , A, m, B, n):
        #指向数组A的结尾
        i = m - 1 
        #指向数组B的结尾
        j = n - 1 
        #指向数组A空间的结尾处
        k = m + n - 1 
        #从两个数组最大的元素开始，直到某一个数组遍历完
        while i >= 0 and j >= 0: 
            #将较大的元素放到最后
            if A[i] > B[j]: 
                A[k] = A[i]
                k = k - 1
                i = i - 1
            else:
                A[k] = B[j]
                k = k - 1
                j = j - 1
        #数组A遍历完了，数组B还有，则还需要添加到数组A前面
        if i < 0: 
            while j >= 0:
                A[k] = B[j]
                k = k - 1
                j = j - 1
        #数组B遍历完了，数组A前面正好有，不用再添加
```

复杂度分析：

时间复杂度： O(n+m) ，其中 m 、 n 分别为两个数组的长度，最坏情况遍历整个数组A和数组B
空间复杂度： O(1) ，常数级变量，无额外辅助空间

### BM88. 判断是否为回文字符串

题目的主要信息：
判断字符串是否是回文字符
回文字符即首尾相互往中靠，字符都是相同的
方法一：首尾依次比较法（推荐使用）
具体做法：

step 1：两个指针，一个在字符串首，一个在字符串尾。
step 2：在首的指针往后走，在尾的指针往前走，依次比较路过的两个字符是否相等，直到两指针在中间相遇。（我们这里用下标代替指针）

```
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param str string字符串 待判断的字符串
# @return bool布尔型
#
class Solution:
    def judge(self , str: str) -> bool:
        #首指针
        left = 0 
        #尾指针
        right = len(str) - 1 
        #首尾往中间靠
        while left < right :
            #比较前后是否相同
            if str[left] != str[right] :
                return False
            left += 1
            right -= 1
        return True
```

复杂度分析：

时间复杂度： O(n) ，其中 n 为字符串长度，最多遍历半个字符串
空间复杂度： O(1) ，除了常数个临时变量，无额外辅助空间

方法二：反转字符串比较法（扩展思路）
具体做法：

step 1：因为回文字符串首尾部分相同，所以可以将其用reverse函数反转。
step 2：若是还是与原来的字符串相等，则是回文字符串。

```
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param str string字符串 待判断的字符串
# @return bool布尔型
#
class Solution:
    def judge(self , str: str) -> bool:
        temp = str
        #反转字符串
        str = str[::-1] 
        #比较字符串是否相等
        if temp == str:
            return True
        return False
```

复杂度分析：

时间复杂度： O(n) ，反转字符串和比较字符串都是 O(n) 
空间复杂度： O(n) ，辅助字符串temp记录原来的字符串

### BM89. 合并区间

题目主要信息:
给出一组区间，区间包括起始点，要求将重叠的区间合并
重叠后的区间按照起点位置升序排列
方法:排序比较(推荐使用)
具体思路:

step 1：既然要求重叠后的区间按照起点位置升序排列，我们就将所有区间按照起点位置先进行排序。使用sort函数进行排序，重载比较方式为比较interval结构的start变量。
step 2：排序后的第一个区间一定是起点值最小的区间，我们将其计入返回数组res，然后遍历后续区间。
step 3：后续遍历过程中，如果遇到起点值小于res中最后一个区间的末尾值的情况，那一定是重叠，取二者最大末尾值更新res中最后一个区间即可；如果遇到起点值大于res中最后一个区间的末尾值的情况，那一定没有重叠，后续也不会有这个末尾的重叠区间了，因为后面的起点只会更大，因此可以将它加入res。

```
# class Interval:
#     def __init__(self, a=0, b=0):
#         self.start = a
#         self.end = b
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param intervals Interval类一维数组 
# @return Interval类一维数组
#
from functools import cmp_to_key

class Solution:
    def merge(self , intervals: List[Interval]) -> List[Interval]:
        res = list()
        #去除特殊情况
        if len(intervals) == 0: 
            return res
        #按照区间首排序
        intervals.sort(key=cmp_to_key(lambda a,b:a.start - b.start))
        #放入第一个区间
        res.append(intervals[0]) 
        #遍历后续区间，查看是否与末尾有重叠
        for i in range(len(intervals)): 
            #区间有重叠，更新结尾
            if intervals[i].start <= res[-1].end: 
                res[-1].end = max(res[-1].end, intervals[i].end)
            #区间没有重叠，直接加入
            else: 
                res.append(intervals[i])
        return res
```

复杂度分析：

时间复杂度： O(nlog~2~n) ，排序的复杂度为 O(nlog~2~n) ，后续遍历所有区间的复杂度为 O(n) ，属于低次幂，忽略
空间复杂度： O(1) ，res为返回必要空间，没有使用额外辅助空间

### BM90. 最小覆盖子串

题目主要信息：
在S字符串中找到包含T字符串所有字符的最小连续子串
两个字符串仅包含大小写字母
如果S中没有包含T中所有字符的子串，返回空字符串""，若有，则存在唯一最短
方法：哈希表匹配（推荐使用）
具体思路：

step 1：字符串仅包含大小写字母，则字符集是已知且有限的，那这种情况下我们可以考虑使用哈希表——只需要维护一个哈希表，里面是字符串T的字符为key值，初始化时当字符在T中出现一次则value值减1，后续如果找到就可以将其加回来。
step 2：依次遍历字符串S，如果匹配则将哈希表中的相应的字符加1。
step 3：在遍历过程中维护一个窗口，如果哈希表中所有元素都大于0，意味着已经找全了，则窗口收缩向左移动，找最小的窗口，如果不满足这个条件则窗口右移继续匹配。窗口移动的时候需要更新最小窗口，以取得最短子串。
step 4：如果匹配到最后，窗口left（初始为-1）也没有右移，说明没有找到，返回空串即可。
step 5：最后使用字符串截取函数，截取刚刚记录下的窗口即可得到符合条件的最短子串。
因此，这道题中使用哈希表的一个重要条件是字符集是确定的。

```
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param S string字符串 
# @param T string字符串 
# @return string字符串
#
class Solution:
    #检查是否有小于0的
    def check(self, hash:dict()): 
        for key, value in hash.items():
            if value < 0:
                return False
        return True

    def minWindow(self , S: str, T: str) -> str:
        cnt = len(S) + 1
        #记录目标字符串T的字符个数
        hash = dict() 
        for i in range(len(T)):
            if T[i] in hash:
                #初始化哈希表都为负数，找的时候再加为正
                hash[T[i]] -= 1 
            else:
                hash[T[i]] = -1
        slow = 0
        fast = 0
        left = -1
        #记录左右区间
        right = -1 
        while fast < len(S):
            c = S[fast]
            #目标字符匹配+1
            if c in hash:
                hash[c] += 1
            #没有小于0的说明都覆盖了，缩小窗口
            while (Solution.check(self, hash)) :   
                #取最优解
                if  cnt > fast - slow + 1: 
                    cnt = fast - slow + 1
                    left = slow
                    right = fast
                c = S[slow]
                if c in hash:
                    #缩小窗口的时候减1
                    hash[c] -= 1 
                #窗口缩小
                slow += 1      
            fast += 1
        #找不到的情况
        if left == -1:    
            return ""
        return S[left:right+1]
```

复杂度分析：

时间复杂度： O(C*n_S+n_T) ，其中C为T字符串的字符集大小，本题中为52个字母， n_S 

 为字符串S的长度， n_T 为字符串T的长度

空间复杂度： O(C) ，哈希表长度不会超过字符串T的字符集大小

### BM91. 反转字符串

题目的主要信息：
输入一个只包含小写字母的字符串
输出该字符串反转后的字符串
方法一：双指针交换（推荐使用）
具体做法：

字符串反转即逆序，前后顺序是反的，那既然这样我们就将前后的顺序依次对称交换。

step 1：准备两个指针，从字符串一首一尾同时出发。
step 2：每次交换二者指向的字符，直到二者相遇，这样刚好可以将字符串首尾交换，完成反转。

```
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 反转字符串
# @param str string字符串 
# @return string字符串
#
class Solution:
    def solve(self , str: str) -> str:
        #左右双指针
        left = 0
        right = len(str) - 1
        #两指针往中间靠
        while left < right: 
            l_s = list(str)
            temp = l_s[left]
            l_s[left] = l_s[right]
            #交换两边字符
            l_s[right] = temp
            str = ''.join(l_s)
            left += 1
            right -= 1
        return str
```

复杂度分析：

时间复杂度： O(n) ， n 为字符串长度，一共循环 n/2 次
空间复杂度： O(1) ，常数级变量，没有使用额外辅助空间

方法二：逆序拼接（扩展思路）
具体做法：

step 1：我们可以从后往前遍历字符串s。
step 2：准备一个空串依次在其前面添加遍历到的字符，新串就是逆序字符串。

```
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 反转字符串
# @param str string字符串 
# @return string字符串
#
class Solution:
    def solve(self , str: str) -> str:
        #从一个空串开始
        output = "" 
        i = len(str) - 1
        #逆序遍历字符串
        while i >= 0 : 
            #将字符加到新串后面
            output += str[i] 
            i -= 1
        return output
```

复杂度分析：

时间复杂度： O(n) ， n 为字符串的长度，一次遍历
空间复杂度： O(n) ，output记录新串，长度等于原串

### BM92. 最长无重复子数组

题目主要信息:
题目给定一个数组，要找到其中最长的无重复的子数组的长度
子数组必须是数组中连续的一段
方法：滑动窗口(推荐使用)
具体做法:

既然要找一段连续子数组的内不重复的长度，我们可以使用滑动窗口，窗口内都是不重复的，然后窗口右界不断向右滑，如果窗口内出现了重复数组，说明新加入的元素与之前的重复了，只需要窗口左界也向右收缩就可以保证窗口内都是不重复的。

step 1：使用unordered_map构建一个哈希表，用于统计数组元素出现的次数。
step 2：窗口左右界都从数组首部开始，每次窗口优先右移右界，并统计进入窗口的元素的出现频率。
step 3：一旦右界元素出现频率大于1，就需要右移左界直到窗口内不再重复，将左边的元素移除窗口的时候同时需要将它在哈希表中的频率减1，保证哈希表中的频率都是窗口内的频率。
step 4：每轮循环，维护窗口长度最大值。

```
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param arr int整型一维数组 the array
# @return int整型
#
class Solution:
    def maxLength(self , arr: List[int]) -> int:
        #哈希表记录窗口内非重复的数字
        mp = dict() 
        res = 0
        left = 0
        #设置窗口左右边界
        for right in range(len(arr)): 
            if arr[right] in mp:
                #窗口右移进入哈希表统计出现次数
                mp[arr[right]] += 1 
            else:
                mp[arr[right]] = 1
            #出现次数大于1，则窗口内有重复
            while mp[arr[right]] > 1: 
                #窗口左移，同时减去该数字的出现次数
                mp[arr[left]] -=1 
                left += 1
            #维护子数组长度最大值
            res = max(res, right - left + 1) 
        return res
```

复杂度分析：

时间复杂度： O(n) ，外循环窗口右界从数组首右移到数组尾，内循环窗口左界同样如此，因此复杂度为 O(n+n)=O(n) 
空间复杂度： O(n) ，最坏情况下整个数组都是不重复的，哈希表长度就为数组长度 n 

### BM93. 盛水最多的容器

题目主要信息:
输入一个数组，其中每个元素代表水桶边界高度
水桶容积为边界较短的一边高度乘上两边界的距离（数组下标表示距离）
求在数组中选取两个边，求最大容积
方法：贪心法(建议使用)
具体做法:

这道题类似接雨水问题，还是利用了水桶的短板原理，较短的一边控制最大水量，因此直接用较短边长乘底部两边距离就可以得到当前情况下的容积。但是要怎么找最大值呢？可以用双指针+贪心思想：

step 1：优先排除不能形成容器的特殊情况。
step 2：初始化双指针指向数组首尾，每次利用上述公式计算当前的容积，维护一个最大容积作为返回值。
step 3：我们都知道容积与最短边长和底边长有关，双指针向中间靠的情况下，底边长会缩短，因此还想要有更大容积只能是增加最短变长，因此每次指针移动就移动较短的一边，因为贪心思想下较长的一边比较短的一边更可能出现更大容积。

```
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param height int整型一维数组 
# @return int整型
#
class Solution:
    def maxArea(self , height: List[int]) -> int:
        #排除不能形成容器的情况
        if len(height) < 2: 
            return 0
        res = 0
        #双指针左右界
        left = 0 
        right = len(height) - 1
        #共同遍历完所有的数组
        while left < right:
            #计算区域水容量
            capacity = min(height[left], height[right]) * (right - left) 
            #维护最大值
            res = max(res, capacity) 
            #优先舍弃较短的边
            if height[left] < height[right]: 
                left += 1
            else:
                right -= 1
        return res
```

复杂度分析：

时间复杂度： O(n) ，双指针共同遍历一次数组
空间复杂度： O(1) ，常数级变量，没有额外辅助空间

### BM94. 接雨水问题

题目主要信息:
给定一个整型数组，数组每个元素表示下图所示的每列灰色柱子高度，数值都是非负数
在雨水（图中蓝色部分）不超过边界的情况下，问最多能有多少蓝色的格子
数组以外的区域高度视为0

方法：双指针(推荐使用)
具体做法：

我们都知道水桶的短板问题，控制水桶水量的是最短的一条板子。这道题也是类似，我们可以将整个图看成一个水桶，两边就是水桶的板，中间比较低的部分就是水桶的底，由较短的边控制水桶的最高水量。但是水桶中可能出现更高的边，比如上图第四列，它比水桶边还要高，那这种情况下它是不是将一个水桶分割成了两个水桶，而中间的那条边就是两个水桶的边。

有了这个思想，解决这道题就容易了，因为我们这里的水桶有两个边，因此可以考虑使用双指针往中间靠。

step 1：检查数组是否为空的特殊情况
step 2：准备双指针，分别指向数组首尾元素，代表最初的两个边界
step 3：指针往中间遍历，遇到更低柱子就是底，用较短的边界减去底就是这一列的接水量，遇到更高的柱子就是新的边界，更新边界大小。

```
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# max water
# @param arr int整型一维数组 the array
# @return long长整型
#
class Solution:
    def maxWater(self , arr: List[int]) -> int:
        #排除空数组
        if len(arr) == 0: 
            return 0
        res = 0
        #左右双指针
        left = 0 
        right = len(arr) - 1
        #中间区域的边界高度
        maxL = 0 
        maxR = 0
        #直到左右指针相遇
        while left < right:
            #每次维护往中间的最大边界 
            maxL = max(maxL, arr[left]) 
            maxR = max(maxR, arr[right])
            #较短的边界确定该格子的水量
            if maxR > maxL: 
                res += maxL - arr[left]
                left += 1
            else:
                res += maxR - arr[right]
                right -= 1
        return res
```

复杂度分析：

时间复杂度： O(n) ，两个指针最多共同遍历整个数组
空间复杂度： O(1) ，常数个变量，没有额外的辅助空间

## 10贪心

### BM95. 分糖果问题

题目主要信息:
给定一个数组，每个元素代表孩子的得分，每个孩子至少分得一个糖果
相邻两个位置得分高的要比得分低的分得多，得分相同没有限制
求最少总共需要多少糖果数
方法：贪心算法（推荐使用）
具体思路:

要想分出最少的糖果，利用贪心思想，肯定是相邻位置没有增加的情况下大家都分到1，相邻位置有增加的情况下，分到糖果数加1就好。什么情况下会增加糖果，相邻位置有得分差异，可能是递增可能是递减，如果是递增的话，糖果依次加1，如果是递减糖果依次减1？这不符合最小，必须从1开始加才是最小，那我们可以反向加1.

step 1：使用一个辅助数组记录每个位置的孩子分到的糖果，全部初始化为1.
step 2：从左到右遍历数组，如果右边元素比相邻左边元素大，意味着在递增，糖果数就是前一个加1，否则保持1不变。
step 3：从右到左遍历数组，如果左边元素比相邻右边元素大， 意味着在原数组中是递减部分，如果左边在上一轮中分到的糖果数更小，则更新为右边的糖果数+1，否则保持不变。
step 4：将辅助数组中的元素累加求和。

```
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# pick candy
# @param arr int整型一维数组 the array
# @return int整型
#
class Solution:
    def candy(self , arr: List[int]) -> int:
        #记录每个位置的糖果数，初始为1
        nums = [1] * len(arr) 
        #从左到右遍历
        for i in range(1,len(arr)) :
            #如果右边在递增，每次增加一个
            if arr[i] > arr[i - 1]: 
                nums[i] = nums[i - 1] + 1
        #记录总糖果数
        res = nums[len(arr) - 1] 
        i = len(arr) - 2
        #从右到左遍历
        while i >= 0: 
            #如果左边更大但是糖果数更小
            if arr[i] > arr[i + 1] and nums[i] <= nums[i + 1]: 
                nums[i] = nums[i + 1] + 1
            #累加和
            res += nums[i] 
            i -= 1
        return res
```

复杂度分析：

时间复杂度： O(n) ，单独遍历两次
空间复杂度： O(n) ，记录每个位置糖果数的辅助数组

### BM96. 主持人调度

题目的主要信息：
n个活动，有各自的区间
一个主持人不能在相交的区间工作
将相交的区间分成一组，最后组数即是主持人的数量
数字为int型的范围，可能会出现负数
方法一：排序+遍历比较（推荐使用）
具体做法：

step 1: 利用辅助数组单独各个活动开始的时间和结束时间，然后分别进行排序。
step 2: 遍历个活动，如果某个活动开始的时间大于之前活动结束的时候，当前主持人就够了,活动结束时间往后一位;
step 3: 若是出现之前活动结束时间晚于当前活动开始时间的，需要增加主持人。

```
class Solution:
    def minmumNumberOfHost(self , n: int, startEnd: List[List[int]]) -> int:
        start = list()
        end =list()
        #分别得到活动起始时间
        for i in range(n):
            start.append(startEnd[i][0])
            end.append(startEnd[i][1])
        #分别对开始和结束时间排序
        start.sort()
        end.sort()
        res = 0
        j = 0
        for i in range(n):
            #新开始的节目大于上一轮结束的时间，主持人不变
            if start[i] >= end[j]: 
                j += 1
            else:
                #主持人增加
                res += 1  
        return res
```

复杂度分析：

时间复杂度： O(nlog_2n) ，遍历都是 O(n) ，sort排序为 O(nlog_2n)

空间复杂度： O(n) ，辅助空间记录开始时间和结束时间的数组

方法二：重载sort+大顶堆（扩展思路）
具体做法：

step 1: 重载sort函数，优先排开始时间小的，相同情况下再考虑结束时间较小的。
step 2: 使用小顶堆辅助，其中堆顶是还未结束的将要最快结束的活动的结束时间。
step 3:首先将int的最小数加入堆中，遍历每一个开始时间，若是堆顶的结束时间小于当前开始时间，可以将其弹出，说明少需要一个主持人；
step 4: 除此之外，每次都需要将当前的结束时间需要加入堆中，代表需要一个主持人，最后遍历完成，堆中还有多少元素，就需要多少主持人。

```
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 计算成功举办活动需要多少名主持人
# @param n int整型 有n个活动
# @param startEnd int整型二维数组 startEnd[i][0]用于表示第i个活动的开始时间，startEnd[i][1]表示第i个活动的结束时间
# @return int整型
#
import functools
from queue import Queue, PriorityQueue
class Solution:
    #优先比较开始时间，再比较结束时间
    def comp(a:List[int], b: List[int]): 
        if a[0] == b[0]:
            return a[1] - b[1]
        else:
            return a[0] - b[0]
        
    def minmumNumberOfHost(self , n: int, startEnd: List[List[int]]) -> int:
        startEnd.sort(key = functools.cmp_to_key(Solution.comp))
        #小顶堆
        q = PriorityQueue() 
        #可能有负区间
        q.put(-2147483648) 
        for i in range(n):
            temp = q.get()
            #最近的活动结束时间小于当前活动开始时间
            if temp > startEnd[i][0]:  
                q.put(temp)
            q.put(startEnd[i][1])
        #剩余的活动等于主持人数
        return q.qsize()
```

复杂度分析：

时间复杂度： O(nlog_2n) ，sort排序是 O(nlog_2n) ，一次遍历，循环中维护堆每次 O(log_2n) 

空间复杂度： O(n) ，堆大小最大为 n 

## 11模拟

### BM97. 旋转数组

题目主要信息:
一个长度为 n 的数组，将数组整体循环右移 m 个位置（ m 可能大于 n ）
循环右移即最后 m 个元素放在数组最前面，前 n - m 个元素依次后移
不能使用额外的数组空间
方法：三次翻转（推荐使用）
具体思路:

循环右移相当于从第 m 个位置开始，左右两部分视作整体翻转。即abcdefg右移3位efgabcd可以看成AB翻转成BA（这里小写字母看成数组元素，大写字母看成整体）。既然是翻转我们就可以用到reverse函数。

step 1：因为 m 可能大于 n ，因此需要对 n 取余，因为每次长度为 n 的旋转数组相当于没有变化。
step 2：第一次将整个数组翻转，得到数组的逆序，它已经满足了右移的整体出现在了左边。
step 3：第二次就将左边的 m 个元素单独翻转，因为它虽然移到了左边，但是逆序了。
step 4：第三次就将右边的 n - m 个元素单独翻转，因此这部分也逆序了。

```
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 旋转数组
# @param n int整型 数组长度
# @param m int整型 右移距离
# @param a int整型一维数组 给定数组
# @return int整型一维数组
#
class Solution:
    def solve(self , n: int, m: int, a: List[int]) -> List[int]:
        #取余，因为每次长度为n的旋转数组相当于没有变化
        m = m % n 
        #第一次逆转全部数组元素
        a.reverse() 
        b = a[:m]
        #第二次只逆转开头m个
        b.reverse()
        c = a[m:]
        #第三次只逆转结尾m个
        c.reverse() 
        a[:m] = b
        a[m:] = c
        return a
```

复杂度分析：

时间复杂度： O(n) ，三次reverse函数的复杂度都最坏为 O(n) 
空间复杂度： O(1) ，没有使用额外的辅助空间

### BM98. 螺旋矩阵

题目主要信息:
题目给定一个的矩阵，需要将其螺旋输出
方法：边界模拟法（推荐使用）
具体思路:

这道题就是一个简单的模拟，我们想象有一个矩阵，从第一个元素开始，往右到底后再往下到底后再往左到底后再往上，结束这一圈，进入下一圈螺旋。

step 1：首先排除特殊情况，即矩阵为空的情况。
step 2：设置矩阵的四个边界值，开始准备螺旋遍历矩阵，遍历的截止点是左右边界或者上下边界重合。
step 3：首先对最上面一排从左到右进行遍历输出，到达最右边后第一排就输出完了，上边界相应就往下一行，要判断上下边界是否相遇相交。
step 4：然后输出到了右边，正好就对最右边一列从上到下输出，到底后最右边一列已经输出完了，右边界就相应往左一列，要判断左右边界是否相遇相交。
step 5：然后对最下面一排从右到左进行遍历输出，到达最左边后最下一排就输出完了，下边界相应就往上一行，要判断上下边界是否相遇相交。
step 6：然后输出到了左边，正好就对最左边一列从下到上输出，到顶后最左边一列已经输出完了，左边界就相应往右一列，要判断左右边界是否相遇相交。
step 7：重复上述3-6步骤直到循环结束。

```
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param matrix int整型二维数组 
# @return int整型一维数组
#
class Solution:
    def spiralOrder(self , matrix: List[List[int]]) -> List[int]:
        res = list()
        n = len(matrix)
        #先排除特殊情况
        if n == 0: 
            return res
        #左边界
        left = 0 
        #右边界
        right = len(matrix[0]) - 1 
        #上边界
        up = 0 
        #下边界
        down = n - 1 
        #直到边界重合
        while left <= right and up <= down: 
            #上边界的从左到右
            for i in range(left, right+1): 
                res.append(matrix[up][i])
            #上边界向下
            up += 1 
            if up > down:
                break
            #右边界的从上到下
            for i in range(up,down+1): 
                res.append(matrix[i][right])
            #右边界向左
            right -= 1 
            if left > right:
                break
            i = right
            #下边界的从右到左
            while i >= left: 
                res.append(matrix[down][i])
                i -= 1
            #下边界向上
            down -= 1 
            if up > down:
                break
            i = down
            #左边界的从下到上
            while i >= up: 
                res.append(matrix[i][left])
                i -= 1
            #左边界向右
            left += 1 
            if left > right:
                break
        return res
```

复杂度分析：

时间复杂度： O(mn) ，相当于遍历整个矩阵
空间复杂度： O(1) ，res属于必要空间，没有使用额外辅助空间

### BM99. 顺时针旋转矩阵

题目主要信息:
给定一个 n * n 的矩阵，返回其顺时针90度旋转后的结果
方法：倒置翻转（推荐使用）
具体思路:

这道题可能需要将矩阵画出来，观察一下旋转后的规律：

乍一看没有啥规律，但是旋转后的第一行是不是与原矩阵的第一列很像，就是其翻转之后的结果，那我们可以再尝试画出一个顺时针90度旋转后每行翻转的矩阵：

然后我们会惊喜得发现，这就是互为转置的两个矩阵（转置矩阵为上三角矩阵元素与下三角矩阵元素依据对角线位置互换的矩阵）。因为转置的可逆性，只要过程逆转，就可以得到顺时针旋转90度后的矩阵了。

step 1：遍历矩阵的下三角矩阵，将其与上三角矩阵对应的位置互换，其实就是数组下标交换后的互换。
step 2：遍历矩阵每一行，将每一行看成一个数组使用reverse函数翻转。

```
class Solution:
    def rotateMatrix(self , mat: List[List[int]], n: int) -> List[List[int]]:
        #矩阵转置
        for i in range(n):
            for j in range(i):
                #交换上三角与下三角对应的元素
                temp = mat[i][j]
                mat[i][j] = mat[j][i]
                mat[j][i] = temp
        #每行翻转
        for i in range(n):
            mat[i].reverse()
        return mat
```

复杂度分析：

时间复杂度： O(n^2) ，转置需要遍历矩阵，逐行翻转也是 O(n^2) 
空间复杂度： O(1) ，常数级变量，没有使用额外辅助空间

### BM100. 设计LRU缓存结构

题目的主要信息：
实现LRU缓存的模拟结构，包括加入函数set，访问函数get
结构有长度限制，加入新数时，超出长度则需要删除最不常访问的，其中set与get都访问
两个函数都是 O(1) 
方法：构建双向链表（推荐使用）
插入与访问值都是 O(1) ，没有任何一种数据结构可以做到。
于是我们可以想到数据结构的组合。访问O(1)很容易想到了哈希表，插入 O(1) 有很多，但是如果访问到了再插入，且超出长度要在 O(1) 之内删除，我们可以想到用链表。因为要在 O(1) 之内删除最不常访问的，所以是双向链表。于是我们的方法就是哈希表+双向链表。

具体做法：

step 1：用哈希表存储链表结点和key值，能够做到 O(1) 访问链表任意结点
step 2：每次调用函数后将该结点放到链表最前方表示权重最大，最常访问，每次删除链表最后一个结点。
step 3：要实现这个操作，我们需要的是有头结点和尾结点的双向链表。

```
#构建双向链表
class Node:
    def __init__(self, key, val):
        self.key = key
        self.val = val
        self.pre = None
        self.next = None
        
class Solution:
    def __init__(self):
        #双向链表头尾
        self.size = 0
        self.head = None
        self.tail = None
        #哈希表记录key值
        self.mp = dict()
    
    #将节点插入表头函数
    def insertFirst(self, node: Node):
        node.pre = self.head
        node.next = self.head.next
        self.head.next.pre = node
        self.head.next = node
    
    #移到表头函数
    def moveToHead(self, node: Node):
        #已经到了表头
        if node.pre == self.head:  
            return
        #将节点断开，取出来
        node.pre.next = node.next
        node.next.pre = node.pre
        #插入第一个前面
        self.insertFirst(node)
    
    #删去表尾函数，最近最少使用
    def removeLast(self):
        #哈希表去掉key
        self.mp.pop(self.tail.pre.key)
        #断连该节点
        self.tail.pre.pre.next = self.tail; 
        self.tail.pre = self.tail.pre.pre
    
    #插入函数
    def set(self, key: int, val: int):
        #没有见过这个key，新值加入
        if key not in self.mp:
            node = Node(key, val)
            self.mp[key] = node
            #超出大小，移除最后一个
            if self.size <= 0:
                self.removeLast()
            #大小还有剩余
            else:
                #大小减1
                self.size -= 1 
            #加到链表头
            self.insertFirst(node); 
        #哈希表中已经有了，即链表里也已经有了
        else:
            self.mp[key].val = val
            #访问过后，移到表头
            self.moveToHead(self.mp[key])
    
    #获取数据函数
    def get(self, key: int) -> int:
        #找不到返回-1
        res = -1
        #哈希表中找到
        if key in self.mp:
            #获取
            res = self.mp[key].val
            #访问过后移到表头
            self.moveToHead(self.mp[key])
        return res

    def LRU(self , operators: List[List[int]], k: int) -> List[int]:
        res = []
        #构建初始化连接
        #链表剩余大小
        self.size = k 
        self.head = Node(0, 0)
        self.tail = Node(0, 0)
        self.head.next = self.tail
        self.tail.pre = self.head
        #遍历所有操作
        for i in range(len(operators)):
            op = operators[i]
            if op[0] == 1: 
                #set操作
                self.set(op[1], op[2])
            else:
                #get操作
                res.append(self.get(op[1]))
        return res
```

复杂度分析：

时间复杂度： O(n) ，其中 n 为操作数组大小，map为哈希表，每次插入的复杂度都是 O(1) 
空间复杂度： O(k) ，链表和哈希表都是O(k)的辅助空间

https://juejin.cn/post/7105654083347808263

```
<script>
  class LRUCache {
    constructor(lenght) {
      this.length = lenght; // 存储长度
      this.data = new Map(); // 存储数据
    }
    // 存储数据，通过键值对的方式
    set(key, value) {
      const data = this.data;
      if (data.has(key)) {
        data.delete(key)
      }
      data.set(key, value);


      // 如果超出了容量，则需要删除最久的数据
      if (data.size > this.length) {
        const delKey = data.keys().next().value;
        data.delete(delKey);
      }
    }
    // 获取数据
    get(key) {
      const data = this.data;
      // 未找到
      if (!data.has(key)) {
        return null;
      }
      const value = data.get(key); // 获取元素
      data.delete(key); // 删除元素
      data.set(key, value); // 重新插入元素
    }
  }
  const lruCache = new LRUCache(5);
</script>
```



### BM101. 设计LFU缓存结构

题目的主要信息：
实现LFU的set与get函数，且复杂度为 O(1) 
每次调用这两个函数会给一个频率赋值，超出长度则移除频率最少的，若有频率相同，则移除访问时间最早的
方法：双哈希表（推荐使用）
具体做法：

step 1: 需要建立一个双向量表及两个哈希表，链表结点存储频率、key及value。第一个哈希表建立链表与频率的映射，旨在能O(1)找到最小频率；第二个哈希表建立键值key到第一个哈希表的映射，旨在能 O(1) 找到key对应的那组数据。
step 2: 对于get函数，直接访问哈希表即可，但是访问后要更新频率；
step 3: 对于set函数，需要容量未满，则直接加入，若是满了则通过第一个哈希表剔出频率最低的结点，最后要更新结点频率为1。

```
import collections
class Node:
    def __init__(self, freq, key, val):
        self.freq = freq
        self.key = key
        self.val = val
        
class Solution:
    def __init__(self):
        #记录剩余空间
        self.size = 0
        #key到双向链表节点的哈希表
        self.mp = dict()
        #频率到链表的哈希表
        self.freq_mp = dict(collections.deque())
        #记录当前最小频次
        self.min_freq = 0
    
    #调用函数时更新频率或者val值
    def update(self, node: Node, key: int, value: int): 
        #找到频率
        freq = node.freq
        #原频率中删除该节点
        self.freq_mp[freq].remove(node) 
        #哈希表中该频率已无节点，直接删除
        if len(self.freq_mp[freq]) == 0: 
            self.freq_mp.pop(freq)
            #若当前频率为最小，最小频率加1
            if self.min_freq == freq: 
                self.min_freq += 1
        #插入频率加一的双向链表表头，链表中对应：freq key value
        node = Node(freq + 1, key, value)
        if freq + 1 not in self.freq_mp:
            self.freq_mp[freq + 1] = collections.deque()
        self.freq_mp[freq + 1].appendleft(node)
        self.mp[key] = self.freq_mp[freq + 1][0]
    
    #set操作函数
    def set(self, key:int, value: int):
        #在哈希表中找到key值
        if key in self.mp:
            #若是哈希表中有，则更新值与频率
            self.update(self.mp[key], key, value)
        else:
            #哈希表中没有，即链表中没有
            if self.size == 0:
                #满容量取频率最低且最早的删掉
                oldnode = self.freq_mp[self.min_freq].pop() 
                #频率哈希表的链表中删除
                if len(self.freq_mp[self.min_freq]) == 0:
                    self.freq_mp.pop(self.min_freq) 
                #链表哈希表中删除
                self.mp.pop(oldnode.key)
            #若有空闲则直接加入，容量减1
            else: 
                self.size -= 1
            #最小频率置为1
            self.min_freq = 1
            node = Node(1, key, value)
            if 1 not in self.freq_mp:
                self.freq_mp[1] = collections.deque()
            self.freq_mp[1].appendleft(node)
            #哈希表key值指向链表中该位置
            self.mp[key] = self.freq_mp[1][0]
            
    #get操作函数
    def get(self, key: int) -> int:
        res = -1
        #查找哈希表
        if key in self.mp:
            node = self.mp[key]
            #根据哈希表直接获取值
            res = node.val
            #更新频率 
            self.update(node, key, res)
        return res

    def LFU(self , operators: List[List[int]], k: int) -> List[int]:
        res = []
        #构建初始化连接
        #链表剩余大小
        self.size = k
        #遍历所有操作
        for i in range(len(operators)):
            op = operators[i]
            if op[0] == 1: 
                #set操作
                self.set(op[1], op[2])
            else:
                #get操作
                res.append(self.get(op[1]))
        return resnd(self.get(op[1]))
        return res
```

复杂度分析：

时间复杂度： O(n) ，取决于操作数 n 
空间复杂度： O(k) ，取决于缓存容量 k 
