# top101

## 01链表

### BM1 反转链表

给定一个长度为n的链表，反转该链表，输出表头

方法一：迭代（推荐使用）
具体做法：

step 1：优先处理空链表，空链表不需要反转。
step 2：我们可以设置两个指针，一个当前节点的指针，一个上一个节点的指针（初始为空）。
step 3：遍历整个链表，每到一个节点，断开当前节点与后面节点的指针，并用临时变量记录后一个节点，然后当前节点指向上一个节点。
step 4：再轮换当前指针与上一个指针，让它们进入下一个节点及下一个节点的前序节点。

```
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param head ListNode类 
# @return ListNode类
#
class Solution:
    def ReverseList(self , head: ListNode) -> ListNode:
        # write code here
        pre = None
        phead = head
        while phead:
            temp = phead.next
            phead.next = pre
            pre = phead
            phead = temp
        return pre
```

复杂度分析：

时间复杂度：O（N），遍历链表一次

空间复杂度：O（1），无额外空间使用

### BM2.链表内指定区间反转

题目的主要信息：
将一个节点数为 size 链表 m 位置到 n 位置之间的区间反转
链表其他部分不变，返回头节点
方法一：头插法迭代（推荐使用）
具体做法：

肯定是要先找到了第m个位置才能开始反转链表，而反转的部分就是从第m个位置到第n个位置。

step 1：我们可以在链表前加一个表头，后续返回时去掉就好了，因为如果要从链表头的位置反转，也很方便。
step 2：使用两个指针，一个指向当前节点，一个指向前序节点。
step 3：依次遍历链表，到第m个的位置。
step 4：对于从m到n这些个位置的节点，依次断掉指向后续的指针，反转指针方向。
step 5：返回时去掉我们添加的表头。

```
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param head ListNode类 
# @param m int整型 
# @param n int整型 
# @return ListNode类
#
class Solution:
    def reverseBetween(self , head: ListNode, m: int, n: int) -> ListNode:
        #加个表头
        res = ListNode(-1)
        res.next = head
        #前序节点
        pre = res 
        #当前节点
        cur = head 
        #找到m
        for i in range(1,m): 
            pre = cur
            cur = cur.next
        #从m反转到n
        for i in range(m, n): 
            temp = cur.next
            cur.next = temp.next
            temp.next = pre.next
            pre.next = temp
        #返回去掉表头
        return res.next 
```

复杂度分析：

时间复杂度：O(n)，最坏情况下递归遍历全部链表节点，比如m为链表最后一个位置，或者n为链表最后一个位置时

空间复杂度：O(n)，遍历全部节点时递归栈深度最坏为n

### BM3.链表中的节点每k个一组翻转

题目主要信息:
给定一个链表，从头开始每k个作为一组，将每组的链表结点翻转
组与组之间的位置不变
如果最后链表末尾剩余不足k个元素，则不翻转，直接放在最后
方法：递归（推荐使用）
具体做法：

step 1：现在我们想一想，如果拿到一个链表，想要像上述一样分组翻转应该做些什么？首先肯定是分段吧，至少我们要先分成一组一组，才能够在组内翻转。分组很容易，只要每次遍历k个元素，就是一组。
step 2：然后是组内翻转，翻转完了再连接起来。翻转即指定区间内的翻转，也很容易，可以参考链表指定区间内的翻转。
step 3：最后是将反转后的分组连接，但是连接的时候遇到问题了：首先如果能够翻转，链表第一个元素一定是第一组，它翻转之后就跑到后面去了，而第一组的末尾元素才是新的链表首，我们要返回的也是这个元素，而原本的链表首要连接下一组翻转后的头部，即翻转前的尾部，如果不建立新的链表，看起来就会非常难。
step 4：如果我们从最后的一个组开始翻转，得到了最后一个组的链表首，是不是可以直接连在倒数第二个组翻转后的尾（即翻转前的头）后面，是不是看起来就容易多了。
怎样从后往前呢？我们这时候可以用到自上而下再自下而上的递归或者说栈。接下来我们说说为什么能用递归？如果这个链表有n个分组可以翻转，我们首先对第一个分组翻转，那么是不是接下来将剩余n-1个分组翻转后的结果接在第一组后面就行了，那这剩余的n-1组就是一个子问题。我们来看看递归的三段式模版：

终止条件： 当进行到最后一个分组，即不足k次遍历到链表尾（0次也算），就将剩余的部分直接返回。
返回值： 每一级要返回的就是翻转后的这一分组的头，以及连接好它后面所有翻转好的分组链表。
本级任务： 对于每个子问题，先遍历k次，找到该组结尾在哪里，然后从这一组开头遍历到结尾，依次翻转，结尾就可以作为下一个分组的开头，而先前指向开头的元素已经跑到了这一分组的最后，可以用它来连接它后面的子问题，即后面分组的头。

```
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param head ListNode类 
# @param k int整型 
# @return ListNode类
#
class Solution:
    def reverseKGroup(self , head: ListNode, k: int) -> ListNode:
        #找到每次翻转的尾部
        tail = head 
        #遍历k次到尾部
        for i in range(0,k): 
            #如果不足k到了链表尾，直接返回，不翻转
            if tail == None: 
                return head
            tail = tail.next
        #翻转时需要的前序和当前节点
        pre = None 
        cur = head
        #在到达当前段尾节点前
        while cur != tail: 
            #翻转
            temp = cur.next 
            cur.next = pre
            pre = cur
            cur = temp
        #当前尾指向下一段要翻转的链表
        head.next = self.reverseKGroup(tail, k) 
        return pre
```

复杂度分析：

时间复杂度：O(n)，一共遍历链表n个节点

空间复杂度：O(n)，递归栈最大深度为n/k

### BM4. 合并有序链表

题目的主要信息：
两个元素值递增的链表，单个链表的长度为n
合并这两个链表并使新链表中的节点仍然是递增排序的
方法一：迭代（推荐使用）
具体做法：

既然两个链表已经是排好序的，都是从小到大的顺序，那我们要将其组合，可以使用归并排序的思想：每次比较两个头部，从中取出最小的元素，然后依次往后。这样就能最快速地将最小的元素依次取出来排好序。

step 1：判断空链表的情况，只要有一个链表为空，那答案必定就是另一个链表了，就算另一个链表也为空。
step 2：新建一个空的表头后面连接两个链表排序后的结点。
step 3：遍历两个链表都不为空的情况，取较小值添加在新的链表后面，每次只把被添加的链表的指针后移。
step 4：遍历到最后肯定有一个链表还有剩余的结点，它们的值将大于前面所有的，直接连在新的链表后面即可。

```
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param pHead1 ListNode类 
# @param pHead2 ListNode类 
# @return ListNode类
#
class Solution:
    def Merge(self, pHead1, pHead2):
        # write code here
        dummy = cur = ListNode(0)
        while pHead1 and pHead2:
            if pHead1.val <pHead2.val:
                cur.next = pHead1
                pHead1 = pHead1.next
            else:
                cur.next = pHead2
                pHead2 =pHead2.next
            cur = cur.next
        cur.next = pHead1 or pHead2
        return dummy.next
```

复杂度分析：

时间复杂度：O（n），最坏情况遍历2*n个结点
空间复杂度：O（1），无额外空间使用，新建的链表属于返回必要空间

### BM5. 合并k个已排序的链表

题目的主要信息：
给定k个排好序的升序链表
将这k个链表合并成一个大的升序链表，并返回这个升序链表的头
方法一：归并排序思想（推荐使用）
具体做法：

如果是两个有序链表合并，我们可能会利用归并排序合并阶段的思想：准备双指针分别放在两个链表头，每次取出较小的一个元素加入新的大链表，将其指针后移，继续比较，这样我们出去的都是最小的元素，自然就完成了排序。

其实这道题我们也可以两两比较啊，只要遍历链表数组，取出开头的两个链表，按照上述思路合并，然后新链表再与后一个继续合并，如此循环，知道全部合并完成。但是，这样太浪费时间了。

既然都是归并排序的思想了，那我们可不可以直接归并的分治来做，而不是顺序遍历合并链表呢？答案是可以的！

归并排序是什么？简单来说就是将一个数组每次划分成等长的两部分，对两部分进行排序即是子问题。对子问题继续划分，直到子问题只有1个元素。还原的时候呢，将每个子问题和它相邻的另一个子问题利用上述双指针的方式，1个与1个合并成2个，2个与2个合并成4个，因为这每个单独的子问题合并好的都是有序的，直到合并成原本长度的数组。

step 1：对于这k个链表，就相当于上述合并阶段的k个子问题，需要两个合并，不断往上，最终合并成完整的一个链表。
step 2：从链表数组的首和尾开始，每次划分从中间开始划分，划分成两半。
step 3：将这两半子问题合并好了就成了两个有序链表，最后将这两个有序链表合并就成了，依据子问题递归处理。
终止条件： 划分的时候直到左右区间相等或事左边大于右边。
返回值： 每级返回已经合并好的子问题链表。
本级任务： 对半划分，将划分后的子问题合并成新的链表。

```
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param lists ListNode类一维数组 
# @return ListNode类
#
# import sys
#设置递归深度
# sys.setrecursionlimit(100000) 

class Solution:
    #两个有序链表合并函数
    def Merge2(self, pHead1: ListNode, pHead2: ListNode) -> ListNode: 
        #一个已经为空了，直接返回另一个
        if pHead1 == None: 
            return pHead2
        if pHead2 == None:
            return pHead1
        #加一个表头
        head = ListNode(0) 
        cur = head
        #两个链表都要不为空
        while pHead1 and pHead2: 
            #取较小值的节点
            if pHead1.val <= pHead2.val: 
                cur.next = pHead1
                #只移动取值的指针
                pHead1 = pHead1.next 
            else:
                cur.next = pHead2
                #只移动取值的指针
                pHead2 = pHead2.next 
            #指针后移
            cur = cur.next 
        #哪个链表还有剩，直接连在后面
        if pHead1: 
            cur.next = pHead1
        else:
            cur.next = pHead2
        #返回值去掉表头
        return head.next 
    
    #划分合并区间函数
    def divideMerge(self, lists: List[ListNode], left: int, right: int) -> ListNode:         
        if left > right :
            return None
        #中间一个的情况
        elif left == right: 
            return lists[left]
        #从中间分成两段，再将合并好的两段合并
        mid = (int)((left + right) / 2) 
        return self.Merge2(self.divideMerge(lists, left, mid), self.divideMerge(lists, mid + 1, right))
    
    def mergeKLists(self , lists: List[ListNode]) -> ListNode:
        #k个链表归并排序
        return self.divideMerge(lists, 0, len(lists) - 1) 
```

复杂度分析：

时间复杂度：O(n*k)，其中n为所有链表的总节点数，最坏情况下每次合并都是O(n)，分治为二叉树型递归，每个节点都要使用一次合并，需要合并k-1次
空间复杂度：O(log~2~k)，最坏情况下递归log~2~k层，需要log~2~k的递归栈

### BM6. 判断链表中是否有环

题目主要信息:
给定一个链表的头节点，判断这个链表是否有环

方法：双指针（推荐使用）
具体做法：

我们都知道链表不像二叉树，每个节点只有一个val值和一个next指针，也就是说一个节点只能有一个指针指向下一个节点，不能有两个指针，那这时我们就可以说一个性质：环形链表的环一定在末尾，末尾没有NULL了。为什么这样说呢？仔细看上图，在环2，0，-4中，没有任何一个节点可以指针指出环，它们只能在环内不断循环，因此环后面不可能还有一条尾巴。如果是普通线形链表末尾一定有NULL，那我们可以根据链表中是否有NULL判断是不是有环。

但是，环形链表遍历过程中会不断循环，线形链表遍历到NULL结束了，但是环形链表何时能结束呢？我们可以用一种双指针技巧，这也是处理环形链表常用的技巧：

step 1：设置快慢两个指针，初始都指向链表头。
step 2：遍历链表，快指针每次走两步，慢指针每次走一步。
step 3：如果快指针到了链表末尾，说明没有环，因为它每次走两步，所以要验证连续两步是否为NULL。
step 4：如果链表有环，那快慢双指针会在环内循环，因为快指针每次走两步，因此快指针会在环内追到慢指针，二者相遇就代表有环。

```
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

#
# 
# @param head ListNode类 
# @return bool布尔型
#
class Solution:
    def hasCycle(self , head: ListNode) -> bool:
        #先判断链表为空的情况
        if head == None: 
            return False
        #快慢双指针
        fast = head 
        slow = head
        #如果没环快指针会先到链表尾
        while fast != None and fast.next != None: 
            #快指针移动两步
            fast = fast.next.next 
            #慢指针移动一步
            slow = slow.next 
            #相遇则有环
            if fast == slow: 
                return True
        #到末尾则没有环
        return False 
```

复杂度分析：

时间复杂度：O(n)，最坏情况下遍历链表n个节点
空间复杂度：O(1)，仅使用了两个指针，没有额外辅助空间

### BM7. 链表中环的入口节点

题目主要信息:
给定一个链表，首先判断其是否有环，然后找到环的入口
方法：双指针（推荐使用）
具体做法：

根据题干，不说别的，我们能发现这道题需要完成两个任务：

判断链表是否有环。
在有环的链表中找到环的入口。
对于第一个任务，可以参考判断链表中是否有环，主要思想是利用环没有末尾NULL，后半部分一定是环，然后快慢双指针相遇就代表有环。（具体分析可以参考BM6）

那我们现在假定已经是一个有环的链表了，那么这个链表中怎么找到环的入口呢？在慢指针进入链表环之前，快指针已经进入了环，且在里面循环，这才能在慢指针进入环之后，快指针追到了慢指针，不妨假设快指针在环中走了n圈，慢指针在环中走了m圈，它们才相遇，而进入环之前的距离为x，环入口到相遇点的距离为y，相遇点到环入口的距离为z。快指针一共走了x+n(y+z)+y步，慢指针一共走了x+m(y+z)+y，这个时候快指针走的倍数是慢指针的两倍，则x+n(y+z)+y=2(x+m(y+z)+y)，这时候x+y=(n−2m)(y+z)，因为环的大小是y+z，说明从链表头经过环入口到达相遇地方经过的距离等于整数倍环的大小：那我们从头开始遍历到相遇位置，和从相遇位置开始在环中遍历，会使用相同的步数，而双方最后都会经过入口到相遇位置这y个节点，那说明这y个节点它们就是重叠遍历的，那它们从入口位置就相遇了，这我们不就找到了吗？

step 1：使用判断链表中是否有环中的方法判断链表是否有环，并找到相遇的节点。
step 2：慢指针继续在相遇节点，快指针回到链表头，两个指针同步逐个元素逐个元素开始遍历链表。
step 3：再次相遇的地方就是环的入口。

```
# -*- coding:utf-8 -*-
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None
class Solution:
    def EntryNodeOfLoop(self, pHead):
        # write code here
        slow = self.hasCycle(pHead)
        #没有环
        if slow == None: 
            return None
        #快指针回到表头
        fast = pHead 
        #再次相遇即是环入口
        while fast != slow: 
            fast = fast.next
            slow = slow.next
        return slow
    
    def hasCycle(self , head):
        #先判断链表为空的情况
        if head == None: 
            return None
        #快慢双指针
        fast = head 
        slow = head
        #如果没环快指针会先到链表尾
        while fast != None and fast.next != None: 
            #快指针移动两步
            fast = fast.next.next 
            #慢指针移动一步
            slow = slow.next 
            #相遇则有环
            if fast == slow: 
                #返回相遇的地方
                return slow 
        #到末尾则没有环
        return None 
```

复杂度分析：

时间复杂度：O(n)，最坏情况下遍历链表两次
空间复杂度：O(1)，使用了常数个指针，没有额外辅助空间

### BM8. 链表中倒数最后k个结点

题目的主要信息：
一个长度为n的链表，返回原链表中从倒数第k个结点至尾节点的全部节点
如果该链表长度小于k，请返回一个长度为 0 的链表
方法一：快慢双指针（推荐使用）
具体做法：

我们无法逆序遍历链表，就很难得到链表的倒数第k个元素，那我们可以试试反过来考虑，如果当前我们处于倒数第k的位置上，即距离链表尾的距离是k，那我们假设双指针指向这两个位置，二者同步向前移动，当前面个指针到了链表头的时候，两个指针之间的距离还是k。虽然我们没有办法让指针逆向移动，但是我们刚刚这个思路却可以正向实施：

step 1：准备一个快指针，从链表头开始，在链表上先走k步。
step 2：准备慢指针指向原始链表头，代表当前元素，则慢指针与快指针之间的距离一直都是k。
step 3：快慢指针同步移动，当快指针到达链表尾部的时候，慢指针正好到了倒数个元素的位置。

```
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param pHead ListNode类 
# @param k int整型 
# @return ListNode类
#
class Solution:
    def FindKthToTail(self , pHead: ListNode, k: int) -> ListNode:
        # write code here
        fast = pHead
        slow = pHead
        #快指针先行k步
        for i in range(0,k): 
            if fast != None:
                fast = fast.next
            #达不到k步说明链表过短，没有倒数k
            else: 
                return None
        #快慢指针同步，快指针先到底，慢指针指向倒数第k个
        while fast:
            fast = fast.next
            slow = slow.next
        return slow
```

复杂度分析：

时间复杂度：O(n)，总共遍历n个链表元素
空间复杂度：O(1)，常数级指针变量，无额外辅助空间使用

### BM9. 删除链表的倒数第n个节点

题目的主要信息：
给定一个链表，要删除链表倒数第n个节点，并返回链表的头
题目保证链表长度一定大于等于n
方法一：双指针（推荐使用）
具体做法：

我们无法逆序遍历链表，就很难得到链表的倒数第n个元素，那我们可以试试反过来考虑，如果当前我们处于倒数第n的位置上，即距离链表尾的距离是n，那我们假设双指针指向这两个位置，二者同步向前移动，当前面个指针到了链表头的时候，两个指针之间的距离还是n。虽然我们没有办法让指针逆向移动，但是我们刚刚这个思路却可以正向实施：

step 1：给链表添加一个表头，处理删掉第一个元素时比较方便。
step 2：准备一个快指针，在链表上先走n步。
step 3：准备慢指针指向原始链表头，代表当前元素，前序节点指向添加的表头，这样两个指针之间相距就是一直都是n。
step 4：快慢指针同步移动，当快指针到达链表尾部的时候，慢指针正好到了倒数n个元素的位置。

```
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param head ListNode类 
# @param n int整型 
# @return ListNode类
#
class Solution:
    def removeNthFromEnd(self , head: ListNode, n: int) -> ListNode:
        # write code here
        #添加表头
        res = ListNode(-1) 
        res.next = head
        #当前节点
        cur = head 
        #前序节点
        pre = res 
        fast = head
        #快指针先行n步
        while n: 
            fast = fast.next
            n = n - 1
        #快慢指针同步，快指针到达末尾，慢指针就到了倒数第n个位置
        while fast: 
            fast = fast.next
            pre = cur
            cur = cur.next
        #删除该位置的节点
        pre.next = cur.next 
        #返回去掉头
        return res.next 
```

复杂度分析：

时间复杂度：O(n)，其中n为链表长度，最坏情况遍历整个链表1次
空间复杂度：O(1)，常数级指针，无额外辅助空间使用

### BM10. 两个链表的第一个公共结点

题目中的信息：
两个链表含有公共结点或没有，有公共结点则返回第一公共结点指针
单链表，无循环
没有公共节点返回空
方法一：双指针长度比较法（推荐使用）
具体做法：

如果两个链表有公共节点，那么它们后半部分都是相同的，我们要找的也就是后半部分的第一个节点，只要遍历两个指针同时抵达第一个相同的节点，我们就找到了它。

step 1：单独的遍历两个链表，得到各自的长度。
step 2：求得两链表的长度差n，其中较长的链表的指针从头先走n步。
step 3：两链表指针同步向后遍历，遇到第一个相同的节点就是第一个公共结点。

```
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

#
# 
# @param pHead1 ListNode类 
# @param pHead2 ListNode类 
# @return ListNode类
#
class Solution:
    def FindFirstCommonNode(self , pHead1 , pHead2 ):
        # write code here
        count1 = 0
        count2 = 0
        temp1 = pHead1
        temp2 = pHead2
        while temp1:
            temp1 = temp1.next 
            count1 += 1
        while temp2:
            temp2 = temp2.next 
            count2 += 1
        if count1 > count2:
            count1,count2 = count2,count1 
            pHead1,pHead2 = pHead2,pHead1
        delta = count2 - count1
        
        i = 1
        while i <= delta:
            pHead2 = pHead2.next
            i += 1
        while pHead1 != pHead2:
            pHead1 = pHead1.next
            pHead2 = pHead2.next
        return pHead1
```

复杂度分析：

时间复杂度：O(n)，其中n为两链表较长者的长度，虽是多次循环，但都为单循环，取最大值即为O(n)
空间复杂度：O(1)，没有其他空间申请

### BM11. 两个链表生成相加链表

题目主要信息:
给定两个链表，每个链表中节点值都是0-9，每个链表就可以表示一个数字
将两个链表表示的数字相加，结果也存在链表中
方法：反转链表法（推荐使用）
具体做法：

既然链表每个节点表示数字的每一位，那相加的时候自然可以按照加法法则，从后往前依次相加。但是，链表是没有办法逆序访问的，这是我们要面对第一只拦路虎。解决它也很简单，既然从后往前不行，那从前往后总是可行的吧，将两个链表反转一下，即可得到个十百千……各个数字从前往后的排列，相加结果也是个位在前，怎么办？再次反转，结果不就正常了。

step 1：任意一个链表为空，返回另一个链表就行了，因为链表为空相当于0，0加任何数为0，包括另一个加数为0的情况。
step 2：相继反转两个待相加的链表，反转过程可以参考反转链表。
step 3：设置返回链表的链表头，设置进位carry=0.
step 4：从头开始遍历两个链表，直到两个链表节点都为空且carry也不为1. 每次取出不为空的链表节点值，为空就设置为0，将两个数字与carry相加，然后查看是否进位，将进位后的结果（对10取模）加入新的链表节点，连接在返回链表后面，并继续往后遍历。
step 5：返回前将结果链表再反转回来。

```
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param head1 ListNode类 
# @param head2 ListNode类 
# @return ListNode类
#
class Solution:
    #反转链表
    def ReverseList(self, pHead:ListNode): 
        if pHead == None:
            return None
        cur = pHead
        pre = None
        while cur:
            #断开链表，要记录后续一个
            temp = cur.next 
            #当前的next指向前一个
            cur.next = pre 
            #前一个更新为当前
            pre = cur 
            #当前更新为刚刚记录的后一个
            cur = temp 
        return pre
    
    def addInList(self , head1: ListNode, head2: ListNode) -> ListNode:
        #任意一个链表为空，返回另一个
        if head1 == None: 
            return head2
        if head2 == None:
            return head1
        #反转两个链表
        head1 = self.ReverseList(head1) 
        head2 = self.ReverseList(head2)
        #添加表头
        res = ListNode(-1) 
        head = res
        #进位符号
        carry = 0 
        #只要某个链表还有或者进位还有
        while head1 != None or head2 != None or carry != 0: 
            #链表不为空则取其值
            val1 = 0 if head1 == None else head1.val 
            val2 = 0 if head2 == None else head2.val
            #相加
            temp = val1 + val2 + carry 
            #获取进位
            carry = (int)(temp / 10) 
            temp %= 10
            #添加元素
            head.next = ListNode(temp) 
            head = head.next
            #移动下一个
            if head1: 
                head1 = head1.next
            if head2:
                head2 = head2.next
        #结果反转回来
        return self.ReverseList(res.next) 
```

复杂度分析：

时间复杂度：O(max(m,n))，其中m与n分别为两个链表的长度，翻转链表三次，复杂度分别是O(n)、O(m)、O(max(m,n))，相加过程也是遍历较长的链表
空间复杂度：O(1)，常数级指针，没有额外辅助空间，返回的新链表属于必要空间

### BM12. 单链表的排序

题目的主要信息：
给定一个无序链表，要将其排序为升序链表
方法一：归并排序（推荐使用）
具体做法：

前面我们做合并两个有序链表不是使用归并思想吗？说明在链表中归并排序也不是不可能使用，合并阶段可以参照前面这道题，两个链表逐渐取最小的元素就可以了，但是划分阶段呢？

常规数组的归并排序，是将数组从中间个元素开始划分，然后将划分后的子数组作为一个要排序的数组，再将排好序的两个子数组合并成一个完整的有序数组，因此采用的是递归。而链表中我们也可以用同样的方式，只需要找到中间个元素的前一个节点，将其断开，就可以将链表分成两个子链表，然后继续划分，直到最小，然后往上依次合并。

step 1：首先判断链表为空或者只有一个元素，直接就是有序的。

step 2：准备三个指针，快指针right每次走两步，慢指针mid每次走一步，前序指针left每次跟在mid前一个位置。三个指针遍历链表，当快指针到达链表尾部的时候，慢指针mid刚好走了链表的一半，正好是中间位置。

step 3：从left位置将链表断开，刚好分成两个子问题开始递归。

终止条件： 当子链表划分到为空或者只剩一个节点时，不再继续划分，往上合并。
返回值： 每次返回两个排好序且合并好的子链表。
本级任务： 找到这个链表的中间节点，从前面断开，分为左右两个子链表，进入子问题排序。
step 4：将子问题得到的链表合并，参考合并两个有序链表。

```
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param head ListNode类 the head node
# @return ListNode类
#
class Solution:
    #合并两段有序链表
    def merge(self, pHead1:ListNode, pHead2:ListNode) : 
        #一个已经为空了，直接返回另一个
        if pHead1 == None: 
            return pHead2
        if pHead2 == None:
            return pHead1
        #加一个表头
        head = ListNode(0) 
        cur = head
        #两个链表都要不为空
        while pHead1 and pHead2: 
            #取较小值的节点
            if pHead1.val <= pHead2.val: 
                cur.next = pHead1
                #只移动取值的指针
                pHead1 = pHead1.next 
            else:
                cur.next = pHead2
                #只移动取值的指针
                pHead2 = pHead2.next 
            #指针后移
            cur = cur.next 
        #哪个链表还有剩，直接连在后面
        if pHead1: 
            cur.next = pHead1
        else:
            cur.next = pHead2
        #返回值去掉表头
        return head.next 
    
    def sortInList(self , head ):
        #链表为空或者只有一个元素，直接就是有序的
        if head == None or head.next == None: 
            return head
        left = head
        mid = head.next
        right = head.next.next
        #右边的指针到达末尾时，中间的指针指向该段链表的中间
        while right and right.next:
            left = left.next
            mid = mid.next
            right = right.next.next
        #左边指针指向左段的左右一个节点，从这里断开
        left.next = None 
        #分成两段排序，合并排好序的两段
        return self.merge(self.sortInList(head), self.sortInList(mid)) 
```

复杂度分析：

时间复杂度：O(nlog2n)，每级划分最坏需要遍历链表全部元素，因此为O(n)，每级合并都是将同级的子问题链表遍历合并，因此也为O(n)，分治划分为二叉树型，一共有O(log2n)层，因此复杂度为O((n+n)∗log2n)=O(nlog2n)
空间复杂度：O(log2n)，递归栈的深度最坏为树型递归的深度，log2n层

### BM13. 判断一个链表是否为回文结构

题目的主要信息：
给定一个链表的头节点，判读该链表是否为回文结构
回文结构即正序遍历与逆序遍历结果都是一样的，类似123321
空链表默认为回文结构

方法四：双指针找中点（推荐使用）
具体做法：

上述方法四找中点，我们遍历整个链表找到长度，又遍历长度一半找中点位置。过程过于繁琐，我们想想能不能优化一下，一次性找到中点。

我们首先来看看中点的特征，一个链表的中点，距离链表开头是一半的长度，距离链表结尾也是一半的长度，那如果从链表首遍历到链表中点位置，另一个每次遍历两个节点的指针是不是就到了链表尾，那这时候我们的快慢双指针就登场了：

step 1：慢指针每次走一个节点，快指针每次走两个节点，快指针到达链表尾的时候，慢指针刚好到了链表中点。
step 2：从中点的位置，开始往后将后半段链表反转。
step 3：按照方法四的思路，左右双指针，左指针从链表头往后遍历，右指针从链表尾往反转后的前遍历，依次比较遇到的值。

```
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param head ListNode类 the head
# @return bool布尔型
#
class Solution:
    #反转链表指针
    def reverse(self, head:ListNode): 
        #前序节点
        prev = None 
        while head:
            #断开后序
            next = head.next 
            #指向前序
            head.next = prev 
            prev = head
            head = next
        return prev
    
    def isPail(self , head: ListNode) -> bool:
        #空链表直接为回文
        if head == None:  
            return True
        #准备快慢双指针
        slow = head 
        fast = head
        #双指针找中点
        while fast and fast.next: 
            slow = slow.next
            fast = fast.next.next
        #中点处反转
        slow = self.reverse(slow) 
        fast = head
        while slow:
            #比较判断节点值是否相等
            if slow.val != fast.val: 
                return False
            fast = fast.next
            slow = slow.next
        return True
```

复杂度分析：

时间复杂度：O(n)，其中n为链表的长度，双指针找到中点遍历半个链表，后续反转链表为O(n)，然后再遍历两份半个链表
空间复杂度：O(1)，常数级变量，没有额外辅助空间

### BM14 链表的奇偶重排

题目主要信息:
给定一个链表，将奇数位的节点依次连在前半部分，偶数位的节点依次连在后半部分
返回连接后的链表头
方法：双指针（推荐使用）
具体做法：

如下图所示，第一个节点是奇数位，第二个节点是偶数，第二个节点后又是奇数位，因此可以断掉节点1和节点2之间的连接，指向节点2的后面即节点3，如红色箭头。如果此时我们将第一个节点指向第三个节点，就可以得到那么第三个节点后为偶数节点，因此我们又可以断掉节点2到节点3之间的连接，指向节点3后一个节点即节点4，如蓝色箭头。那么我们再将第二个节点指向第四个节点，又回到刚刚到情况了。

step 1：判断空链表的情况，如果链表为空，不用重排。
step 2：使用双指针odd和even分别遍历奇数节点和偶数节点，并给偶数节点链表一个头。
step 3：上述过程，每次遍历两个节点，且even在后面，因此每轮循环用even检查后两个元素是否为NULL，如果不为再进入循环进行上述连接过程。
step 4：将偶数节点头接在奇数最后一个节点后，再返回头部。

```
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param head ListNode类 
# @return ListNode类
#
class Solution:
    def oddEvenList(self , head: ListNode) -> ListNode:
         #如果链表为空，不用重排
        if head == None:
            return head
        #even开头指向第二个节点，可能为空
        even = head.next 
        #odd开头指向第一个节点
        odd = head 
        #指向even开头
        evenhead = even 
        while even and even.next:
            #odd连接even的后一个，即奇数位
            odd.next = even.next 
            #odd进入后一个奇数位
            odd = odd.next 
            #even连接后一个奇数的后一位，即偶数位
            even.next = odd.next 
            #even进入后一个偶数位
            even = even.next 
        #even整体接在odd后面
        odd.next = evenhead 
        return head
```

复杂度分析：

时间复杂度：O(n)，遍历一次链表的所有节点
空间复杂度：O(1)，常数级指针，无额外辅助空间

### BM15 删除有序链表中重复的元素-I

题目主要信息:
给定一个从小到大排好序的链表
删去链表中重复的元素，每个值只留下一个节点
方法：遍历删除（推荐使用）
具体做法：

既然相同的元素只留下一个，我们留下哪一个最好呢？当然是遇到的第一个元素了！因为第一个元素直接就与前面的链表节点连接好了，前面就不用管了，只需要跳过后面重复的元素，连接第一个不重复的元素就可以了，在链表中连接后面的元素总比连接前面的元素更方便嘛，因为不能逆序访问。

step 1：判断链表是否为空链表，空链表不处理直接返回。
step 2：使用一个指针遍历链表，如果指针当前节点与下一个节点的值相同，我们就跳过下一个节点，当前节点直接连接下个节点的后一位。
step 3：如果当前节点与下一个节点值不同，继续往后遍历。
step 4：循环过程中每次用到了两个节点值，要检查连续两个节点是否为空。

```
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param head ListNode类 
# @return ListNode类
#
class Solution:
    def deleteDuplicates(self , head: ListNode) -> ListNode:
        #空链表
        if head == None: 
            return None
        #遍历指针
        cur = head 
        #指针当前和下一位不为空
        while cur and cur.next: 
            #如果当前与下一位相等则忽略下一位
            if(cur.val == cur.next.val):  
                cur.next = cur.next.next
            #否则指针正常遍历
            else: 
                cur = cur.next
        return head
```

复杂度分析：

时间复杂度：O(n)，其中n为链表长度，遍历一次链表
空间复杂度：O(1)，常数级指针变量使用，没有使用额外的辅助空间

### BM16 删除有序链表中重复的元素-II

题目的主要信息：
在一个非降序的链表中，存在重复的节点，删除该链表中重复的节点
重复的节点一个元素也不保留
方法一：直接比较删除（推荐使用）
具体做法：

这是一个升序链表，重复的节点都连在一起，我们就可以很轻易地比较到重复的节点，然后去删除。

step 1：给链表前加上表头，方便可能的话删除第一个节点。
step 2：遍历链表，每次比较相邻两个节点，如果遇到了两个相邻结点相同，则新开内循环将这一段所有的相同都遍历过去。
step 3：在step 2中这一连串相同的节点前的节点直接连上后续第一个不相同值的节点。
step 4：返回时去掉添加的表头。

```
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param head ListNode类 
# @return ListNode类
#
class Solution:
    def deleteDuplicates(self , head: ListNode) -> ListNode:
        #空链表
        if head == None: 
            return None
        res = ListNode(0)
        #在链表前加一个表头
        res.next = head 
        cur = res
        while cur.next and cur.next.next: 
            #遇到相邻两个节点值相同
            if cur.next.val == cur.next.next.val: 
                temp = cur.next.val
                #将所有相同的都跳过
                while cur.next != None and cur.next.val == temp: 
                    cur.next = cur.next.next
            else:
                cur = cur.next
        #返回时去掉表头
        return res.next 
```

复杂度分析：

时间复杂度：O(n)，其中n为链表节点数，只有一次遍历
空间复杂度：O(1)，只开辟了临时指针，常数级空间

## 02二分查找/排序

### BM17 二分查找-I

题目的主要信息：
给定一个元素升序的、无重复数字的整型数组 nums 和一个目标值 target 
找到目标值的下标
如果找不到返回-1

方法一：二分法（推荐使用）
具体做法：

既然数组是升序且无重复的，可以使用二分法。

step 1：从数组首尾开始，每次取中点值。
step 2：如果中间值等于目标即找到了，可返回下标，如果中点值大于目标，说明中点以后的都大于目标，因此目标在中点左半区间，如果中点值小于目标，则相反。
step 3：根据比较进入对应的区间，直到区间左右端相遇，意味着没有找到。

```
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param nums int整型一维数组 
# @param target int整型 
# @return int整型
#
class Solution:
    def search(self , nums: List[int], target: int) -> int:
        l = 0
        r = len(nums) - 1
        # 从数组首尾开始，直到二者相遇
        while l <= r :
            # 每次检查中点的值 
            m = int((l+r)/2) 
            if nums[m] == target:
                return m
            # 进入左的区间
            if nums[m] > target: 
                r = m - 1
            # 进入右区间
            else: 
                l = m + 1
        # 未找到
        return -1 
```

复杂度分析：

时间复杂度：O(log2n)，对长度为nnn的数组进行二分，最坏情况就是取2的对数
空间复杂度：O(1)，常数级变量，无额外辅助空间

### BM18. 二维数组中的查找

题目的主要信息：
矩阵的行元素和列元素都是有序的，从左到右递增，从上到下递增，完全递增元素不会有重复
找到矩阵中有没有给定元素即可
方法一：二分查找（推荐使用）
具体做法：

既然矩阵里面的元素是有序且无重复的，我们可以好好利用一下。

首先看四个角，左上与右下必定为最小值与最大值，而左下与右上就有规律了：左下元素大于它上方的元素，小于它右方的元素，右上元素与之相反。我们可以在查找时使用二分法：

step 1：首先获取矩阵的两个边长，判断特殊情况。
step 2：首先以左下角为起点，若是它小于目标元素，则往右移动去找大的，若是他大于目标元素，则往上移动去找小的。
step 3：若是移动到了矩阵边界也没找到，说明矩阵中不存在目标值。

```
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param target int整型 
# @param array int整型二维数组 
# @return bool布尔型
#
class Solution:
    def Find(self , target: int, array: List[List[int]]) -> bool:
        # 优先判断特殊
        if len(array) == 0: 
            return False
        n = len(array)
        if len(array[0]) == 0:
            return False
        m = len(array[0])
        i = n-1
        j = 0
        # 从最左下角的元素开始往左或往上
        while i >=0 and j < m: 
            # 元素较大，往上走
            if array[i][j] > target: 
                i -= 1
            # 元素较小，往右走
            elif array[i][j] < target: 
                j += 1
            else:
                return True
        return False
```

复杂度分析：

时间复杂度：O(m+n)，遍历矩阵的时候，最多经过矩阵的一行一列
空间复杂度：O(1)，常数级变量，无额外辅助空间

### BM19 寻找峰值

题目主要信息:
给定一个长度为n的数组，返回其中任何一个峰值的索引
峰值元素是指其值严格大于左右相邻值的元素
数组两个边界可以看成是最小，
峰值不存在平的情况，即相邻元素不会相等
方法：二分查找（推荐使用）
具体做法：

因为数组边界看成最小值，因此只要不断地往高处走，一定会有波峰，最大值两边一定比它小。那可以考虑二分查找。

step 1：二分查找首先从数组首尾开始，每次取中间值，直到首尾相遇。
step 2：如果中间值的元素大于它右边的元素，说明往右是向下，我们不一定会遇到波峰，但是那就往左收缩区间。
step 3：如果中间值大于右边的元素，说明此时往右是向上，向上一定能有波峰，那我们往右收缩区间。
step 4：最后区间收尾相遇的点一定就是波峰。

```
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param nums int整型一维数组 
# @return int整型
#
class Solution:
    def findPeakElement(self , nums: List[int]) -> int:
        left = 0
        right = len(nums) - 1
        # 二分法
        while left < right: 
            mid = int((left + right) / 2)
            # 右边是往下，不一定有坡峰
            if nums[mid] > nums[mid+1]: 
                right = mid
            # 右边是往上，一定能找到波峰
            else: 
                left = mid + 1
        # 其中一个波峰
        return right 
```

复杂度分析：

时间复杂度：O(log2n)，二分法最坏情况对整个数组连续二分，最多能分log2n次
空间复杂度：O(1)，常数级变量，无额外辅助空间

### BM20. 数组中的逆序对

题目的主要信息：
在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。
输入一个数组，求一个数组的全部逆序对，答案对1000000007取模
保证输入的数组中没有的相同的数字
方法一：归并排序(推荐使用)
具体做法：

因为我们在归并排序过程中会将数组划分成最小为2个元素的子数组，然后依次比较子数组的长度，这里我们也可以用相同的方法统计逆序对。我们主要有三个阶段：

step 1： 划分阶段：将待划分区间从中点划分成两部分；
step 2： 排序阶段：使用归并排序递归地处理子序列，同时统计逆序对；
step 3： 合并阶段：将排好序的子序列合并，同时累加逆序对。
因为在归并排序中，右边大于左边时，它大于了左边的所有子序列，基于这个性质我们可以不用每次加1来统计，减少运算次数。

```
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param data int整型一维数组 
# @return int整型
#
class Solution:
    mod = 1000000007
    def MergeSort(self, left: int, right: int, data: List[int], temp: List[int]) -> int:
         # 停止划分
        if left >= right:
            return 0
        # 取中间
        mid = int((left + right) / 2) 
        # 左右划分合并
        res = self.MergeSort(left, mid, data, temp) + self.MergeSort(mid + 1, right, data, temp) 
        # 防止溢出
        res %= self.mod 
        i, j = left, mid + 1
        for k in range(left, right+1):
            temp[k] = data[k]
        for k in range(left, right+1):
            if i == mid + 1:
                data[k] = temp[j]
                j += 1
            elif j == right + 1 or temp[i] <= temp[j]:
                data[k] = temp[i]
                i += 1
            # 左边比右边大，答案增加
            else: 
                data[k] = temp[j]
                j += 1
                # 统计逆序对
                res += mid - i + 1 
        return res % self.mod
            
    def InversePairs(self , data: List[int]) -> int:
        n = len(data)
        res = [0 for i in range(n)]
        return self.MergeSort(0, n - 1, data, res)
```

复杂度分析：

时间复杂度：O(nlog2n)，归并排序利用分治思想，树型递归每次二分，总共能分为log2n层，每层合并都需要遍历数组所有元素即O(n)

空间复杂度：O(n)，辅助数组temp长度为n及递归栈最大深度不会超过n
